---
layout:     post
title:      "leetcode整理"
subtitle:   ""
date:       2020-01-16 12:00:00
author:     "盈盈冲哥"
header-img: "img/godfather-michael.jpg"
mathjax: true
catalog: true
tags:
    - 学习
---

## 目录

- [基础](#基础)
- [分治](#分治)
- [散列](#散列)
- [字符串](#字符串)

## 基础

#### 频率

[leetcode难度及面试频率](<https://blog.csdn.net/yutianzuijin/article/details/11477603>)

#### 主方法

![img](/img/post/the-master-method.PNG)

![img](/img/post/the-master-method-2.PNG)

![img](/img/post/the-master-method-3.PNG)

对于形式$T(n)=aT(n/b)+f(n)$的递归，分为3种情况：

1. $f(n)=O(n^{\log_ba-\varepsilon})$

   $f(n)$多项式地慢于$n^{\log_ba}$增长（相差$n^\varepsilon$）

   结论：$T(n)=\Theta(n^{\log_ba})$

2. $f(n)=\Theta(n^{\log_ba}\log^kn)$

   $f(n)$与$n^{\log_ba}$以相似速率增长

   结论：$T(n)=\Theta(n^{\log_ba}\log^{k+1}n)$

3. $f(n)=\Omega(n^{\log_ba+\varepsilon})$

   $f(n)$多项式地快于$n^{\log_ba}$增长（相差$n^\varepsilon$）

   结论：$T(n)=\Theta(f(n))$

## 分治

#### 二分查找

- 一般的二分查找

  ```c++
  int binarySearch(int n, int key) {
      int lo = 0;
      int hi = n - 1;
      while(lo <= hi) {
          int mid = (lo + hi) / 2;
          if(num[mid] < key) lo = mid + 1;
          else if(num[mid] > key) hi = mid - 1;
          else return mid;
      }
      return lo;
  }
  ```

- 找到第一个大于等于目标值的位置

  解释：如果目标值大于中间数，在右半边查找；如果目标值小于等于中间数，在左半边查找。当目标值等于中间数时，将会放弃中间数在左半边查找，最后一次循环`lo == hi`时，`lo`的值又会增1​，所以可以找到等于目标值的第一个数。

  ```c++
  int binarySearch(int n, int key) {
      int lo = 0;
      int hi = n - 1;
      while(lo <= hi) {
          int mid = (lo + hi) / 2;
          if(num[mid] < key) lo = mid + 1;
          else hi = mid - 1;
      }
      return lo;
  }
  ```

#### [leetcode 74: 搜索二维矩阵](<https://leetcode.com/problems/search-a-2d-matrix/>)

- 题意：矩阵中行有序，后面一行的第一个数比前一行最后一个数大。

- 方法1：两次二分查找

  - 思路：先二分查找到目标值可能在的那一行（比较方便的方法是找到最后一列大于等于目标值的那一行），然后二分查找那一行。

  - 时间：$O(\log m+\log n)=O(\log mn)$

  - 代码

    ```c++
    class Solution {
    public:
        bool searchMatrix(vector<vector<int>>& matrix, int target) {
            // [] => 0
            // [[]] => 0
            if(matrix.size() == 0) return false;
            if(matrix[0].size() == 0) return false;
            
            // binary search row
            // <=
            int lo = 0;
            int hi = matrix.size() - 1;
            while(lo <= hi) {
                int mid = (lo + hi) / 2;
                if(matrix[mid][0] < target) lo = mid + 1;
                else  hi = mid - 1;
            }
            if(lo < matrix.size() && matrix[lo][0] == target) return true;
            if(lo == 0) return false;
            int row = lo - 1;
            
            // binary search col
            // >=
            lo = 0;
            hi = matrix[row].size() - 1;
            while(lo <= hi) {
                int mid = (lo + hi) / 2;
                if(matrix[row][mid] < target) lo = mid + 1;
                else  hi = mid - 1;
            }
            if(lo < matrix[row].size() && matrix[row][lo] == target) return true;
            return false;
        }
    };
    ```

- 方法2：一次二分查找

  - 思路：直接当成一维数组进行二分查找。

  - 时间：$O(\log mn)$

  - 代码

    ```c++
    class Solution {
    public:
        bool searchMatrix(vector<vector<int>>& matrix, int target) {
            // [] => 0
            // [[]] => 0
            int rows = matrix.size();
            if(rows == 0) return false;
            int cols = matrix[0].size();
            if(cols == 0) return false;
            
            int lo = 0;
            int hi = rows * cols - 1;
            while(lo <= hi) {
                int mid = (lo + hi) / 2;
                if(matrix[mid/cols][mid%cols] < target) lo = mid + 1;
                else hi = mid - 1;
            }
            if(lo < rows * cols && matrix[lo/cols][lo%cols] == target) return true;
            return false;
        }
    };
    ```

#### [leetcode 240: 搜索二维矩阵II](<https://leetcode.com/problems/search-a-2d-matrix-ii/>)

- 题意：矩阵中行有序列有序，查找目标值。

- 方法1：分治

  - 思路：第4象限的数一定比中间值大，第3象限的数一定比中间值小，所以比较中间值与目标值的大小，可以将问题转化为3个子问题。

    ```
      zone 1      zone 2
    *  *  *  * | *  *  *  *
    *  *  *  * | *  *  *  *
    *  *  *  * | *  *  *  *
    *  *  *  * | *  *  *  *
    -----------------------
    *  *  *  * | *  *  *  *
    *  *  *  * | *  *  *  *
    *  *  *  * | *  *  *  *
    *  *  *  * | *  *  *  *
      zone 3      zone 4
    ```

  - 时间：$T(mn)=3T(mn/4)+O(1)$，根据主方法，$T(mn)=\Theta((mn)^{\log_43})$.
  - [参考](<https://leetcode.com/problems/search-a-2d-matrix-ii/discuss/66147/*Java*-an-easy-to-understand-divide-and-conquer-method>)
  - 代码

    ```c++
    class Solution {
    public:
        bool searchMatrix(vector<vector<int>>& matrix, int target) {
            if(matrix.empty()) return false;
            if(matrix[0].empty()) return false;
            int rows = matrix.size();
            int cols = matrix[0].size();
            
            return searchMatrix(matrix, target, 0, 0, rows-1, cols-1);
        }
    
    private:
        bool searchMatrix(vector<vector<int>>& matrix, int target, int loI, int loJ, int hiI, int hiJ) {
            cout << loI << " " << loJ << " " << hiI << " " << hiJ << endl;
            if(loI > hiI || loJ > hiJ) return false;
            if(loI == hiI && loJ == hiJ) return matrix[loI][loJ] == target;
            
            int midI = (loI + hiI) / 2;
            int midJ = (loJ + hiJ) / 2;
            if(matrix[midI][midJ] > target) {
                if(searchMatrix(matrix, target, loI, loJ, midI, midJ)) return true;       // 1st quadrant
                if(searchMatrix(matrix, target, loI, midJ+1, midI, hiJ)) return true;     // 2nd quadrant
                if(searchMatrix(matrix, target, midI+1, loJ, hiI, midJ)) return true;     // 3rd quadrant
            } else if(matrix[midI][midJ] < target) {
                if(searchMatrix(matrix, target, loI, midJ+1, midI, hiJ)) return true;     // 2nd quadrant
                if(searchMatrix(matrix, target, midI+1, loJ, hiI, midJ)) return true;     // 3rd quadrant
                if(searchMatrix(matrix, target, midI+1, midJ+1, hiI, hiJ)) return true;   // 4rd quadrant
            } else {
                return true;
            }
            return false;
        }
    };
    ```

- 方法2：二叉搜索树

  - 思路：将矩阵视为二叉搜索树，根节点为矩阵右上角或左下角的节点。

    ![img](https://assets.leetcode.com/static_assets/discuss/uploads/files/1488858512318-monosnap-2017-03-06-22-48-17.jpg)

  - 时间：$O(m+n)$

  - 代码

    ```c++
    class Solution {
    public:
        bool searchMatrix(vector<vector<int>>& matrix, int target) {
            if(matrix.empty()) return false;
            if(matrix[0].empty()) return false;
            int rows = matrix.size();
            int cols = matrix[0].size();
            
            int i = 0;
            int j = cols - 1;
            while(i < rows && j >= 0) {
                if(matrix[i][j] == target) return true;
                else if(matrix[i][j] > target) j--;
                else i++;
            }
            return false;
        }
    };
    ```

#### [leetcode 4: 寻找两个有序数组的中位数](<https://leetcode.com/problems/median-of-two-sorted-arrays/>)



#### [leetcode 378: 有序矩阵中第K小的数](<https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/>)



## 散列

#### [leetcode 1: 两数之和](<https://leetcode.com/problems/two-sum/>)

- 题意：在数组中寻找两数之和等于目标值。

- 思路：用一个散列表记录数组中的值和索引的关系。

- 时间：$O(n)$

- 代码

  ```c++
  class Solution {
  public:
      vector<int> twoSum(vector<int>& nums, int target) {
          vector<int> result(2);
          unordered_map<int, int> hash;
          for(int i = 0; i < nums.size(); i++) {
              if(hash.find(target - nums[i]) != hash.end()) {
                  result[0] = hash[target - nums[i]];
                  result[1] = i;
                  return result;
              }
              hash[nums[i]] = i;
          }
          return result;
      }
  };
  ```

## 字符串

#### [leetcode 3: 无重复字符的最长子字符串](<https://leetcode.com/problems/longest-substring-without-repeating-characters/>)

- 思路：双指针。

  利用散列表记录所有当前字符串中字符出现的位置。尽可能将右指针向右移动，直到出现重复的字符，这时将左指针向右移去除重复的字符。

- 时间：$O(n)$

- 代码

  ```c++
  class Solution {
  public:
      int lengthOfLongestSubstring(string s) {     
          unprdered_map<char, int> m;
          int start = 0;
          int max = 0;
          
          for(int i = 0; i < s.length(); i++) {
              char c = s[i];
              if(m.find(c) != m.end())
                  start = std::max(start, m[c] + 1);
              max = std::max(max, i - start + 1);
              m[c] = i;
          }
          return max;
      }
  };
  ```

#### [leetcode 5: 最长回文子串](<https://leetcode.com/problems/longest-palindromic-substring/>)

#### [leetcode 395: 至少有K个重复字符的最长子串](<https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/>)

## 双指针

#### [leetcode 43: 接雨水](<https://leetcode.com/problems/trapping-rain-water/>)

## 栈

#### [leetcode 84: 柱状图中最大矩形](<https://leetcode.com/problems/largest-rectangle-in-histogram>)

## 动态规划

#### [leetcode 221: 最大正方形](<https://leetcode.com/problems/maximal-square/>)

#### [leetcode 85: 最大矩形](<https://leetcode.com/problems/maximal-rectangle/>)

