---
layout:     post
title:      "Java整理"
subtitle:   ""
date:       2020-01-20 12:00:00
author:     "盈盈冲哥"
header-img: "img/fleabag.jpg"
mathjax: true
catalog: true
tags:
    - 学习
---

## 目录

- [Java](#java)
- [网络](#网络)
- [操作系统](#操作系统)
- [数据库](#数据库)
- [系统设计](#系统设计)
- [工具](#工具)

## Java

#### 基础

- 面对对象语言的特点：**封装**、**继承**、**多态**（指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用））（引用变量指向哪个类的实例对象，引用对象发出的方法调用哪个类中的实现的方法，在程序运行期间才能确定）。

- JVM、JDK、JRE

  - **Java虚拟机(JVM)**实现**平台无关性**，是运行**Java字节码**（.class文件）的虚拟机。
  - .java源代码（通过JDK中的javac编译）.class字节码（通过JVM）机器码。
  - **JDK包括JRE**、javac、jdb等，能够创建和**编译程序**；**JRE**是**Java运行环境**，用于运行已编译的Java程序，包括JVM等。

- Java与C++的区别

  - Java**没有指针来直接访问内存**，访问内存更安全。
  - 有**自动内存管理机制**，不需要手动释放内存。
  - Java的类是**单继承**的，接口可以多继承，C++支持多继承。
  - Java字符串没有\0，因为Java里**一切都是对象**，可以确定长度。

- Java的接口和C++的虚类的相同和不同处

  - 由于Java不支持多继承，而有可能某个类或对象要使用分别在几个类或对象里面的方法或属性，现有的单继承机制就不能满足要求。
  - 与继承相比，接口有更高的灵活性，因为接口中没有任何实现代码。当一个类实现了接口以后，该类要实现接口里面所有的方法和属性。

  > [https://blog.csdn.net/chwshuang/article/details/46943711](<https://blog.csdn.net/chwshuang/article/details/46943711>)

  - C++虚类相当于java中的抽象类，一个子类只能继承一个抽象类（虚类），但能实现多个接口
  - 一个抽象类可以有构造方法，接口没有构造方法
  - 一个抽象类中的方法不一定是抽象方法，即其中的方法可以有实现（有方法体），接口中的方法都是抽象方法，不能有方法体，只有声明
  - 一个抽象类可以是public、private、protected、default，接口只有public
  - 一个抽象类中的方法可以是public、private、protected、default，接口中的方法只能是public和default
  - 相同之处是：都不能实例化。

- **构造器（private方法）**不能**重写**（override），但是可以**重载**（overload），一个类中可以有多个构造器。

- **重写**（override）和**重载**（overload）的区别

  - 方法的重写和重载都是实现多态的方式，区别在于前者实现的是运行的多态性，而后者实现的是编译时的多态性。

  - 重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，不能比父类被重写方法声明更多的异常（里氏代换原则）

  - 重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载。

  - 重载是否区分返回值类型？重载不根据返回类型进行区分。

  - Overloaded的方法是否可以改变返回值的类型？

    > [https://blog.csdn.net/singit/article/details/47722047](https://blog.csdn.net/singit/article/details/47722047)

    这个题目很模糊。如果几个Overloaded的方法的参数列表不一样，它们的返回者类型当然也可以不一样。但我估计你想问的问题是：如果两个方法的参数列表完全一样，是否可以让它们的返回值不同来实现重载Overload。这是不行的。

    我们可以用反证法来说明这个问题，因为我们有时候调用一个方法时也可以不定义返回结果变量，即不要关心其返回结果，例如，我们调用map.remove(key)方法时，虽然remove方法有返回值，但是我们通常都不会定义接收返回结果的变量，这时候假设该类中有两个名称和参数列表完全相同的方法，仅仅是返回类型不同，java就无法确定编程者倒底是想调用哪个方法了，因为它无法通过返回结果类型来判断。

- String、Stringbuffer、StringBuilder

  - **String**类中使用**final**关键字修饰字符数组来保存字符串，对象**不可变**，**线程安全**。
  - StringBuffer和StringBuilder构造方法调用父类AbstractStringBuffer实现，是**可变**的。
  - **StringBuffer**对方法加了**同步锁**，是**线程安全**的；**StringBuilder**没有加同步锁，非线程安全。
  - 底层实现上的话，StringBuffer其实就是比StringBuilder多了Synchronized修饰符。

- **装箱**：基本类型用对应的引用类型包装起来。

  **拆箱**：包装类型转换为基本数据类型。

- 静态方法内不能调用非静态成员，因为静态方法可以不通过对象进行调用。

- 不做事且没有参数的构造方法的作用：子类中没有用super()方法来调用父类特定的构造方法，**会调用父类中没有参数的构造方法**。

- **接口**和**抽象类**的区别

  - **方法在接口中不能有实现**，而抽象类可以有非抽象方法。
  - 接口中除了static、final变量，不能有其他变量。
  - **一个类可以实现多个接口，但只能实现一个抽象类**。接口可以通过extends关键字扩展多个接口。
  - 接口方法默认是public，抽象方法可以有public、protected、default（不能使用private）。
  - 抽象类是对类的抽象，接口是对行为的抽象。

- **成员变量**和**局部变量**的区别

  - 成员变量属于类，局部变量是在方法中定义的变量或方法的参数；成员变量可以被public、private、static等修饰符修饰，局部变量不能被访问控制符及static所修饰；成员变量和局部变量都能被final修饰。
  - 成员变量如果使用static修饰属于类，否则属于实例。对象存在堆中，局部变量存在栈中，**静态变量存在方法区**（静态区）。
  - 成员变量是对象的一部分，随着对象的创建而存在；局部变量随着方法的调用而自动消失。
  - 成员变量如果没有赋初值会自动赋默认值，局部变量不会自动赋值。

- 构造方法

  - 名字于类名相同。
  - 没有返回值，不能用void声明构造函数。
  - 生成类的对象时自动执行，无需调用。如果没有声明构造方法，会有默认的不带参数的构造函数。
  - 作用时完成堆类对象的初始化工作。

- **静态方法**和**实例方法**的区别

  - 在外部调用静态方法：类名.方法名、对象名.方法名；实例方法：对象名.方法名。
  - 静态方法在访问本类成员时，只允许访问静态成员（静态成员变量、静态方法），不允许访问实例成员变量和实例方法。

- **==**和**equals()**的区别

  - ==：判断两个对象的地址是不是相等。
  - equals()
    - 情况1：类没有覆盖equals()方法时，等价于==。
    - 情况2：覆盖类equals()方法，来比较两个对象的内容是否相等。

- **hashCode()**和**equals()**的区别

  - hashCode()的作用：获取散列码，实际上是一个int整数。
  - 为什么要有散列码？以“HashSet”如何检查重复为例：**当把对象假如HashSet时，HashSet会先计算散列码，如果没有相符的散列码，HashSet会假设对象没有重复出现，如果发现有相同散列码的对象，会调用equals()方法来检查对象是否真的相同。如果两者相同，HashSet就不会让它加入，否则就会重新散列到其他位置。这样就大大减少equals()的次数，提高执行速度。**
  - 相关规定
    - **如果两个对象相等，则散列码相同。**
    - 如果两个对象相等，则两个对象分别调用equals()方法都返回true。
    - 两个对象有相同的散列码，它们也不一定是相等的。
    - **equals()方法被覆盖过，则hashCode()方法也必须被覆盖**。
    - hashCode()的默认行为是对堆上的对象产生独特值，如果没有重写hashcode()，则同一个类的两个对象无论如何不会相等。

- 为什么**Java中只有值传递**

  - 例1

    ```java
    public static void main(String[] args) {
    	int[] arr = { 1, 2, 3, 4, 5 };
    	System.out.println(arr[0]);
    	change(arr);
    	System.out.println(arr[0]);
    }
    
    public static void change(int[] array) {
    	// 将数组的第一个元素变为0
    	array[0] = 0;
    }
    ```

    结果

    ```
    1
    0
    ```

    解析：**方法得到的是对象引用的拷贝，对象引用及对象引用的拷贝同时引用同一个对象**。

    ![example 2](https://camo.githubusercontent.com/b7bad9506150c29bb8d7debd3905bd7a71cd6611/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d32372f333832353230342e6a7067)

  - 例2

    ```java
    public class Test {
    
    	public static void main(String[] args) {
    		// TODO Auto-generated method stub
    		Student s1 = new Student("小张");
    		Student s2 = new Student("小李");
    		Test.swap(s1, s2);
    		System.out.println("s1:" + s1.getName());
    		System.out.println("s2:" + s2.getName());
    	}
    
    	public static void swap(Student x, Student y) {
    		Student temp = x;
    		x = y;
    		y = temp;
    		System.out.println("x:" + x.getName());
    		System.out.println("y:" + y.getName());
    	}
    }
    ```

    结果

    ```
    x:小李
    y:小张
    s1:小张
    s2:小李
    ```

    解析

    交换之前：

    ![img](https://camo.githubusercontent.com/9d6dd0313695d309280675cd3251b47432a28814/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d32372f38383732393831382e6a7067)

    交换之后：

    ![img](https://camo.githubusercontent.com/6bea9b0ed65609d699207ab787f631f7ba0a9246/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d32372f33343338343431342e6a7067)

    方法并没有改变存储在变量s1和s2中的对象引用。

  - 总结

    **Java中对对象采用的不是引用调用，对象引用是按值传递的**，因此一个方法不能让对象参数引用一个新的对象。

- Java中的异常处理

  - 异常类层次结构

    ![Java异常类层次结构图](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-2/Exception.png)

    **Throwable类**分为两个子类：**Exception（异常）**和**Error（错误）**。

    **Error是程序无法处理的错误**。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。

    **Exception是程序本身可以处理的异常**。Exception 类有一个重要的子类 **RuntimeException**。RuntimeException 异常由Java虚拟机抛出。**NullPointerException**（要访问的变量没有引用任何对象时，抛出该异常）、**ArithmeticException**（算术运算异常，一个整数除以0时，抛出该异常）和 **ArrayIndexOutOfBoundsException** （下标越界异常）。

  - 异常处理总结

    - **try 块：** 用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。

    - **catch 块：** 用于处理try捕获到的异常。

    - **finally 块：** 无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return 语句时，finally语句块将在方法返回之前被执行。

    - **注意：** 当try语句和finally语句中都有return语句时，在方法返回之前，finally语句的内容将被执行，并且finally语句的返回值将会覆盖原始的返回值。以下代码如果调用 `f(2)`，返回值将是0，因为finally语句的返回值覆盖了try语句块的返回值。

      ```java
      public static int f(int value) {
      	try {
          	return value * value;
          } finally {
          	if (value == 2) {
              	return 0;
              }
          }
      }
      ```

  - 请说明JAVA语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？

    - throw：用来明确地抛出一个“异常”。

    - throws：标明一个成员函数可能抛出的各种“异常”。
    - 可以在try里手动抛出异常，不过比较少见；也可以在try里嵌套try。

- transient关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复。transient只能修饰变量，不能修饰类和方法。

- 获取用键盘输入的方法

  - 通过 Scanner

    ```java
    Scanner input = new Scanner(System.in);
    String s  = input.nextLine();
    input.close();
    ```

  - 通过 BufferedReader

    ```java
    BufferedReader input = new BufferedReader(new InputStreamReader(System.in)); 
    String s = input.readLine(); 
    ```

- Java中的I/O流

  - Java中的I/O流的40多个类都是由以下4个抽象类积累中派生出来的。

    - InputStream/Reader: 字节输入流/字符输入流。
    - OutputStream/Writer: 字节输出流/字符输出流。

  - 信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？

    如果我们不知道编码类型就很容易出现乱码问题。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。

  - BIO、NIO、AIO

    - **BIO (Blocking I/O):** 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。
    - **NIO (New I/O):** NIO是一种同步非阻塞的I/O模型。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。
    - **AIO (Asynchronous I/O):** AIO 也就是 NIO 2，是异步非阻塞的IO模型。

- static、final

  - **final**关键字
    - **对于一个final变量，如果是基本数据类型的变量，其数值在初始化后不能更改；如果是引用类型的变量，在对其初始化之后不能再让它指向另一个对象。**
    - **用final修饰一个类时，表示这个类不能被继承。final类的所有成员方法都会被隐式指定final方法。**
    - 使用final方法有两个原因。
      - 把方法锁定，以防任何继承类修改它的含义。
      - 效率。在早期的Java实现版本中，会将final方法转为内嵌调用。类中的所有private方法都隐式地指定为final。
  - **static**关键字
    - **修饰成员变量和成员方法:** 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，**静态变量 存放在 Java 内存区域的方法区**。调用格式：`类名.静态变量名` `类名.静态方法名()`
    - **静态代码块:** 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—>非静态代码块—>构造方法)。 该类不管创建多少对象，静态代码块只执行一次.
    - **静态内部类（static修饰类的话只能修饰内部类）：** 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。
    - **静态导包(用来导入类中的静态资源，1.5之后的新特性):** 格式为：`import static` 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。

- 深拷贝、浅拷贝

  - **浅拷贝**：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝。
  - **深拷贝**：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容。

- Java和PHP/JavaScript、Python的区别

  > [https://www.zhihu.com/question/20377398](<https://www.zhihu.com/question/20377398>)
  >
  > [https://www.zhihu.com/question/19913979](<https://www.zhihu.com/question/19913979>)
  >
  > [https://www.zhihu.com/question/19918532](<https://www.zhihu.com/question/19918532>)
  >
  > [https://www.zhihu.com/question/20491745](<https://www.zhihu.com/question/20491745>)

  - Java 属于**强类型**（所有程序都是well behaved），是**静态类型**语言（在编译时拒绝ill behaved）。

  - PHP/JavaScript属于弱类型（不需要定义变量的类型），是动态类型语言（在运行时拒绝ill behaved）。
  - PHP/JavaScript数组的功能强大，可以当作map和list来用。
  - PHP主要用于服务器端，JavaScript主要用于网页端。
  - Java和Python的区别是静态类型和动态类型，**静态类型必须先声明再使用，动态则不需要声明**。
  - Python也是强类型。**强弱类型不是指是否需要定义，而是是一旦类型决定了，是否能随便转换。**

- 如何跳出多重循环

  - loop and a half
  - break

- 内部类可以引用他包含类的成员吗，如果可以，有没有什么限制吗？

  - 一个内部类对象可以访问创建它的外部类对象的内容。内部类如果不是static的，那么它可以访问创建它的外部类对象的所有属性内部类；如果是satic的，即为nested class，那么它只可以访问创建它的外部类对象的所有static属性

  - 完全可以。如果不是静态内部类，那没有什么限制！
    如果你把静态嵌套类当作内部类的一种特例，那在这种情况下不可以访问外部类的普通成员变量，而只能访问外部类中的静态成员。

- Static Nested Class 和 Inner Class的不同

  > [https://blog.csdn.net/zzy7075/article/details/50378366](<https://blog.csdn.net/zzy7075/article/details/50378366>)

  Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化。

- final, finally, finalize的区别

  - final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。
  - finally是异常处理语句结构的一部分，表示总是执行。
  - finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。

- extends 和super 泛型限定符

  > [https://blog.csdn.net/qq_40395278/article/details/88603655](<https://blog.csdn.net/qq_40395278/article/details/88603655>)

  - 在java泛型中，**？ 表示通配符，代表未知类型，< ? extends Object>表示上边界限定通配符，< ? super Object>表示下边界限定通配符。**

  - 通配符 与 T 的区别

    - **T：作用于模板上，用于将数据类型进行参数化**，不能用于实例化对象。 
    - **?：在实例化对象的时候，不确定泛型参数的具体类型时，可以使用通配符进行对象定义。**
    - < T > 等同于 < T extends Object>
    - < ? > 等同于 < ? extends Object>

  - 例一：**定义泛型类**，将key，value的数据类型进行< K, V >参数化，而不可以使用通配符。

    ```java
    public class Container<K, V> {
    	private K key;
    	private V value;
    
    	public Container(K k, V v) {
    		key = k;
    		value = v;
    	}
    }
    ```

  - 例二：**实例化泛型对象**，我们不能够确定eList存储的数据类型是Integer还是Long，因此我们使用List<? extends Number>定义变量的类型。

    ```java
    List<? extends Number> eList = null;
    eList = new ArrayList<Integer>();
    eList = new ArrayList<Long>();
    ```

    上界类型通配符（? extends）

    ```java
    List<? extends Number> eList = null;
    eList = new ArrayList<Integer>();
    Number numObject = eList.get(0); //语句1，正确
     
    //Type mismatch: cannot convert from capture#3-of ? extends Number to Integer
    Integer intObject = eList.get(0); //语句2，错误
     
    //The method add(capture#3-of ? extends Number) in the type List<capture#3-of ? extends Number> is not applicable for the arguments (Integer)
    eList.add(new Integer(1)); //语句3，错误
    ```

- 泛型

  泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。

- Object类的方法

  > [https://fangjian0423.github.io/2016/03/12/java-Object-method/](<https://fangjian0423.github.io/2016/03/12/java-Object-method/>)

  - getClass()
  - hashCode()
  - equals()
  - clone()
  - toString()
  - notify(): 唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果所有的线程都在此对象上等待，那么只会选择一个线程。
  - notifyAll(): 跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。
  - wait(long timeout) throws InterruptedException: wait方法会让当前线程等待直到另外一个线程调用对象的notify或notifyAll方法，或者超过参数设置的timeout超时时间。
  - wait(long timeout, int nanos) throws InterruptedException: 跟wait(long timeout)方法类似，多了一个nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。
  - wait() throws InterruptedException: 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念。
  - finalize()的作用是实例被垃圾回收器回收的时候触发的操作，就好比 “死前的最后一波挣扎”。

- Query接口的list方法和iterate方法有什么区别？

  > [https://www.nowcoder.com/questionTerminal/e0f929dfaf6e46e4900b538b9c2134ea?orderByHotValue=1&page=1&onlyReference=false](<https://www.nowcoder.com/questionTerminal/e0f929dfaf6e46e4900b538b9c2134ea?orderByHotValue=1&page=1&onlyReference=false>)

  1. 返回的类型不一样，list返回List，iterate返回iterator

  1. 查询策略不同。获取数据的方式不一样，list会直接查询数据库，iterate会先到数据库中把id取出来，然后真正要遍历某个对象的时候先到缓存中找，如果找不到，以id为条件再发一条sql到数据库，这样如果缓存中没有数据，则查询数据库的次数为n+1 

  1. iterate会查询2级缓存，list只会缓存，但不会使用缓存（除非结合查询缓存）。  

  1. list中返回的list中每个对象都是原本的对象，iterate中返回的对象中仅包含了主键值

#### 容器

- Collections、Arrays工具类

  - Collections

    - 排序

      ```java
      void reverse(List list)//反转
      void shuffle(List list)//随机排序
      void sort(List list)//按自然排序的升序排序
      void sort(List list, Comparator c)//定制排序，由Comparator控制排序逻辑
      void swap(List list, int i , int j)//交换两个索引位置的元素
      void rotate(List list, int distance)//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面。
      ```

      实例代码

      ```java
      ArrayList<Integer> arrayList = new ArrayList<Integer>();
      arrayList.add(-1);
      arrayList.add(3);
      arrayList.add(3);
      arrayList.add(-5);
      arrayList.add(7);
      arrayList.add(4);
      arrayList.add(-9);
      arrayList.add(-7);
      System.out.println("原始数组:");
      System.out.println(arrayList);
      // void reverse(List list)：反转
      Collections.reverse(arrayList);
      System.out.println("Collections.reverse(arrayList):");
      System.out.println(arrayList);
      
      
      Collections.rotate(arrayList, 4);
      System.out.println("Collections.rotate(arrayList, 4):");
      System.out.println(arrayList);
      
      // void sort(List list),按自然排序的升序排序
      Collections.sort(arrayList);
      System.out.println("Collections.sort(arrayList):");
      System.out.println(arrayList);
      
      // void shuffle(List list),随机排序
      Collections.shuffle(arrayList);
      System.out.println("Collections.shuffle(arrayList):");
      System.out.println(arrayList);
      
      // void swap(List list, int i , int j),交换两个索引位置的元素
      Collections.swap(arrayList, 2, 5);
      System.out.println("Collections.swap(arrayList, 2, 5):");
      System.out.println(arrayList);
      
      // 定制排序的用法
      Collections.sort(arrayList, new Comparator<Integer>() {
      
          @Override
          public int compare(Integer o1, Integer o2) {
              return o2.compareTo(o1);
          }
      });
      System.out.println("定制排序后：");
      System.out.println(arrayList);
      ```

    - 查找、替换

      ```java
      int binarySearch(List list, Object key)//对List进行二分查找，返回索引，注意List必须是有序的
      int max(Collection coll)//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)
      int max(Collection coll, Comparator c)//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)
      void fill(List list, Object obj)//用指定的元素代替指定list中的所有元素。
      int frequency(Collection c, Object o)//统计元素出现次数
      int indexOfSubList(List list, List target)//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target).
      boolean replaceAll(List list, Object oldVal, Object newVal), 用新元素替换旧元素
      ```

      示例代码

      ```java
      ArrayList<Integer> arrayList = new ArrayList<Integer>();
      arrayList.add(-1);
      arrayList.add(3);
      arrayList.add(3);
      arrayList.add(-5);
      arrayList.add(7);
      arrayList.add(4);
      arrayList.add(-9);
      arrayList.add(-7);
      ArrayList<Integer> arrayList2 = new ArrayList<Integer>();
      arrayList2.add(-3);
      arrayList2.add(-5);
      arrayList2.add(7);
      System.out.println("原始数组:");
      System.out.println(arrayList);
      
      System.out.println("Collections.max(arrayList):");
      System.out.println(Collections.max(arrayList));
      
      System.out.println("Collections.min(arrayList):");
      System.out.println(Collections.min(arrayList));
      
      System.out.println("Collections.replaceAll(arrayList, 3, -3):");
      Collections.replaceAll(arrayList, 3, -3);
      System.out.println(arrayList);
      
      System.out.println("Collections.frequency(arrayList, -3):");
      System.out.println(Collections.frequency(arrayList, -3));
      
      System.out.println("Collections.indexOfSubList(arrayList, arrayList2):");
      System.out.println(Collections.indexOfSubList(arrayList, arrayList2));
      
      System.out.println("Collections.binarySearch(arrayList, 7):");
      // 对List进行二分查找，返回索引，List必须是有序的
      Collections.sort(arrayList);
      System.out.println(Collections.binarySearch(arrayList, 7));
      ```

    - 同步控制

      **效率非常低**

  - Arrays

    - 排序 : `sort()`
    - 查找 : `binarySearch()`
    - 比较: `equals()`
    - 填充 : `fill()`
    - 转列表: `asList()`
    - 转字符串 : `toString()`
    - 复制: `copyOf()`

- Comparable和Comparator接口的作用以及它们的区别

  - Java提供了只包含一个compareTo()方法的Comparable接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。

  - Java提供了包含compare()和equals()两个方法的Comparator接口。compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。

  > [https://www.jianshu.com/p/fa1a1089d44d](<https://www.jianshu.com/p/fa1a1089d44d>)

  - Comparable接口的实现是在类的内部（如 String、Integer已经实现了Comparable接口，自己就可以完成比较大小操作），Comparator接口的实现是在类的外部（可以理解为一个是自已完成比较，一个是外部程序实现比较）

  - **实现Comparable接口要重写compareTo方法, 在compareTo方法里面实现比较**

    ```java
    public class Student implements Comparable {
         String name;
         int age
         public int compareTo(Student another) {
              int i = 0;
              i = name.compareTo(another.name); 
              if(i == 0) { 
                   return age - another.age;
              } else {
                   return i; 
              }
         }
    }
    ```

    这时我们可以直接用 Collections.sort( StudentList ) 对其排序了(**只需传入要排序的列表**）

  - **实现Comparator需要重写 compare 方法**

    ```java
    public class Student{
         String name;
         int age
    }
    class StudentComparator implements Comparator { 
         public int compare(Student one, Student another) {
              int i = 0;
              i = one.name.compareTo(another.name); 
              if(i == 0) { 
                   return one.age - another.age;
              } else {
                   return i;
              }
         }
    }
    ```

    Collections.sort( StudentList , new StudentComparator()) 可以对其排序（**不仅要传入待排序的列表，还要传入实现了Comparator的类的对象**）

- List、Set、Map的区别

  - List：有序的多个对象。
    - **Arraylist：** Object数组
    - **Vector：** Object数组
    - **LinkedList：** 双向链表
  - Set：不允许重复的集合。
    - **HashSet（无序，唯一）:** 基于 HashMap 实现的，底层采用 HashMap 来保存元素
    - **LinkedHashSet：** LinkedHashSet 继承于 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 HashMap 实现一样，不过还是有一点点区别的
    - **TreeSet（有序，唯一）：** 红黑树(自平衡的排序二叉树)
  - Map：使用键值对存储。
  - Set和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。

- Array和ArrayList的区别

  - Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。
  - Array大小是固定的，ArrayList的大小是动态变化的。
  - ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。

- ArrayList和LinkedList的区别

  - 都不保证线程安全。
  - 底层数据结构：**ArrayList底层使用的Object数组，LinkedList底层使用的是双向链表结构。**
  - 时间复杂度：ArrayList插入删除元素的时间复杂度为**O(n)**，取第 i 元素的时间复杂度为**O(1)**；LinkedList插入和删除的时间复杂度为**O(1)**，如果是要在指定位置i插入和删除元素的话，时间复杂度近似为**O(n)**因为需要先移动到指定位置再插入。
  - 是否支持快速随机访问：LinkedList不支持高效的随机元素访问，而 ArrayList 支持。
  - 内存空间占用： ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。

- ArrayList和Vector的区别

  - Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。
  - Arraylist不是同步的，所以在不需要保证线程安全时建议使用Arraylist。

- Map的分类

  - Map有4个实现类，HashMap、HashTable、LinkedHashMap、TreeMap。
  - Hashmap 是一个最常用的Map，它根据键的HashCode值存储数据,根据键可以直接获取它的值，具有**很快的访问速度**，遍历时，取得数据的顺序是完全随机的。 **HashMap最多只允许一条记录的键为Null；允许多条记录的值为 Null；HashMap不支持线程的同步**，即任一时刻可以有多个线程同时写HashMap；可能会导致数据的不一致。
  - **Hashtable**与 HashMap类似，它继承自Dictionary类，不同的是：**它不允许记录的键或者值为空；它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了 Hashtable在写入时会比较慢。**
  - LinkedHashMap 是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排序。
  - TreeMap实现SortMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。
  - 一般情况下，我们用的最多的是HashJDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）Map，在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按**自然顺序**或自定义顺序遍历键，那么**TreeMap**会更好。如果需要**输出的顺序和输入的相同**，那么用**LinkedHashMap**可以实现,它还可以按读取顺序来排列.

- HashMap和HashSet的区别

  - HashSet 底层就是基于 HashMap 实现的。

  - | HashMap                          | HashSet                                                      |
    | -------------------------------- | ------------------------------------------------------------ |
    | 实现了Map接口                    | 实现Set接口                                                  |
    | 存储键值对                       | 仅存储对象                                                   |
    | 调用 `put()`向map中添加元素      | 调用 `add()`方法向Set中添加元素                              |
    | HashMap使用键（Key）计算Hashcode | HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性， |

- 散列

  - 选择散列函数

    - Division method

      - $h(k)=k \mod m$

    - Multiplication method

      - $m=2^r$，计算机有$w$位词

      - $h(k)=(A\cdot k\mod 2^w)\rm{rsh}(w-r)$
      - 模块轮 (Modular wheel)：将轮子旋转$k$个$A$，然后舍弃最后几位

  - 处理冲突

    - 拉链法  

      填装因子$\alpha=表中记录数（键数）n/散列表长度（槽数）m$

      **不成功**搜索的期望时间$=\Theta(1+\alpha)$

    - 开放定址法：线性探查法、平方探查法、再散列法、伪随机序列法

      假设均匀散列，每个键等可能地将$m!$种排序之一作为其探查序列。

      定理：不成功搜索的期望探查次数 $E[$#$probes]\le1/(1-\alpha)$

- HashMap源码学习

  JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间。

- ConcurrentHashMap和HashTable的区别

  - **底层数据结构：** JDK1.7的 ConcurrentHashMap 底层采用 **分段的数组+链表** 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。HasTable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 **数组+链表** 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；

  - **实现线程安全的方式（重要）：** 

    ① **在JDK1.7的时候，ConcurrentHashMap（分段锁）** 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 

    >  ConcurrentHashMap 类中包含两个静态内部类 HashEntry 和 Segment。HashEntry 用来封装映射表的键 / 值对；Segment 用来充当锁的角色，每个 Segment 对象守护整个散列映射表的若干个桶。每个桶是由若干个 HashEntry 对象链接起来的链表。一个 ConcurrentHashMap 实例中包含由若干个 Segment 对象组成的数组。HashEntry 用来封装散列映射表中的键值对。在 HashEntry 类中，key，hash 和 next 域都被声明为 final 型，value 域被声明为 volatile 型。
    >
    >  在ConcurrentHashMap 中，在散列时如果产生“碰撞”，将采用“分离链接法”来处理“碰撞”：把“碰撞”的 HashEntry 对象链接成一个链表。由于 HashEntry 的 next 域为 final 型，所以新节点只能在链表的表头处插入。 

    **到了 JDK1.8 的时候已经摒弃了Segment的概念，则是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）** 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；

    ② **HashTable(同一把锁)** :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。

  - HashTable

    ![HashTable全表锁](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/HashTable%E5%85%A8%E8%A1%A8%E9%94%81.png)

  - JDK1.7的ConcurrentHashMap

    ![JDK1.7的ConcurrentHashMap](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/ConcurrentHashMap%E5%88%86%E6%AE%B5%E9%94%81.jpg)

  - JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）

    ![JDK1.8的ConcurrentHashMap](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/JDK1.8-ConcurrentHashMap-Structure.jpg)

- List、Set、Map是否继承自Collection接口？

  List、Set 是，Map 不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。

- 常用集合类以及主要方法

  > [https://blog.csdn.net/zhj870975587/article/details/50996811](<https://blog.csdn.net/zhj870975587/article/details/50996811>)

  Collection接口

  > 若要检查Collection中的元素，可以使用foreach进行遍历，也可以使用迭代器，Collection支持iterator()方法，通过该方法可以访问Collection中的每一个元素。Set和List是由Collection派生的两个接口。

  - List接口：LinkedList类、ArrayList类
  - Vector类
  - Stack类
  - Set接口：HashSet类、TreeSet类
  - Queue类

  - Map接口：HashTable类、HashMap类、TreeNap类、LinkedHashMap类

- Collection 和 Collections的区别

  - Collection是集合类的上级接口，继承与他的接口主要有Set 和List.
  - Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。

- 快速失败(fail-fast)和安全失败(fail-safe)的区别

  > [https://blog.csdn.net/qq_31780525/article/details/77431970](<https://blog.csdn.net/qq_31780525/article/details/77431970>)

  - **在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。**

    - 原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。

    - 注意：这里异常的抛出条件是检测到 modCount!=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。

    - 场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。

  - **采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。**

    - 原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。

    - 缺点：**基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。**

    - 场景：**java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。**

  - 快速失败和安全失败是对迭代器而言的。 

    - 快速失败：当在迭代一个集合的时候，如果有另外一个线程在修改这个集合，就会抛出ConcurrentModification异常，java.util下都是快速失败。
    - 安全失败：在迭代时候会在集合二层做一个拷贝，所以在修改集合上层元素不会影响下层。在java.util.concurrent下都是安全失败

- Iterator和ListIterator的区别

  - Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。
  - ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。

- 什么是迭代器？

  - Iterator提供了统一遍历操作集合元素的统一接口，Collection接口实现Iterable接口，每个集合都通过实现Iterable接口中iterator()方法返回Iterator接口的实例，然后对集合的元素进行迭代操作.
  - 有一点需要注意的是：在迭代元素的时候不能通过集合的方法删除元素，否则会抛出ConcurrentModificationException 异常. 但是可以通过Iterator接口中的remove()方法进行删除.

- 为什么集合类没有实现Cloneable和Serializable接口？

  - 克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。
  - 实现Serializable序列化的作用：将对象的状态保存在存储媒体中以便可以在以后重写创建出完全相同的副本；按值将对象从一个从一个应用程序域发向另一个应用程序域。
    实现 Serializable接口的作用就是可以把对象存到字节流，然后可以恢复。所以你想如果你的对象没有序列化，怎么才能进行网络传输呢？要网络传输就得转为字节流，所以在分布式应用中，你就得实现序列化。如果你不需要分布式应用，那就没必要实现实现序列化。

- TreeMap的底层实现

  - TreeMap 的实现就是红黑树数据结构，也就说是一棵自平衡的排序二叉树，这样就可以保证当需要快速检索指定节点。

    红黑树的插入、删除、遍历时间复杂度都为O(lgN)，所以性能上低于哈希表。但是哈希表无法提供键值对的有序输出，红黑树因为是排序插入的，可以按照键的值的大小有序输出。

  - 红黑树性质：

    性质1：每个节点要么是红色，要么是黑色。

    性质2：根节点永远是黑色的。

    性质3：所有的叶节点都是空节点（即 null），并且是黑色的。

    性质4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点）

    性质5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。

- HashMap的容量为什么是2的n次幂？

  负载因子默认是0.75， 2^n是为了让散列更加均匀，例如出现极端情况都散列在数组中的一个下标，那么hashmap会由O(1)复杂退化为O(n)的。
- 如果hashMap的key是一个自定义的类，怎么办？

  使用HashMap，如果key是自定义的类，就必须重写hashcode()和equals()。

#### 并发

- 线程、程序、进程

  - **线程**是比进程更小的执行单位，一个进程在执行过程中可以产生多个线程。同类的多个线程共享同一块内存空间和一组系统资源，所以各个线程之间切换工作负担比进程小得多。
  - **程序**是含有指令和数据的文件，程序是静态的代码。
  - **进程**是程序的一次执行过程，进程是动态的。

- 线程的基本状态

  - 就绪、运行、阻塞、新建、终止（王道操作系统P28）

  - Java线程的状态：新建New（线程被构建）、可运行Runnable（运行中Running、就绪Ready）、阻塞Blocked（线程阻塞于锁）、等待Waiting（当前线程需要等待其他线程的消息）、超时等待TimeWaiting（在等待状态的基础上增加了超时限制，在指定时间自动返回）、终止Terminated

    比操作系统多了等待、超时等待两个状态

    ![Java线程的状态](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png)

  - Java线程状态变迁

    ![Java线程状态变迁](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java%20%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81.png)

- 如何保证线程安全？

  **通过合理的时间调度，避开共享资源的存取冲突。**另外，在并行任务设计上可以通过适当的策略，保证任务与任务之间不存在共享资源，设计一个规则来保证一个客户的计算工作和数据访问只会被一个线程或一台工作机完成，而不是把一个客户的计算工作分配给多个线程去完成。

- 什么是线程池(thread pool)？

  在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。**所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。**
  Java 5+中的Executor接口定义一个执行线程的工具。它的子类型即线程池接口是ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类Executors面提供了一些静态工厂方法，生成一些常用的线程池，如下所示：

  - newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。
  - newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。
  - newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。
  - newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。

  > [https://blog.csdn.net/paul342/article/details/52442932](<https://blog.csdn.net/paul342/article/details/52442932>)

  Java通过Executors提供四种线程池，分别为：

  - **newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。**
  - **newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数**，超出的线程会在队列中等待。
  - **newScheduledThreadPool** 创建一个定长线程池，**支持定时及周期性任务执行。**
  - **newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务**，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。

- 同步和异步

  如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就必须进行同步存取（数据库操作中的排他锁就是最好的例子）。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。事实上，所谓的**同步就是指阻塞式操作，而异步就是非阻塞式操作。**

- 当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？

  不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁，如果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。

- 线程同步和线程调度的相关方法

  - wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；
  - sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常；
  - notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；
  - notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；
  - 通过Lock接口提供了显式的锁机制（explicit lock），增强了灵活性以及对线程的协调。Lock接口中定义了加锁（lock()）和解锁（unlock()）的方法，同时还提供了newCondition()方法来产生用于线程之间通信的Condition对象；此外，Java 5还提供了信号量机制（semaphore），信号量可以用来限制对某个共享资源进行访问的线程的数量。在对资源进行访问之前，线程必须得到信号量的许可（调用Semaphore对象的acquire()方法）；在完成对资源的访问后，线程必须向信号量归还许可（调用Semaphore对象的release()方法）。

- 线程的sleep()方法和yield()方法有什么区别？

  ① sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；

  ② 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；

  ③ sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；

  ④ sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。

  > [https://www.jianshu.com/p/25e959037eed](<https://www.jianshu.com/p/25e959037eed>)

  Java中wait、sleep的区别或者Java中sleep、yield的区别是Java面试或者多线程面试中最常问的问题之一。在这3个在Java中能够用来暂停线程的方法中，sleep()和yield()方法是定义在Thread类中，而wait()方法是定义在Object类中的， 这也是面试中常问的一个问题。

  wait()和sleep()的关键的区别在于，**wait()是用于线程间通信的，而sleep()是用于短时间暂停当前线程。**更加明显的一个区别在于，**当一个线程调用wait()方法的时候，会释放它锁持有的对象的管程和锁，但是调用sleep()方法的时候，不会释放他所持有的管程。**

  回到**yield()方法**上来，与wait()和sleep()方法有一些区别，它**仅仅释放线程所占有的CPU资源，从而让其他线程有机会运行，但是并不能保证某个特定的线程能够获得CPU资源。谁能获得CPU完全取决于调度器，在有些情况下调用yield方法的线程甚至会再次得到CPU资源。所以，依赖于yield方法是不可靠的，它只能尽力而为。**

  - Java中wait和sleep的区别

    wait和sleep的主要区别是调用wait方法时，线程在等待的时候会释放掉它所获得的monitor，但是调用Thread.sleep()方法时，线程在等待的时候仍然会持有monitor或者锁。另外，Java中的wait方法应在同步代码块中调用，但是sleep方法不需要。
    **另一个区别是Thread.sleep()方法是一个静态方法，作用在当前线程上；但是wait方法是一个实例方法，并且只能在其他线程调用本实例的notify()方法时被唤醒。**另外，使用sleep方法时，被暂停的线程在被唤醒之后会立即进入就绪态（Runnable state)，但是使用wait方法的时候，被暂停的线程会首先获得锁（译者注：阻塞态），然后再进入就绪态。所以，根据你的需求，如果你需要暂定你的线程一段特定的时间就使用sleep()方法，如果你想要实现线程间通信就使用wait()方法。
    下面列出Java中wait和sleep方法的区别：

    1. wait只能在同步（synchronize）环境中被调用，而sleep不需要。详见[Why to wait and notify needs to call from synchronized method](https://link.jianshu.com/?t=http%3A%2F%2Fjavarevisited.blogspot.com%2F2011%2F05%2Fwait-notify-and-notifyall-in-java.html)
    2. 进入wait状态的线程能够被notify和notifyAll线程唤醒，但是进入sleeping状态的线程不能被notify方法唤醒。
    3. wait通常有条件地执行，线程会一直处于wait状态，直到某个条件变为真。但是sleep仅仅让你的线程进入睡眠状态。
    4. wait方法在进入wait状态的时候会释放对象的锁，但是sleep方法不会。
    5. wait方法是针对一个被同步代码块加锁的对象，而sleep是针对一个线程。更详细的讲解可以参考《Java核心技术卷1》，里面介绍了如何使用wait和notify方法。

  - yield和sleep的区别

    yield和sleep的区别主要是，**yield方法会临时暂停当前正在执行的线程，来让有同样优先级的正在等待的线程有机会执行。如果没有正在等待的线程，或者所有正在等待的线程的优先级都比较低，那么该线程会继续运行。**执行了yield方法的线程什么时候会继续运行由线程调度器来决定，不同的厂商可能有不同的行为。**yield方法不保证当前的线程会暂停或者停止，但是可以保证当前线程在调用yield方法时会放弃CPU。**
    在Java中Sleep方法有两个， 一个只有一个毫秒参数，另一个有毫秒和纳秒两个参数。

    ```java
    sleep(long millis)
    ```

    or

    ```java
    sleep(long millis, int nanos)
    ```

    会让当前执行的线程sleep指定的时间。

    下面这张图很好地展示了在调用wait、sleep、yield方法的时候，线程状态如何转换。

    ![img](https://upload-images.jianshu.io/upload_images/66827-780462c52b8f5a83.png?imageMogr2/auto-orient/strip\|imageView2/2/w/1100/format/webp)

    Java中sleep方法的几个注意点：

    1. Thread.sleep()方法用来暂停线程的执行，将CPU放给线程调度器。
    2. Thread.sleep()方法是一个静态方法，它暂停的是当前执行的线程。
    3. Java有两种sleep方法，一个只有一个毫秒参数，另一个有毫秒和纳秒两个参数。
    4. 与wait方法不同，sleep方法不会释放锁
    5. 如果其他的线程中断了一个休眠的线程，sleep方法会抛出Interrupted Exception。
    6. 休眠的线程在唤醒之后不保证能获取到CPU，它会先进入就绪态，与其他线程竞争CPU。
    7. 有一个易错的地方，当调用t.sleep()的时候，会暂停线程t。这是不对的，因为Thread.sleep是一个静态方法，它会使当前线程而不是线程t进入休眠状态。

    这就是java中的sleep方法。我们已经看到了java中sleep、wait以及yield方法的区别。总之，记住sleep和yield作用于当前线程。

- 第一个 问题：Java中有几种方法可以实现一个线程？

  第二个问题：用什么关键字修饰同步方法?  

  第三个问题：stop()和suspend()方法为何不推荐使用，请说明原因？

  > [https://blog.csdn.net/Amen_Wu/article/details/54025804](<https://blog.csdn.net/Amen_Wu/article/details/54025804>)

  - **多线程有两种实现方法，分别是继承Thread类与实现Runnable接口。**

  - **用synchronized关键字修饰同步方法。（同步的实现方面有两种，分别是synchronized, wait与notify.）**

  - **反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定**，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。

    **suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。**此时，其他任何线程都不能访问锁定的资源，除非被”挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。

    所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用 wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。

- 启动一个线程是用run()还是start()?

  > [https://blog.csdn.net/wang_xing1993/article/details/70257475](<https://blog.csdn.net/wang_xing1993/article/details/70257475>)

  启动线程肯定要用start()方法。当用start()开始一个线程后，线程就进入就绪状态，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行。这并不意味着线程就会立即运行。当cpu分配给它时间时，才开始执行run()方法(如果有的话)。start()是方法,它调用run()方法.而run()方法是你必须重写的. run()方法中包含的是线程的主体。

  继承Thread类的启动方式：

  ```java
  public class ThreadStartTest {
  	public static void main(String[] args) {
  		ThreadTest tt = new ThreadTest();// 创建一个线程实例
          tt.start();  // 启动线程
      }
  }
  ```

  实现Runnable接口的启动方式：

  ```java
  public class RunnableStartTest {
  	public static void main(String[] args) {
  		Thread t = new Thread(new RunnableTest());    // 创建一个线程实例
  		t.start();  // 启动线程
  	}
  }
  ```

  实际上这两种启动线程的方式原理是一样的。首先都是调用本地方法启动一个线程，其次是在这个线程里执行目标对象的run()方法。那么这个目标对象是什么呢？为了弄明白这个问题，我们来看看Thread类的run()方法的实现：

  ```java
  public void run() {
     if (target != null) {
         target.run();
      }
  }
  ```

  当我们采用实现Runnable接口的方式来实现线程的情况下，在调用new Thread(Runnable target)构造器时，将实现Runnable接口的类的实例设置成了线程要执行的主体所属的目标对象target，当线程启动时，这个实例的 run()方法就被执行了。当我们采用继承Thread的方式实现线程时，线程的这个run()方法被重写了，所以当线程启动时，执行的是这个对象自身的 run()方法。总结起来就一句话，如果我们采用的是继承Thread类的方式，那么这个target就是线程对象自身，如果我们采用的是实现Runnable接口的方式，那么这个target就是实现了Runnable接口的类的实例。

- 使用内部类实现线程设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1

  > [https://www.nowcoder.com/questionTerminal/8db05d0b47044b3f9605860451d63d25](<https://www.nowcoder.com/questionTerminal/8db05d0b47044b3f9605860451d63d25>)

  ```java
  public class Main{
      private int j=0;//定义变量j
      
      public synchronized add() {
          j++;//定义同步方法每次只有一个线程对j进行j++操作
      }
      
      public synchronized dec() {
  		j--;//定义同步方法每次只有一个线程对j进行j--操作
      }
      
  	public static void main(String[] args){
  		
          for(int i=0;i<2;i++) {
  			
              new Thead(new Runnable(){//使用匿名内部类进行线程的创建，重写run()方法，调用add()方法
                  public void run() {
  					while(true){
                   		add();
             			}
           		}
           	}).start();
              
           	new Thead(new Runnable() {//使用匿名内部类进行线程的创建，重写run()方法，调用dec()方法
             		public void run(){
                      while(true){
                          dec();
                      }
  				}
              }).start();
          }
      }
  }
  ```

  > [https://blog.csdn.net/zuoyixiao/article/details/39525625](<https://blog.csdn.net/zuoyixiao/article/details/39525625>)

  ```java
  public class MultiThread {
  	private int j;
   
  	public static void main(String[] args) {
  		MultiThread mt = new MultiThread();
  		Inc inc = mt.new Inc();
  		Dec dec = mt.new Dec();
  		// 4个线程（0、1、2、3）
  		for (int i = 0; i < 2; i++) {
  			Thread t = new Thread(inc);
  			t.start();
  			t = new Thread(dec);
  			t.start();
  		}
  		// System.exit(0);// 如果报错加上此句
  	}
   
  	// 对j增加1的方法
  	private synchronized void inc() {
  		j++;
  		System.out.println(Thread.currentThread().getName() + "-inc:" + j);
  	}
   
  	// 对j减少1的方法
  	private synchronized void dec() {
  		j--;
  		System.out.println(Thread.currentThread().getName() + "-dec:" + j);
  	}
   
  	// 内部类实现线程
  	class Inc implements Runnable {
  		public void run() {
  			for (int i = 0; i < 100; i++) {
  				inc();
  			}
  		}
  	}
   
  	class Dec implements Runnable {
  		public void run() {
  			for (int i = 0; i < 100; i++) {
  				dec();
  			}
  		}
  	}
  }
  ```

- 在监视器(Monitor)内部，是如何做到线程同步的？在程序又应该做哪种级别的同步呢？

  监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。

- 同步方法和同步代码块的区别是什么？

  同步方法默认用this或者当前类class对象作为锁；
  同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法。

- 创建线程有几种不同的方式？你喜欢哪一种？为什么？

  > [https://blog.csdn.net/u012973218/article/details/51280044](<https://blog.csdn.net/u012973218/article/details/51280044>)

  1. 继承Thread类创建线程类

     ```java
     public class FirstThreadTest extends Thread {  
         int i = 0;  
         //重写run方法，run方法的方法体就是现场执行体  
         public void run() {  
             for(;i<100;i++) {  
                 System.out.println(getName()+"  "+i);  
             }  
         }  
         public static void main(String[] args) {  
             for(int i = 0;i< 100;i++) {  
                 System.out.println(Thread.currentThread().getName()+"  : "+i);  
                 if(i==20) {  
                     new FirstThreadTest().run();  
                     new FirstThreadTest().run();  
                 }  
             }  
         }   
     }
     ```

  2. 通过Runable接口创建线程类

     ```java
     public class RunnableThreadTest implements Runnable {  
         private int i;  
         public void run() {  
             for(i = 0;i <100;i++) {  
                 System.out.println(Thread.currentThread().getName()+" "+i);  
             }  
         }  
         public static void main(String[] args) {  
             for(int i = 0;i < 100;i++) {  
                 System.out.println(Thread.currentThread().getName()+" "+i);  
                 if(i==20) {  
                     RunnableThreadTest rtt = new RunnableThreadTest();  
                     new Thread(rtt,"新线程1").start();  
                     new Thread(rtt,"新线程2").start();  
                 }  
             }  
         }  
     }
     ```

  3. 通过Callable和FutureTask创建线程

     a. 创建Callable接口的实现类，并实现call()方法；

     b. 创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callback对象的call()方法的返回值；

     c. 使用FutureTask对象作为Thread对象的target创建并启动新线程；

     d. 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。

     ```java
     import java.util.concurrent.Callable;  
     import java.util.concurrent.ExecutionException;  
     import java.util.concurrent.FutureTask;  
       
     public class CallableThreadTest implements Callable<Integer> {  
       
         public static void main(String[] args) {  
             CallableThreadTest ctt = new CallableThreadTest();  
             FutureTask<Integer> ft = new FutureTask<Integer>(ctt);  
     //        Thread thread = new Thread(ft,"有返回值的线程");
     //        thread.start();
             for(int i = 0;i < 100;i++) {  
                 System.out.println(Thread.currentThread().getName()+" 的循环变量i的值"+i);  
                 if(i==20) {  
                     new Thread(ft,"有返回值的线程").start();  
                 }  
             }  
             try {  
                 System.out.println("子线程的返回值："+ft.get());  
             } catch (InterruptedException e) {  
                 e.printStackTrace();  
             } catch (ExecutionException e) {  
                 e.printStackTrace();  
             }  
         }  
       
         @Override  
         public Integer call() throws Exception {  
             int i = 0;  
             for(;i<100;i++) {  
                 System.out.println(Thread.currentThread().getName()+" "+i);  
             }  
             return i;  
         }  
     } 
     ```

  4. 通过线程池创建线程

     ```java
     import java.util.concurrent.ExecutorService;
     import java.util.concurrent.Executors;
     
     public class ThreadPool {
     	/* POOL_NUM */
     	private static int POOL_NUM = 10;
     	
     	/**
     	 * Main function
     	 */
     	public static void main(String[] args) {
     		ExecutorService executorService = Executors.newFixedThreadPool(5);
     		for(int i = 0; i<POOL_NUM; i++) {
     			RunnableThread thread = new RunnableThread();
     			executorService.execute(thread);
     		}
     	}
     }
      
     class RunnableThread implements Runnable {
     	private int THREAD_NUM = 10;
     	public void run() {
     		for(int i = 0; i<THREAD_NUM; i++) {
     			System.out.println("线程" + Thread.currentThread() + " " + i);
     		} 
     	}
     }
     ```

- Java多线程回调是什么意思？

  > [https://blog.csdn.net/wenzhi20102321/article/details/52512536](<https://blog.csdn.net/wenzhi20102321/article/details/52512536>)

  所谓回调，就是客户程序C调用服务程序S中的某个方法A，然后S又在某个时候反过来调用C中的某个方法B，对于C来说，这个B便叫做回调方法。

  - 回答者(S)

  ```java
  package com.xykj.thread;
  public class XiaoZhang extends Thread {
      // 回答1+1，很简单的问题不需要线程
      public int add(int num1, int num2) {
         return num1 + num2;
      }
   
      // 重写run方法
      @Override
      public void run() {
         // 回答地球为什么是圆的
         askquestion();
         super.run();
      }
   
      // 回调接口的创建，里面要有一个回调方法
      //回调接口什么时候用呢？这个思路是最重要的   
      public static interface CallPhone {
         public void call(String question);
      }
   
      // 回调接口的对象
      CallPhone callPhone;
   
      // 回答地球为什么是圆的
      private void askquestion() {
         System.err.println("开始查找资料！");
         try {
             sleep(3000);// 思考3天
         } catch (InterruptedException e) {
             e.printStackTrace();
         }
         // 把答案返回到回调接口的call方法里面
         if (callPhone!=null) {//提问者实例化callPhone对象，相当于提问者已经告诉我，我到时用什么方式回复答案
             //这个接口的方法实现是在提问者的类里面
             callPhone.call("知道了，！！！~~~~百度有啊");
         }     
      }
  }
  ```

  - 提问者(C)

  ```java
  package com.xykj.thread;
  import com.xykj.thread.XiaoZhang.CallPhone;
  public class MainClass {
      /**
       * java回调方法的使用
       * 实际操作时的步骤：（以本实例解释）
       * 1.在回答者的类内创建回调的接口
       * 2.在回答者的类内创建回调接口的对象，
       * 3.在提问者类里面实例化接口对象，重写接口方法
       * 2.-3.这个点很重要，回调对象的实例化，要在提问者的类内实例化，然后重写接口的方法
       * 相当于提问者先把一个联络方式给回答者，回答者找到答案后，通过固定的联络方式，来告诉提问者答案。
       * 4.调用开始新线程的start方法
       * 5.原来的提问者还可以做自己的事
       * */
      public static void main(String[] args) {
         // 小王问小张1+1=？，线程同步
         XiaoZhang xiaoZhang = new XiaoZhang();
         int i = xiaoZhang.add(1, 1);//回答1+1的答案
   
         // 问小张地球为什么是圆的？回调方法的使用
         //这相当于先定好一个返答案的方式，再来执行实际操作
        
         // 实例化回调接口的对象
         CallPhone phone = new CallPhone() {
             @Override
             public void call(String question) {
                //回答问题者，回答后，才能输出答案
                System.err.println(question);
             }
         };
        
         //把回调对象赋值给回答者的回调对象，回答问题者的回调对象才能回答问题
         xiaoZhang.callPhone = phone;
        
         System.out.println("交代完毕！");
         //相关交代完毕之后再执行查询操作
         xiaoZhang.start();
        
         //小王做自己的事！
         System.out.println("小王做自己的事！");
      }
   
  }
  ```

- CyclicBarrier和CountDownLatch区别

  > [https://blog.csdn.net/tolcf/article/details/50925145](<https://blog.csdn.net/tolcf/article/details/50925145>)

  | CountDownLatch                                               | CyclicBarrier                                                |
  | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | 减计数方式                                                   | 加计数方式                                                   |
  | 计算为0时释放所有等待的线程                                  | 计数达到指定值时释放所有等待线程                             |
  | 计数为0时，无法重置                                          | 计数达到指定值时，计数置为0重新开始                          |
  | 调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响 | 调用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞 |
  | 不可重复利用                                                 | 可重复利用                                                   |

- 线程池的优势

  第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。

  第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能执行。

  第三：提高线程的可管理性，线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。

- AQS

  > [https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Multithread/AQS.md](<https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Multithread/AQS.md>)

  AQS 的全称为（AbstractQueuedSynchronizer），这个类在 java.util.concurrent.locks 包下面。

  AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask(jdk1.7) 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。

- 线程池的运行流程，使用参数以及方法策略

  > [https://www.nowcoder.com/questionTerminal/da3b91dcfc654995a7ee66081a12f22d](<https://www.nowcoder.com/questionTerminal/da3b91dcfc654995a7ee66081a12f22d>)

  ![img](https://uploadfiles.nowcoder.com/images/20191030/772083058_1572442784924_2794081A0C6591DE7FAD353CA16D021F)

- 什么是生产者消费者模式？

  ![img](https://uploadfiles.nowcoder.com/images/20180925/308572_1537880635592_7142B8354CA8A352B2B805F997C71549)

  生产者消费者问题是线程模型中的经典问题：生产者和消费者在同一时间段内共用同一存储空间，生产者向空间里生产数据，而消费者取走数据。

- 实现多线程同步的方法

  > [https://www.cnblogs.com/xhjt/p/3897440.html](<https://www.cnblogs.com/xhjt/p/3897440.html>)

  1. **同步方法**

     即有synchronized关键字修饰的方法。由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。

     代码如：

     ```java
     public synchronized void save(){}
     ```

     注： synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类

  2. **同步代码块**

     即有synchronized关键字修饰的语句块。被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。

     代码如：

     ```java
     synchronized(object){}
     ```

     注：同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。

     代码实例：

     ```java
     package com.xhj.thread;
     
     /**
       * 线程同步的运用
       */
     public class SynchronizedThread {
     
         class Bank {
     
             private int account = 100;
     
             public int getAccount() {
                 return account;
             }
     
             /**
               * 用同步方法实现
               * 
               * @param money
               */
             public synchronized void save(int money) {
                 account += money;
             }
     
             /**
               * 用同步代码块实现
               * 
               * @param money
               */
             public void save1(int money) {
                 synchronized (this) {
                     account += money;
                 }
             }
         }
     
         class NewThread implements Runnable {
             private Bank bank;
     
             public NewThread(Bank bank) {
                 this.bank = bank;
             }
     
             @Override
             public void run() {
                 for (int i = 0; i < 10; i++) {
                     // bank.save1(10);
                     bank.save(10);
                     System.out.println(i + "账户余额为：" + bank.getAccount());
                 }
             }
     
         }
     
         /**
           * 建立线程，调用内部类
           */
         public void useThread() {
             Bank bank = new Bank();
             NewThread new_thread = new NewThread(bank);
             System.out.println("线程1");
             Thread thread1 = new Thread(new_thread);
             thread1.start();
             System.out.println("线程2");
             Thread thread2 = new Thread(new_thread);
             thread2.start();
         }
     
         public static void main(String[] args) {
             SynchronizedThread st = new SynchronizedThread();
             st.useThread();
         }
     
     }
     ```

  3. 使用特殊域变量(**volatile**)实现线程同步

     a.volatile关键字为域变量的访问提供了一种免锁机制，

     b.使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新，

     c.因此每次使用该域就要重新计算，而不是使用寄存器中的值

     d.volatile不会提供任何原子操作，它也不能用来修饰final类型的变量

     例如：在上面的例子当中，只需在account前面加上volatile修饰，即可实现线程同步。

     代码实例：

     ```java
     //只给出要修改的代码，其余代码与上同
     class Bank {
         //需要同步的变量加上volatile
         private volatile int account = 100;
     
         public int getAccount() {
             return account;
         }
         //这里不再需要synchronized 
         public void save(int money) {
             account += money;
         }
     }
     ```

     注：多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。用final域，有锁保护的域和volatile域可以避免非同步的问题。

  4. 使用**重入锁**实现线程同步

     在JavaSE5.0中新增了一个java.util.concurrent包来支持同步。ReentrantLock类是可重入、互斥、实现了Lock接口的锁，它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力。

     **ReenreantLock类**的常用方法有：

     - ReentrantLock() : 创建一个ReentrantLock实例
     - lock() : 获得锁
     - unlock() : 释放锁

     注：ReentrantLock()还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，不推荐使用。

     例如：在上面例子基础上，修改后的代码为：

     代码实例：

     ```java
     //只给出要修改的代码，其余代码与上同
     class Bank {
     
         private int account = 100;
         //需要声明这个锁
         private Lock lock = new ReentrantLock();
         public int getAccount() {
             return account;
         }
         //这里不再需要synchronized 
         public void save(int money) {
             lock.lock();
             try{
                 account += money;
             }finally{
                 lock.unlock();
             }
         }
     }
     ```

     注：关于Lock对象和synchronized关键字的选择：

     a.最好两个都不用，使用一种java.util.concurrent包提供的机制，能够帮助用户处理所有与锁相关的代码。

     b.如果synchronized关键字能满足用户的需求，就用synchronized，因为它能简化代码

     c.如果需要更高级的功能，就用ReentrantLock类，此时要注意及时释放锁，否则会出现死锁，通常在finally代码释放锁

  5. 使用局部变量实现线程同步

     **如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本，副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。**

     **ThreadLocal 类**的常用方法

     - ThreadLocal() : 创建一个线程本地变量
     - get() : 返回此线程局部变量的当前线程副本中的值
     - initialValue() : 返回此线程局部变量的当前线程的"初始值"
     - set(T value) : 将此线程局部变量的当前线程副本中的值设置为value

     例如：在上面例子基础上，修改后的代码为：

     代码实例：

     ```java
     //只改Bank类，其余代码与上同
     public class Bank{
         //使用ThreadLocal类管理共享变量account
         private static ThreadLocal<Integer> account = new ThreadLocal<Integer>(){
             @Override
             protected Integer initialValue(){
                 return 100;
             }
         };
         public void save(int money){
             account.set(account.get()+money);
         }
         public int getAccount(){
             return account.get();
         }
     }
     ```

     注：ThreadLocal与同步机制

     a.**ThreadLocal**与**同步机制**都是为了解决多线程中相同变量的访问冲突问题。

     b.前者采用以"**空间换时间**"的方法，后者采用以"**时间换空间**"的方式

  6. 使用**阻塞队列**实现线程同步

     前面5种同步方式都是在底层实现的线程同步，但是我们在实际开发当中，应当尽量远离底层结构。 
     使用javaSE5.0版本中新增的java.util.concurrent包将有助于简化开发。 

     本小节主要是使用**LinkedBlockingQueue<E>**来实现线程的同步 。LinkedBlockingQueue<E>是一个基于已连接节点的，范围任意的blocking queue。 队列是先进先出的顺序（FIFO），关于队列以后会详细讲解~ 

     **LinkedBlockingQueue 类常用方法** 

     - LinkedBlockingQueue() : 创建一个容量为Integer.MAX_VALUE的LinkedBlockingQueue 
     - put(E e) : 在队尾添加一个元素，如果队列满则阻塞 
     - size() : 返回队列中的元素个数 
     - take() : 移除并返回队头元素，如果队列空则阻塞 

     **代码实例：** 实现商家生产商品和买卖商品的同步

     ```java
     package com.xhj.thread;
     
     import java.util.Random;
     import java.util.concurrent.LinkedBlockingQueue;
     
     /**
      * 用阻塞队列实现线程同步 LinkedBlockingQueue的使用
      */
     public class BlockingSynchronizedThread {
         /**
          * 定义一个阻塞队列用来存储生产出来的商品
          */
         private LinkedBlockingQueue<Integer> queue = new LinkedBlockingQueue<Integer>();
         /**
          * 定义生产商品个数
          */
         private static final int size = 10;
         /**
          * 定义启动线程的标志，为0时，启动生产商品的线程；为1时，启动消费商品的线程
          */
         private int flag = 0;
     
         private class LinkBlockThread implements Runnable {
             @Override
             public void run() {
                 int new_flag = flag++;
                 System.out.println("启动线程 " + new_flag);
                 if (new_flag == 0) {
                     for (int i = 0; i < size; i++) {
                         int b = new Random().nextInt(255);
                         System.out.println("生产商品：" + b + "号");
                         try {
                             queue.put(b);
                         } catch (InterruptedException e) {
                             // TODO Auto-generated catch block
                             e.printStackTrace();
                         }
                         System.out.println("仓库中还有商品：" + queue.size() + "个");
                         try {
                             Thread.sleep(100);
                         } catch (InterruptedException e) {
                             // TODO Auto-generated catch block
                             e.printStackTrace();
                         }
                     }
                 } else {
                     for (int i = 0; i < size / 2; i++) {
                         try {
                             int n = queue.take();
                             System.out.println("消费者买去了" + n + "号商品");
                         } catch (InterruptedException e) {
                             // TODO Auto-generated catch block
                             e.printStackTrace();
                         }
                         System.out.println("仓库中还有商品：" + queue.size() + "个");
                         try {
                             Thread.sleep(100);
                         } catch (Exception e) {
                             // TODO: handle exception
                         }
                     }
                 }
             }
         }
     
         public static void main(String[] args) {
             BlockingSynchronizedThread bst = new BlockingSynchronizedThread();
             LinkBlockThread lbt = bst.new LinkBlockThread();
             Thread thread1 = new Thread(lbt);
             Thread thread2 = new Thread(lbt);
             thread1.start();
             thread2.start();
         }
     }
     ```

     注：BlockingQueue<E>定义了阻塞队列的常用方法，尤其是三种添加元素的方法，我们要多加注意，当队列满时：add()方法会抛出异常，offer()方法返回false，put()方法会阻塞。

  7. 使用**原子变量**实现线程同步

     需要使用线程同步的根本原因在于对普通变量的操作不是原子的。那么什么是原子操作呢？原子操作就是指将读取变量值、修改变量值、保存变量值看成一个整体来操作，即-这几种行为要么同时完成，要么都不完成。在java的**util.concurrent.atomic包中提供了创建了原子类型变量的工具类**，使用该类可以简化线程同步。其中**AtomicInteger** 表可以用原子方式更新int的值，可用在应用程序中(如以原子方式增加的计数器)，但不能用于替换Integer；可扩展Number，允许那些处理机遇数字类的工具和实用工具进行统一访问。

     **AtomicInteger类常用方法：**

     - AtomicInteger(int initialValue) : 创建具有给定初始值的新的AtomicInteger
     - addAddGet(int dalta) : 以原子方式将给定值与当前值相加
     - get() : 获取当前值

     **代码实例：**只改Bank类，其余代码与上面第一个例子同

     ```java
     class Bank {
         private AtomicInteger account = new AtomicInteger(100);
     
         public AtomicInteger getAccount() {
             return account;
         }
     
         public void save(int money) {
             account.addAndGet(money);
         }
     }
     ```

     **补充--原子操作主要有：**

     对于引用变量和大多数原始变量(long和double除外)的读写操作；

     对于所有使用volatile修饰的变量(包括long和double)的读写操作。

- 多线程中的i++线程安全吗？请简述一下原因？

  不安全。i++不是原子性操作。i++分为读取i值，对i值加一，再赋值给i++，执行期中任何一步都是有可能被其他线程抢占的。

- synchronized与java.util.concurrent.locks.Lock的相同之处和不同之处

  > [https://blog.csdn.net/qq838642798/article/details/65441415](<https://blog.csdn.net/qq838642798/article/details/65441415>)

  ReenTrantLock可重入锁（和synchronized的区别）总结

  **可重入性：**

  从名字上理解，ReenTrantLock的字面意思就是再进入的锁，其实synchronized关键字所使用的锁也是可重入的，两者关于这个的区别不大。两者都是同一个线程每进入一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。

  **锁的实现：**

  Synchronized是依赖于JVM实现的，而ReenTrantLock是JDK实现的，有什么区别，说白了就类似于操作系统来控制实现和用户自己敲代码实现的区别。前者的实现是比较难见到的，后者有直接的源码可供阅读。

  **性能的区别：**

  在Synchronized优化以前，synchronized的性能是比ReenTrantLock差很多的，但是自从Synchronized引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用synchronized，其实synchronized的优化我感觉就借鉴了ReenTrantLock中的CAS技术。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。

  **功能区别：**

  便利性：很明显**Synchronized的使用比较方便简洁，并且由编译器去保证锁的加锁和释放，而ReenTrantLock需要手工声明来加锁和释放锁，为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。**

  锁的细粒度和灵活度：很明显ReenTrantLock优于Synchronized

  **ReenTrantLock独有的能力：**

  1. **ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。**

  1. **ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的诸线程，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。**

  1. ReenTrantLock提供了一种能够**中断等待锁**的线程的机制，通过lock.lockInterruptibly()来实现这个机制。

  **ReenTrantLock实现的原理：**

  在网上看到相关的源码分析，本来这块应该是本文的核心，但是感觉比较复杂就不一一详解了，简单来说，ReenTrantLock的实现是一种自旋锁，通过循环调用CAS操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。**想尽办法避免线程进入内核的阻塞状态是我们去分析和理解锁设计的关键钥匙。**

  **什么情况下使用ReenTrantLock：**

  答案是，如果你需要实现ReenTrantLock的三个独有功能时。

- synchronized的可重入怎么实现

  > 《Java并发编程实践》

  **“重入”意味这获取锁的操作的粒度是“线程”，而不是“调用”。**重入的一种**实现方法**是，为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值置为1. 如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应地递减。当计数值为0时，这个锁将被释放。

  > [https://www.jianshu.com/p/5379356c648f](<https://www.jianshu.com/p/5379356c648f>)

  若一个程序或子程序可以“**在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错**”，则称其为可重入（reentrant或re-entrant）的。即**当该子程序正在运行时，执行线程可以再次进入并执行它**，仍然获得符合设计时预期的结果。与多线程并发执行的线程安全不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的。

- 非公平锁和公平锁在reetrantlock里的实现过程是怎样的

  > [https://blog.csdn.net/rickiyeat/article/details/78307739](<https://blog.csdn.net/rickiyeat/article/details/78307739>)

  所谓公平锁，就是线程按照执行顺序排成一排，依次获取锁，但是这种方式在高并发的场景下极其损耗性能；这时候，非公平锁应运而生了，所谓非公平锁，就是不管执行顺序，每个线程获取锁的几率都是相同的，获取失败了，才会采用像公平锁那样的方式。这样做的好处是，JVM可以花比较少的时间在线程调度上，更多的时间则是用在执行逻辑代码里面。

  - **NonfairSync 非公平锁**

  - **FairSync 公平锁**

    公平锁就是每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照FIFO的规则从队列中获取。

- 《Java并发编程实战》摘录

  - 第二章 线程安全性

    - **安全性**的含义是“**永远不发生糟糕的事情**”，而**活跃性**则关注于另一个目标，即“**某件正确的事情最终会发生**”。

    - **当多个线程访问某个类时**，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，**这个类都能表现出正确的行为**，那么就称**这个类是线程安全的**。

    - 无状态对象一定是线程安全的。

    - 当某个计算的正确性取决于多个线程的交替执行时序时，就会发生**竞争条件**(race condition)。换句话说，就是正确的结果要取决于运气。最常见的竞争条件类型就是“**先检查后执行**(check-then-act)”操作，即通过一个可能失效的观测结果来决定下一步的动作。

    - 假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说时**原子的**。原子操作是指，对于访问同一个状态的所有操作（包括该操作本身）来说，这个操作是一个以原子方式执行的操作。

    - 在java.util.concurrent.atomic包中包含了一些原子变量类，用于实现在数值和对象引用上的原子状态转换。通过用AtomicLong来代替long类型的计数器，能够确保所有对计数器状态的访问操作都是原子的。

    - 要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。

    - **“重入”意味这获取锁的操作的粒度是“线程”，而不是“调用”。**重入的一种**实现方法**是，为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值置为1. 如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应地递减。当计数值为0时，这个锁将被释放。

      在以下代码中，子类改写了父类的synchronized方法，然后调用父类的方法，此时如果没有可重入的锁，那么这段代码将产生死锁。

      ```java
      public class Widget {
          public synchronized void doSomething() {
              ...
          }
      }
      
      public class LoggingWiget extends Widget {
          public synchronized void doSomething() {
              System.out.println(toString() + ": calling doSomething");
              super.doSomething();
          }
      }
      ```

    - 一种常见的错误是认为，只有在写入共享变量时才需要使用同步，然而事实并非如此。

    - 对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态是由这个锁保护的。**每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁。对于包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护。**

    - Servlet中一个同步代码块负责保护判断是否只需返回缓存结果的“先检查后执行”操作序列，另一个同步代码块则负责确保对缓存的数值和引述分解结果进行同步更新。

      ```java
      @ThreadSafe
      public class CacheFactorizer implments Servlet {
          @GuardedBy("this") private BigInteger lastNumber;
          @GuardedBy("this") private BigInteger[] lastFactors;
          @GuardedBy("this") private long hits;
          @GuardedBy("this") private long cacheHits;
          
          public synchronized long getHits() { return hits; }
          public synchronized double getCacheHitRatio() {
              return (double) cacheHits / (double) hits;
          }
          
          public void service(ServletRequest req, ServletResponse resq) {
              BigInteger i = extractFromRequest(req);
              BigInteger[] factors = null;
              synchronized (this) {
                  ++hits;
                  if (i.equals(lastNumber)) {
                      ++cacheHits;
                      factors = lastFactors.clone();
                  }
              }
              if (factors == null) {
                  factors = factor(i);
                  synchronized (this) {
                      lastNumber = i;
                      lastFactors = factors.clone();
                  }
              }
              encodeIntResponse(resp, factors);
          }
      }
      ```

      在简单性与性能之间存在着相互制约因素。

      **当执行时间较长的计算或者可能无法快速完成的操作时（例如，网络I/O或控制台I/O），一定不要持有锁。**

  - 第三章 对象的共享

    - 在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意向不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得出正确的结论。在缺乏同步的程序中可能产生错误结果的一种情况是**失效数据**。仅对set方法进行同步是不够的，调用get的线程仍然会看到失效值。

    - 当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性保证也被称为最低安全性(out-of-thin-air safety)。最低安全性适用于绝大多数变量，但是存在一个例外：非volatile类型的64位数值变量（double和long）。Java内存模型要求，变量的读取操作和写入操作都必须时原子操作，但对于非volatile类型的long和double变量，JVM允许将64位读操作或写操作分解为两个32位的操作。当读取一个非volatile类型的long时，如果对该变量的读操作和写操作在不同的线程中执行，那么很可能会读取到某个值的高32位和另一个值的低32位。

    - 在访问某个共享且可变的变量时要求所有线程在同一个锁上同步，就是为了确保某个线程写入该变量的值对于其他线程来说时可见的。**加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。**

    - **Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保变量的更新操作通知到其他线程。在读取volatile类型的变量时总会返回最新写入的值。在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比synchronized关键字更轻量级的同步机制。**

    - volatile变量对可见性的影响比volatile变量本身更为重要。当线程A首先写入一个volatile变量并且线程B随后读取该变量时，在写入volatile变量之前对A可见的所有变量的值，在B读取了volatile变量后，对B也是可见的。因此，从内存可见性的角度来看，写入volatile变量相当于退出同步代码块，而读取volatile变量就相当于进入同步代码块。

    - **加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。**虽然volatile变量很方便，但也存在一些局限性，在使用时要非常小心。例如，volatile的语义不足以确保递增操作(count++)的原子性，除非你能确保只有一个线程对变量执行写操作。

    - 当且仅当满足以下所有条件时，才应该使用volatile变量：

      - 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。
      - 该变量不会与其他状态一起纳入不变性条件中。
      - 在访问变量时不需要加锁。

    - volatile变量的典型用法：检查某个状态标记以判断是否退出循环。为了使这个示例能正确执行，asleep必须位volatile变量。否则，当asleep被另一个线程修改时，执行判断的线程却发现不了。

      ```java
      volatile boolean asleep;
      ...
          while (!asleep)
              countSomeSheep();
      ```

#### JVM

- JVM加载class文件的原理

  > [https://www.cnblogs.com/Qian123/p/5707562.html](<https://www.cnblogs.com/Qian123/p/5707562.html>)

   Java中的所有类，都需要由类加载器装载到JVM中才能运行。类加载器本身也是一个类，而它的工作就是把class文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。

  类装载方式，有两种 

  1. 隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中，
  2. 显式装载， 通过class.forname()等方法，显式加载需要的类 

  隐式加载与显式加载的区别：两者本质是一样? 

  Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到jvm中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。

  Java的类加载器有三个，对应Java的三种类:（java中的类大致分为三种：   1.系统类   2.扩展类 3.由程序员自定义的类 ）

  ​     Bootstrap Loader  // 负责加载**系统类** (指的是内置类，像是String，对应于C#中的System类和C/C++标准库中的类)
  ​            | 
  ​          \- - ExtClassLoader   // 负责加载**扩展类**(就是继承类和实现类)
  ​                          | 
  ​                      \- - AppClassLoader   // 负责加载应用类(**程序员自定义的类**)

  三个加载器各自完成自己的工作，但它们是如何协调工作呢？哪一个类该由哪个类加载器完成呢？为了解决这个问题，Java采用了**委托模型机制**。

  **委托模型机制的工作原理很简单：当类加载器需要加载类的时候，先请示其Parent(即上一层加载器)在其搜索路径载入，如果找不到，才在自己的搜索路径搜索该类。这样的顺序其实就是加载器层次上自顶而下的搜索，因为加载器必须保证基础类的加载。**之所以是这种机制，还有一个安全上的考虑：如果某人将一个恶意的基础类加载到jvm，委托模型机制会搜索其父类加载器，显然是不可能找到的，自然就不会将该类加载进来。

  我们可以通过这样的代码来获取类加载器:

  ```java
  ClassLoader loader = ClassName.class.getClassLoader();
  ClassLoader ParentLoader = loader.getParent();
  ```

  注意一个很重要的问题，就是Java在逻辑上并不存在BootstrapLoader的实体！因为它是用C++编写的，所以打印其内容将会得到null。

  前面是对类加载器的简单介绍，它的原理机制非常简单，就是下面几个步骤:

  1. **加载**:查找和导入class文件;

  2. **连接**:

     (1)**验证**:检查载入的class文件数据的正确性;

     (2)**准备**:为类的静态变量分配存储空间;

     (3)**解析**:将符号引用转换成直接引用(这一步是可选的)

  3. **初始化**:初始化静态变量，静态代码块。

  这样的过程在程序调用类的静态成员的时候开始执行，所以静态方法main()才会成为一般程序的入口方法。类的构造器也会引发该动作。

  ![img](https://uploadfiles.nowcoder.com/images/20180926/308572_1537962641528_95106A90F455887E4A4B298735A4641B)

  >《深入理解JVM》P191

  **双亲委派模型**的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委托给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载器请求最终都应该传送到顶层的启动类加载器中，只有当父加载器自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。

- 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？

  > [https://www.nowcoder.com/questionTerminal/a90230b35b5f4a7287f779ecdd88841d](<https://www.nowcoder.com/questionTerminal/a90230b35b5f4a7287f779ecdd88841d>)

  java的跨平台不是java源程序的跨平台 ，如果是这样，那么所有语言都是跨平台的， java源程序先经过javac编译器编译成二进制的.class字节码文件（java的跨平台指的就是.class字节码文件的跨平台，.class字节码文件是与平台无关的），.class文件再运行在jvm上，java解释器（jvm的一部分）会将其解释成对应平台的机器码执行，所以java所谓的跨平台就是在不同平台上安装了不同的jvm，而在不同平台上生成的.class文件都是一样的，而.class文件再由对应平台的jvm解释成对应平台的机器码执行。 

  最后解释下机器码和字节码的区别: 

  一，机器码，完全依附硬件而存在～并且不同硬件由于内嵌指令集不同，即使相同的0 1代码 意思也可能是不同的～换句话说，根本不存在跨平台性～比如～不同型号的CPU,你给他个指令10001101，他们可能会解析为不同的结果～ 

  二，我们知道JAVA是跨平台的，为什么呢？因为他有一个jvm,不论哪种硬件，只要你装有jvm,那么他就认识这个JAVA字节码～～～～至于底层的机器码，咱不用管，有jvm搞定，他会把字节码再翻译成所在机器认识的机器码～～～

- JVM最大内存限制多少？

  > [https://blog.csdn.net/lengyuhong/article/details/6044894](<https://blog.csdn.net/lengyuhong/article/details/6044894>)

  没想到第一个实验的程序，跑了几个小时，就遇到了Out of Memory Exception了。看看自己的虚拟机设置，我设置的是-Xms512M -Xmx1024M。想都没想，直接改成-Xms512M -Xmx2048M，结果直接就Could not reserve enough space for object heap。程序都起不来了。这才发现原来最大内存还有限制。上网搜了一下，发现很多讨论这个问题的文章。最终在BEA的DEV2DEV论坛发现了最有用的一篇

  这里的版主YuLimin 做了[测试](http://softtest.chinaitlab.com/)，得出结论：

  　　公司 JVM版本                  最大内存(兆)client    最大内存(兆)server

  　　SUN 1.5.x                          1492                            1520

  　　SUN 1.5.5(Linux)             2634                            2660

  　　SUN 1.4.2                          1564                            1564

  　　SUN 1.4.2(Linux)             1900                            1260

  　　IBM 1.4.2(Linux)             2047                             N/A

  　　BEA JRockit 1.5 (U3)      1909                             1902

  >[https://www.nowcoder.com/questionTerminal/855006adab6b45afb9fe98e3c72b90d6](<https://www.nowcoder.com/questionTerminal/855006adab6b45afb9fe98e3c72b90d6>)

  首先JVM内存限制于实际的最大物理内存了 假设物理内存无限大的话 JVM内存的最大值跟操作系统有很大的关系 简单的说就32位处理器虽然可控内存空间有4GB,但是具体的操作系统会给一个限制，这个限制一般是2GB-3GB（一般来说Windows系统下为1.5G-2G Linux系统 下为2G-3G） 而64bit以上的处理器就不会有限制了

- JVM是如何实现线程的？

  > 《深入理解JVM》P333 Java与线程
  >
  > [https://blog.csdn.net/qq_33938256/article/details/52615257](<https://blog.csdn.net/qq_33938256/article/details/52615257>)

  并发不一定要依赖多线程（如PHP中很常见的多进程并发），但是在Java里面谈论并发，大多数都与线程脱不开关系。

  - 线程的实现

    线程是比进程更轻量级的调度执行单位，线程的引入，可以把一个进程的**资源分配**和**执行调度**分开，各个线程既可以共享进程资源（内存地址、文件I/O等），又可以独立调度（线程是CPU调度的最基本单位）。

    主流的操作系统都提供了线程实现，Java语言则提供了在不同硬件和操作系统平台下对线程操作的同一处理，每个java.lang.Thread类的实例就代表了一个线程。**Thread类的关键方法，都声明为Native**。这意味着这个方法无法或没有使用平台无关的手段来实现，也可能是为了执行效率。

    实现线程主要有三种方式：使用内核线程实现，使用用户线程实现，使用用户线程加轻量级进程混合实现。

    1. **使用内核线程实现**

       内核线程就是直接由操作系统内核支持的线程。

       - **由内核来完成线程切换**
       - 内核通过调度器Scheduler调度线程，并将线程的任务映射到各个CPU上
       - 程序使用**内核线程的高级接口**，**轻量级进程**(Light Weight Process,LWP)–>(!!!名字是进程，实际是线程)
       - **用户态和内核态切换消耗内核资源**
       - 轻量级进程与内核线程之间的1:1关系称为**一对一线程模型**

    2. **使用用户线程实现**

       - 系统内核不能感知线程存在的实现
       - **用户线程的建立、同步、销毁和调度完全在用户态中完成**
       - 所有线程操作需要用户程序自己处理，复杂度高
       - 这种进程与线程之间1:N的关系称为**一对多的线程模型**

    3. **混合实现**

       - 轻量级进程作为用户线程和内核线程之间的桥梁
       - 混合模式中，用户线程与轻量级进程的数量比是不定的，是M:N的关系，称为**多对多关系**

    4. Java线程的实现

       对于Sun JDK来说，它的Windows版与Linux版都是使用一对一的线程模型来实现的，一条Java线程就映射到一条轻量级进程之中，因为Windows和Linux系统系统提供的线程模型就是一对一的。

  - Java线程调度

    线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是协同式线程调度和抢占式线程调度。

    - 协同式调度：线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上去。

      优点：实现简单，而且由于线程要把自己的事情干完后才会进行线程切换，切换操作对线程自己是可知的，所以没有什么线程同步的问题。

      缺点：线程执行时间不可控制，甚至如果一个线程编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞在那里。

    - 抢占式调度：每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定。

      在这种实现线程调度的方式下，线程的执行时间是系统可控的，也不会有一个线程导致整个进程阻塞的问题，Java使用的线程调度方式就是抢占式调度。

    虽然说Java线程调度是系统自动完成的，但是我们还是可以“建议”系统给某些线程多分配一点执行时间，另外的一些线程则可以少分配一点——这项操作可以同故宫设置线程优先级来完成。Java语言一共设置了10个级别的线程优先级。

    不过，线程优先级并不是太靠谱，原因是Java的线程是被映射到系统原生线程上来实现的，所以线程调度最终还是有操作系统说了算，虽然现在很多操作系统都提供线程优先级的概念，但是并不见得能与Java线程的优先级一一对应。Windows只有7中优先级，比Java线程优先级少，不得不出现几个优先级相同的情况。还有其他情况让我们不能太依赖优先级：优先级可能会被系统自行改变。例如在Windows系统中存在一个名为“优先级推进器”的功能，它的大致作用就是当系统发现一个线程被执行得特别“勤奋努力”的话，可能会越过线程优先级去为它分配执行时间。

  > 王道操作系统 P34

  - 线程的实现方式

    线程的实现可以分为两类，**用户级线程**和**内核级线程**。

    **在用户级线程中，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。应用程序可以通过使用线程库设计成多线程程序。**通常，应用程序从单线程起始，在该线程中开始运行，在其运行的任何时刻，可以通过调用线程库中的派生例程创建一个在相同进程中运行的新线程。

    **在内核级线程中，线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只有一个到内核级线程的编程接口。**内核为进程及其内部的每个线程维护上下文信息，调度也是在内核基于线程架构的基础上完成。

    在一些系统中，使用**组合方式**的多线程实现。线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行，一个应用程序中的多个用户级线程被映射到一些内核级线程上。

  - 多线程模型

    有的系统同时支持用户线程和内核线程，由此产生了不同的多线程模型。

    1. **多对一模型**。**将多个用户级线程映射到一个内核级线程**，线程管理在用户空间完成。

       优点：线程管理是在用户空间进行的，因此效率比较高。

       缺点：当一个线程在使用内核服务被阻塞，那么整个进程都会被阻塞；多个线程不能并行地运行在多处理器上。

    2. **一对一模型**。将每个用户及线程映射到一个内核级线程。

       优点：当一个线程被阻塞后允许另一个线程继续执行，所以并发能力较强。

       缺点：每创建一个用户及线程都需要创建一个内核级线程与其对应，这样创建线程的开销比较大，会影响到应用程序的性能。

    3. **多对多模型**。将$n$个用户及线程映射到$m$个内核级线程上，要求$m\le n$。

- 什么是Java内存模型？

  > 《深入理解JVM》P318

  Java虚拟机规范中试图定义一种Java内存模型(JMM)来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果。

  Java内存模型规定了所有的变量都存储在主内存中。每个线程还有自己的工作内存，线程的工作内存中给保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读取主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。

  > [https://blog.csdn.net/suifeng3051/article/details/52611310](<https://blog.csdn.net/suifeng3051/article/details/52611310>)

  Java内存模型(简称JMM)。**JMM决定一个线程对共享变量的写入何时对另一个线程可见**。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：**线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本**。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。

  ![这里写图片描述](https://img-blog.csdn.net/20160921182337904)

  从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：

  1. 首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。
  2. 然后，线程B到主内存中去读取线程A之前已更新过的共享变量。 

  下面通过示意图来说明这两个步骤：
  ![这里写图片描述](https://img-blog.csdn.net/20160921182748551)

  如上图所示，本地内存A和B有主内存中共享变量x的副本。假设初始时，这三个内存中的x值都为0。线程A在执行时，把更新后的x值（假设值为1）临时存放在自己的本地内存A中。当线程A和线程B需要通信时，线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变为了1。随后，线程B到主内存中去读取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。

  从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。

- 在JAVA虚拟机中，哪些对象可作为ROOT对象？

  > 《深入理解JVM》P46 根搜索算法
  >
  > [https://www.nowcoder.com/questionTerminal/b898ead0055e47fd8ae2ea896bfdd0c1](<https://www.nowcoder.com/questionTerminal/b898ead0055e47fd8ae2ea896bfdd0c1>)

  在主流的商用程序语言中，都是使用**根搜索算法**判断对象是否存活。这个算法的基本思路就是通过一系列的名为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连（用凸轮的话来说就是从GC Roots到这个对象不可达）时，则证明此对象时不可用的。

  在Java语言中，可作为GC Roots的对象包括下面几种：

  1. **虚拟机栈**（栈帧中的本地变量表）中引用的对象
  2. **方法区中的类静态变量**引用的对象
  3. **方法区中的常量**引用的对象
  4. **本地方法栈中JNI**（即一般说的Native方法）的引用的变量

- GC中如何判断对象是否需要被回收？

  > 《深入理解JVM》P44 对象已死？
  >
  > [https://blog.csdn.net/u010126792/article/details/82855265](<https://blog.csdn.net/u010126792/article/details/82855265>) 判断一个对象是否可用（存活，可回收），GC回收对象的过程方式，finilized函数了解吗，调用了finilized函数的对象一定会被回收吗，可以主动调用finilized函数吗？

  - 判断对象是否需要被回收

    - 引用计数算法

      给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时候计数器都为0的对象就是不可能再被使用的。

      Java语言中没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间的相互循环引用的问题。但是它们的引用计数可能都不为0，计数引用算法无法通知GC收集器回收它们。

    - 根搜索算法

      在主流的商用程序语言中，都是使用**根搜索算法**判断对象是否存活。这个算法的基本思路就是通过一系列的名为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连（用凸轮的话来说就是从GC Roots到这个对象不可达）时，则证明此对象时不可用的。

      在Java语言中，可作为GC Roots的对象包括下面几种：

      1. **虚拟机栈**（栈帧中的本地变量表）中引用的对象
      2. **方法区中的类静态变量**引用的对象
      3. **方法区中的常量**引用的对象
      4. **本地方法栈中JNI**（即一般说的Native方法）的引用的变量

  - Java的四种引用类型

    上面的分析可知，无论是通过引用计数还是可达性分析的判断都用到了引用，那么引用是否可以被回收就至关重要了，如果一个引用要么可以被回收，要么就不能被回收，那对于一些“可回收”的对象就无能无力了，jdk1.2之后扩充了引用的概念，将引用分为强引用（Strong Reference），软引用（Soft Reference），弱引用（Weak Reference），虚引用（Phantom Reference），四种引用引用的强度依次逐渐减弱。

    **强引用**：程序中的普通对象赋值就是强引用，只要引用还在垃圾回收器就永远不会回收被引用的对象。

    **软引用**：描述还有用但并非必须的对象，在系统将要发生内存溢出异常之前，将会把这些对象放入回收范围内进行二次回收，如果还没有足够内存，才抛出异常。

    **弱引用**：也是用来描述非必须对象，强度更弱，弱引用关联的对象只能生存到下一次垃圾收集发生之前，无论内存是否足够都会被回收掉。

    **虚引用**：一个对象是否有虚引用的存在，不会对其生存时间产生任何影响，也无法通过虚引用获取对象实例，虚引用的唯一一个目的就是能在对象被回收时收到一个系统通知。

  - finalize()方法

    在根搜索算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行根搜索后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。

    如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程区执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）复制给某个类变量或对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那它就真的离死不远了。

    并不鼓励使用finalize()方法来拯救对象，因为它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。finalize()能做的所有工作，使用try-finally或其他方式都可以做得更好。

- 假设一个场景，要求stop the world时间非常短，你会怎么设计垃圾回收机制？

  绝大多数新创建的对象分配在Eden区。

  在Eden区发生一次GC后，存活的对象移到其中一个Survivor区。

  在Eden区发生一次GC后，对象是存放到Survivor区，这个Survivor区已经存在其他存活的对象。

  一旦一个Survivor区已满，存活的对象移动到另外一个Survivor区。然后之前那个空间已满Survivor区将置为空，没有任何数据。

  经过重复多次这样的步骤后依旧存活的对象将被移到老年代。

- Eden区和Survivor区的含义以及工作原理？

  目前主流的虚拟机实现都采用了分代收集的思想，把整个堆区划分为新生代和老年代；新生代又被划分成Eden 空间、 From Survivor 和 To Survivor 三块区域。

  我们把Eden : From Survivor : To Survivor 空间大小设成 8 : 1 : 1 ，对象总是在 Eden 区出生， From Survivor 保存当前的幸存对象， To Survivor 为空。一次 gc 发生后： 1）Eden 区活着的对象 ＋ From Survivor 存储的对象被复制到 To Survivor ；2) 清空 Eden 和 From Survivor ； 3) 颠倒 From Survivor 和 To Survivor 的逻辑关系： From 变 To ， To 变 From 。可以看出，只有在 Eden 空间快满的时候才会触发 Minor GC 。而 Eden 空间占新生代的绝大部分，所以 Minor GC 的频率得以降低。当然，使用两个 Survivor 这种方式我们也付出了一定的代价，如 10% 的空间浪费、复制对象的开销等。

  > 《深入理解JVM》P51 垃圾收集算法

  - 标记-清除算法

    算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。

    它的主要缺点有两个：一个是效率问题，标记和清除过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量布莱纳许的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

  - 复制算法

    为了解决效率问题，一种称为“复制”的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这块用完了，就将还活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样是的每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价时将内存缩小为原来的一半，未免太高了一点。

    现在的商业虚拟机都采用这种收集算法来回收新生代，新生代中的对象98%是朝生夕死的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%(80%+10%)，只有10%的内存是会被“浪费”的。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够时，需要依赖其他内存（这里指老年代）进行分配担保。

  - 标记-整理算法

    根据老年代的特点，有人提出了另外一种“标记-整理”算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象对象进行清理，而是所有存活的对象都向一端移动，然后直接清理掉段边界以外的内存。

  - 分代收集算法

    当前商业虚拟机的垃圾收集都采用“分代收集”算法，这种算法并没有什么新的思想，只是根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少了存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。

- JVM运行时数据区域

  > [https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F?id=%e5%86%99%e5%9c%a8%e5%89%8d%e9%9d%a2-%e5%b8%b8%e8%a7%81%e9%9d%a2%e8%af%95%e9%a2%98](<https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F?id=%e5%86%99%e5%9c%a8%e5%89%8d%e9%9d%a2-%e5%b8%b8%e8%a7%81%e9%9d%a2%e8%af%95%e9%a2%98>)

  **线程私有的：**

  - 程序计数器
  - 虚拟机栈
  - 本地方法栈

  **线程共享的：**

  - 堆
  - 方法区
  - 直接内存 (非运行时数据区的一部分)

  ![img](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png)

  > 《深入理解JVM》P25 运行时数据区域

  Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。

  - 程序计数器

    程序计数器是一块较小的内存空间，它的作用可以看作是当前线程所执行的字节码的行号指示器。**字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。**

    另外，**为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。**

    **注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。**

  - Java虚拟机栈

    **与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。**

    **Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。** （实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）

    **局部变量表主要存放了编译器可知的各种数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。

    **Java 虚拟机栈会出现两种错误：StackOverFlowError 和 OutOfMemoryError。**

    - **StackOverFlowError：** 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。
    - **OutOfMemoryError：** 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError 错误。

    Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。

  - 本地方法栈

    和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

    本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。

    方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。

  - Java堆

    Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都是在这里分配内存。

    Java堆是垃圾收集器管理的主要区域，因此很多时候也被称作“GC堆”。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老生代，再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。

    根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。

  - 方法区

    方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 **Java 虚拟机规范把方法区描述为堆的一个逻辑部分**，但是它却有一个别名叫做 **Non-Heap（非堆）**，目的应该是与 Java 堆区分开来。

    《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 **方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。** 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。

    根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。

  - 运行时常量池

    运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项时常量池信息，用于存放编译期生成的各种字面量和符号引用，这部分内容酱紫啊类加载后存放到方法区的运行时常量池中。

    既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。

  - 直接内存

    **直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。**

    JDK1.4 中新加入的 **NIO(New Input/Output) 类**，引入了一种基于**通道（Channel）** 与**缓存区（Buffer）** 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为**避免了在 Java 堆和 Native 堆之间来回复制数据**。

    本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。

- JVM的回收算法以及它的回收器是什么？CMS采用哪种回收算法？使用CMS怎样解决内存碎片的问题呢？

  > 《深入理解JVM》P51 垃圾收集算法

  - 标记-清除算法

    算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。

    它的主要缺点有两个：一个是效率问题，标记和清除过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量布莱纳许的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

  - 复制算法

    为了解决效率问题，一种称为“复制”的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这块用完了，就将还活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样是的每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价时将内存缩小为原来的一半，未免太高了一点。

    现在的商业虚拟机都采用这种收集算法来回收新生代，新生代中的对象98%是朝生夕死的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%(80%+10%)，只有10%的内存是会被“浪费”的。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够时，需要依赖其他内存（这里指老年代）进行分配担保。

  - 标记-整理算法

    根据老年代的特点，有人提出了另外一种“标记-整理”算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象对象进行清理，而是所有存活的对象都向一端移动，然后直接清理掉段边界以外的内存。

  - 分代收集算法

    当前商业虚拟机的垃圾收集都采用“分代收集”算法，这种算法并没有什么新的思想，只是根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少了存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。

  > 《深入理解JVM》P55 垃圾收集器
  >
  > [https://crowhawk.github.io/2017/08/15/jvm_3/](<https://crowhawk.github.io/2017/08/15/jvm_3/>)

  **如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。**Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、版本的虚拟机所提供的垃圾收集器都可能会有很大差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。接下来讨论的收集器基于JDK1.7 Update 14 之后的HotSpot虚拟机（在此版本中正式提供了商用的G1收集器，之前G1仍处于实验状态），该虚拟机包含的所有收集器如下图所示：

  ![img](https://pic.yupoo.com/crowhawk/56a02e55/3b3c42d2.jpg)

  上图展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。Hotspot实现了如此多的收集器，正是因为目前并无完美的收集器出现，只是选择对具体应用最适合的收集器。

  - 相关概念

    - 并行和并发

      - **并行（Parallel）**：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
      - **并发（Concurrent）**：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行。而垃圾收集程序运行在另一个CPU上。

    - 吞吐量（Throughput）

      吞吐量就是**CPU用于运行用户代码的时间**与**CPU总消耗时间**的比值，即

      **吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。**

      假设虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。

    - Minor GC 和 Full GC
      - **新生代GC（Minor GC）**：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。具体原理见上一篇文章。
      - **老年代GC（Major GC / Full GC）**：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。

  - 新生代收集器

    - Serial收集器

      **Serial（串行）**收集器是最基本、发展历史最悠久的收集器，它是采用**复制算法**的**新生代收集器**，曾经（JDK 1.3.1之前）是虚拟机**新生代**收集的唯一选择。它是一个单线程收集器，只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是**它在进行垃圾收集时，必须暂停其他所有的工作线程，直至Serial收集器收集结束为止（“Stop The World”）**。这项工作是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说是难以接收的。

      下图展示了Serial 收集器（老年代采用Serial Old收集器）的运行过程：

      ![img](https://pic.yupoo.com/crowhawk/6b90388c/6c281cf0.png)

      为了消除或减少工作线程因内存回收而导致的停顿，HotSpot虚拟机开发团队在JDK 1.3之后的Java发展历程中研发出了各种其他的优秀收集器，这些将在稍后介绍。但是这些收集器的诞生并不意味着Serial收集器已经“老而无用”，实际上到现在为止，它依然是**HotSpot虚拟机运行在Client模式下的默认的新生代收集器**。它也有着优于其他收集器的地方：**简单而高效（与其他收集器的单线程相比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得更高的单线程收集效率。**

      在用户的桌面应用场景中，分配给虚拟机管理的内存一般不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本不会再大了），停顿时间完全可以控制在几十毫秒最多一百毫秒以内，只要不频繁发生，这点停顿时间可以接收。所以，Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择。

    - ParNew 收集器

      **ParNew**收集器就是Serial收集器的多线程版本，它也是一个**新生代收集器**。除了使用多线程进行垃圾收集外，其余行为包括Serial收集器可用的所有控制参数、收集算法（复制算法）、Stop The World、对象分配规则、回收策略等与Serial收集器完全相同，两者共用了相当多的代码。

      ParNew收集器的工作过程如下图（老年代采用Serial Old收集器）：

      ![img](https://pic.yupoo.com/crowhawk/605f57b5/75122b84.png)

      ParNew收集器除了使用多线程收集外，其他与Serial收集器相比并无太多创新之处，但它却是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关的重要原因是，**除了Serial收集器外，目前只有它能和CMS收集器（Concurrent Mark Sweep）配合工作**，CMS收集器是JDK 1.5推出的一个具有划时代意义的收集器，具体内容将在稍后进行介绍。

      ParNew 收集器在**单CPU的环境**中绝对不会有比Serial收集器有更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百地保证可以超越。在**多CPU环境**下，随着CPU的数量增加，它对于GC时系统资源的有效利用是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多的情况下可使用**-XX:ParallerGCThreads**参数设置。

    - Parallel Scavenge 收集器

      **Parallel Scavenge**收集器也是一个**并行**的**多线程新生代**收集器，它也使用**复制算法**。Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标是**达到一个可控制的吞吐量（Throughput）**。

      **停顿时间越短就越适合需要与用户交互的程序**，良好的响应速度能提升用户体验。而**高吞吐量**则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合**在后台运算而不需要太多交互的任务**。

      Parallel Scavenge收集器除了会显而易见地提供可以精确控制吞吐量的参数，还提供了一个参数**-XX:+UseAdaptiveSizePolicy**，这是一个开关参数，打开参数后，就不需要手工指定新生代的大小（-Xmn）、Eden和Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为**GC自适应的调节策略（GC Ergonomics）**。自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。

      另外值得注意的一点是，Parallel Scavenge收集器无法与CMS收集器配合使用，所以在JDK 1.6推出Parallel Old之前，如果新生代选择Parallel Scavenge收集器，老年代只有Serial Old收集器能与之配合使用。

  - 老年代收集器

    - Serial Old收集器

      Serial Old 是 Serial收集器的老年代版本，它同样是一个**单线程收集器**，使用**“标记-整理”（Mark-Compact）**算法。

      此收集器的主要意义也是在于给Client模式下的虚拟机使用。如果在Server模式下，它还有两大用途：

      - 在JDK1.5 以及之前版本（Parallel Old诞生以前）中与Parallel Scavenge收集器搭配使用。
      - 作为CMS收集器的后备预案，在并发收集发生**Concurrent Mode Failure**时使用。

      它的工作流程与Serial收集器相同，这里再次给出Serial/Serial Old配合使用的工作流程图：

      ![img](https://pic.yupoo.com/crowhawk/6b90388c/6c281cf0.png)

    - Parallel Old收集器

      Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用**多线程**和**“标记-整理”**算法。前面已经提到过，这个收集器是在JDK 1.6中才开始提供的，在此之前，如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old以外别无选择，所以在Parallel Old诞生以后，**“吞吐量优先”收集器**终于有了比较名副其实的应用组合，在**注重吞吐量**以及**CPU资源敏感**的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。Parallel Old收集器的工作流程与Parallel Scavenge相同，这里给出Parallel Scavenge/Parallel Old收集器配合使用的流程图：

      ![img](https://pic.yupoo.com/crowhawk/9a6b1249/b1800d45.png)

    - CMS收集器

      **CMS（Concurrent Mark Sweep）**收集器是一种以**获取最短回收停顿时间**为目标的收集器，它非常符合那些集中在互联网站或者B/S系统的服务端上的Java应用，这些应用都非常重视服务的响应速度。从名字上（“Mark Sweep”）就可以看出它是基于**“标记-清除”**算法实现的。

      CMS收集器工作的整个流程分为以下4个步骤：

      - **初始标记（CMS initial mark）**：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要“Stop The World”。
      - **并发标记（CMS concurrent mark）**：进行**GC Roots Tracing**的过程，在整个过程中耗时最长。
      - **重新标记（CMS remark）**：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。此阶段也需要“Stop The World”。
      - **并发清除（CMS concurrent sweep）**

      由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。通过下图可以比较清楚地看到CMS收集器的运作步骤中并发和需要停顿的时间：

      ![img](https://pic.yupoo.com/crowhawk/fffcf9a2/f60599b2.png)

      **优点**

      CMS是一款优秀的收集器，它的主要**优点**在名字上已经体现出来了：**并发收集**、**低停顿**，因此CMS收集器也被称为**并发低停顿收集器（Concurrent Low Pause Collector）**。

      **缺点**

      - **对CPU资源非常敏感** 其实，面向并发设计的程序都对CPU资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。**CMS默认启动的回收线程数是（CPU数量+3）/4**，也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是**当CPU不足4个时（比如2个），CMS对用户程序的影响就可能变得很大**，如果本来CPU负载就比较大，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了50%，其实也让人无法接受。
      - **无法处理浮动垃圾（Floating Garbage）** 可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。**由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生。**这一部分垃圾出现在标记过程之后，CMS无法再当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就被称为**“浮动垃圾”**。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。
      - **标记-清除算法导致的空间碎片** CMS是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次Full GC。为了解决这个问题，CMS收集器提供了一个-XX:+UseCMSCompactAtFullCollection开关参数，用于在“享受”完Full GC服务之后额外免费附送一个碎片整理过程，内存整理的过程是无法并发的。空间碎片问题没有了，但停顿时间不得不变长了。虚拟机设计者还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction，这个参数用于设置在执行多少次不压缩的Full GC后，跟着来一次带压缩的。

    - G1收集器

      **G1（Garbage-First）**收集器是当今收集器技术发展最前沿的成果之一，它是一款**面向服务端应用**的垃圾收集器，HotSpot开发团队赋予它的使命是（在比较长期的）未来可以替换掉JDK 1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点：

      - **并行与并发** G1 能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短“Stop The World”停顿时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。
      - **分代收集** 与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同方式去处理新创建的对象和已存活一段时间、熬过多次GC的旧对象来获取更好的收集效果。
      - **空间整合** G1从整体来看是基于**“标记-整理”**算法实现的收集器，从局部（两个Region之间）上来看是基于**“复制”**算法实现的。这意味着G1运行期间不会产生内存空间碎片，收集后能提供规整的可用内存。此特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。
      - **可预测的停顿** 这是G1相对CMS的一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了降低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在GC上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。

      **横跨整个堆内存**

      在G1之前的其他收集器进行收集的范围都是整个新生代或者老生代，而G1不再是这样。G1在使用时，Java堆的内存布局与其他收集器有很大区别，它**将整个Java堆划分为多个大小相等的独立区域（Region）**，虽然还保留新生代和老年代的概念，但**新生代和老年代不再是物理隔离的了，而都是一部分Region（不需要连续）的集合**。

      **建立可预测的时间模型**

      G1收集器之所以能建立可预测的停顿时间模型，是因为它可以**有计划地避免在整个Java堆中进行全区域的垃圾收集**。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），**在后台维护一个优先列表**，每次根据允许的收集时间，**优先回收价值最大的Region（这也就是Garbage-First名称的来由）**。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。

      **避免全堆扫描——Remembered Set**

      G1把Java堆分为多个Region，就是“化整为零”。但是Region不可能是孤立的，一个对象分配在某个Region中，可以与整个Java堆任意的对象发生引用关系。在做可达性分析确定对象是否存活的时候，需要扫描整个Java堆才能保证准确性，这显然是对GC效率的极大伤害。

      为了避免全堆扫描的发生，虚拟机**为G1中每个Region维护了一个与之对应的Remembered Set**。虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过CardTable**把相关引用信息记录到被引用对象所属的Region的Remembered Set之中**。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。

      ------

      如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为以下几个步骤：

      - **初始标记（Initial Marking）** 仅仅只是标记一下GC Roots 能直接关联到的对象，并且修改**TAMS（Nest Top Mark Start）**的值，让下一阶段用户程序并发运行时，能在正确可以的Region中创建对象，此阶段需要**停顿线程**，但耗时很短。
      - **并发标记（Concurrent Marking）** 从GC Root 开始对堆中对象进行**可达性分析**，找到存活对象，此阶段耗时较长，但**可与用户程序并发执行**。
      - **最终标记（Final Marking）** 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在**线程的Remembered Set Logs**里面，最终标记阶段需要**把Remembered Set Logs的数据合并到Remembered Set中**，这阶段需要**停顿线程**，但是**可并行执行**。
      - **筛选回收（Live Data Counting and Evacuation）** 首先对各个Region中的回收价值和成本进行排序，根据用户所期望的GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。

      通过下图可以比较清楚地看到G1收集器的运作步骤中并发和需要停顿的阶段（Safepoint处）：

      ![img](https://pic.yupoo.com/crowhawk/53b7a589/0bce1667.png)

  - 总结

    | 收集器                | 串行、并行or并发 | 新生代/老年代 | 算法               | 目标             | 适用场景                                  |
    | --------------------- | ---------------- | ------------- | ------------------ | ---------------- | ----------------------------------------- |
    | **Serial**            | **串行**         | 新生代        | 复制算法           | 响应速度优先     | 单CPU环境下的Client模式                   |
    | **ParNew**            | **并行**         | 新生代        | 复制算法           | 响应速度优先     | 多CPU环境时在Server模式下**与CMS配合**    |
    | **Parallel Scavenge** | 并行             | 新生代        | 复制算法           | **吞吐量优先**   | 在后台运算而不需要太多交互的任务          |
    | **Serial Old**        | 串行             | 老年代        | 标记-整理          | 响应速度优先     | 单CPU环境下的Client模式、CMS的后备预案    |
    | **Parallel Old**      | 并行             | 老年代        | 标记-整理          | 吞吐量优先       | 在后台运算而不需要太多交互的任务          |
    | **CMS**               | **并发**         | 老年代        | **标记-清除**      | **响应速度优先** | 集中在互联网站或B/S系统服务端上的Java应用 |
    | **G1**                | 并发             | both          | 标记-整理+复制算法 | 响应速度优先     | 面向服务端应用，将来替换CMS               |

- 垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？并且有什么办法可以主动通知虚拟机进行垃圾回收呢？

  对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。

- 在java中会存在内存泄漏吗？

  > [https://blog.csdn.net/m0_37204491/article/details/64500151](<https://blog.csdn.net/m0_37204491/article/details/64500151>)

  **内存泄露**就是指一个不再被程序使用的对象或变量一直被占据在内存中。java中有垃圾回收机制，它可以保证一对象不再被引用的时候，即对象变成了孤儿的时候，对象将自动被垃圾回收器从内存中清除掉。由于Java 使用有向图的方式进行垃圾回收管理，可以消除引用循环的问题，例如有两个对象，相互引用，只要它们和根进程不可达的，那么GC也是可以回收它们的。

  **java中的内存泄露的情况**：

  1. 长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景，通俗地说，就是**程序员可能创建了一个对象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的**，这就是java中可能出现内存泄露的情况，例如，缓存系统，我们加载了一个对象放在缓存中(例如放在一个全局map对象中)，然后一直不再使用它，这个对象一直被缓存引用，但却不再被使用。

     检查java中的内存泄露，一定要让程序将各种分支情况都完整执行到程序结束，然后看某个对象是否被使用过，如果没有，则才能判定这个对象属于内存泄露。

  2. 如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持久外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。

  3. 当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露。

- 垃圾回收的优点以及原理

  Java 语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有"作用域"的概念，只有对象的引用才有"作用域"。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。

- 什么原因会导致minor gc运行频繁？同样的，什么原因又会导致minor gc运行很慢？

  > [https://www.nowcoder.com/questionTerminal/b3cd86f89d6c4b1ab54252b49a6bff57](<https://www.nowcoder.com/questionTerminal/b3cd86f89d6c4b1ab54252b49a6bff57>)

  什么原因会导致minor gc运行频繁？

  1. **产生了太多朝生夕灭的对象导致需要频繁minor gc**

  2. **新生代空间设置的比较小**

  什么原因会导致minor gc运行很慢？

  1. **新生代空间设置过大。**

  2. **对象引用链较长，进行可达性分析时间较长。**

  3. 新生代survivor区设置的比较小，清理后剩余的对象不能装进去需要移动到老年代，造成移动开销。

  4. 内存分配担保失败，由minor gc转化为full gc

  5. **采用的垃圾收集器效率较低，比如新生代使用serial收集器**

  > 《深入理解JVM》P65 内存分配与回收策略

  - **对象优先在Eden分配**

    大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。

  - **大对象直接进入老年代**

    大对象对虚拟机的内存分配来说是个坏消息，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。

  - **长期存活的对象将进入老年代**

    虚拟机既然采用了分代收集的思想来管理内存，那内存回收时就必须能识别哪些对象应该放在新生代，哪些对象应该放在老年代。为了做到这点，虚拟机给每个对象定义了一个对象年龄计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁）时，就会被晋升到老年代中。对象今生老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold来设置。

  - **动态对象年龄判定**

    为了能更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，**如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代**，无需等到MaxTenuringThreshold中要求的年龄。

  - **空间分配担保**

    在发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则改为直接进行一次Full GC。如果小于，则查看HandlePromotionFailure设置是否允许担保失败；如果允许，那只会进行Minor GC；如果不允许，则也要改为进行一次Full GC。

    前面提到过，新生代使用复制收集算法，但为了内存利用率，**只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况时（最极端就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，让Survivor无法容纳的对象直接进入老年代。**与生活中的贷款担保类似，老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的空间，一共有多少对象会活下来，在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。

    取平均值进行比较其实仍然是一种动态概率的手段，也就是说如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败。如果出现了HandlePromotionFailure失败，那就只好在失败后重新发起一次Full GC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将HandlePromotionFailure开关打开，避免Full GC过于频繁。

#### Java 8

- Lambda 表达式：Lambda允许把函数作为一个方法的参数
- 方法引用

#### Java EE

- Spring 教程

  > [https://wiki.jikexueyuan.com/project/spring/hello-world-example.html](<https://wiki.jikexueyuan.com/project/spring/hello-world-example.html>)

  - HelloWorld实例

    - 创建源文件

      这里是 **HelloWorld.java** 文件的内容：

      ```java
      package com.tutorialspoint;
      public class HelloWorld {
         private String message;
         public void setMessage(String message){
            this.message  = message;
         }
         public void getMessage(){
            System.out.println("Your Message : " + message);
         }
      }
      ```

      下面是第二个文件 **MainApp.java** 的内容：

      ```java
      package com.tutorialspoint;
      import org.springframework.context.ApplicationContext;
      import org.springframework.context.support.ClassPathXmlApplicationContext;
      public class MainApp {
         public static void main(String[] args) {
            ApplicationContext context = 
                   new ClassPathXmlApplicationContext("Beans.xml");
            HelloWorld obj = (HelloWorld) context.getBean("helloWorld");
            obj.getMessage();
         }
      }
      ```

      关于主要程序有以下两个要点需要注意：

      - 第一步是我们使用框架 API **ClassPathXmlApplicationContext()** 来创建应用程序的上下文。这个 API 加载 beans 的配置文件并最终基于所提供的 API，它处理创建并初始化所有的对象，即在配置文件中提到的 beans。
      - 第二步是使用已创建的上下文的 **getBean()** 方法来获得所需的 bean。这个方法使用 bean 的 ID 返回一个最终可以转换为实际对象的通用对象。一旦有了对象，你就可以使用这个对象调用任何类的方法。

    - 创建 bean 的配置文件

      Beans.xml 用于给不同的 bean 分配唯一的 ID，并且控制不同值的对象的创建，而不会影响 Spring 的任何源文件。例如，使用下面的文件，你可以为 “message” 变量传递任何值，因此你就可以输出信息的不同值，而不会影响的 HelloWorld.java和MainApp.java 文件。让我们来看看它是如何工作的：

      ```xml
      <?xml version="1.0" encoding="UTF-8"?>
      
      <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
      
         <bean id="helloWorld" class="com.tutorialspoint.HelloWorld">
             <property name="message" value="Hello World!"/>
         </bean>
      
      </beans>
      ```

      当 Spring 应用程序被加载到内存中时，框架利用了上面的配置文件来创建所有已经定义的 beans，并且按照 标签的定义为它们分配一个唯一的 ID。你可以使用 标签来传递在创建对象时使用不同变量的值。

  - IoC容器

    Spring 容器是 Spring 框架的核心。容器将创建对象，把它们连接在一起，配置它们，并管理他们的整个生命周期从创建到销毁。Spring 容器使用依赖注入（DI）来管理组成一个应用程序的组件。这些对象被称为 Spring Beans。

    - Sping 的 BeanFactory 容器

      **例子**

      下面是文件 **MainApp.java** 的内容：

      ```java
      package com.tutorialspoint;
      import org.springframework.beans.factory.InitializingBean;
      import org.springframework.beans.factory.xml.XmlBeanFactory;
      import org.springframework.core.io.ClassPathResource;
      public class MainApp {
         public static void main(String[] args) {
            XmlBeanFactory factory = new XmlBeanFactory
                                   (new ClassPathResource("Beans.xml"));
            HelloWorld obj = (HelloWorld) factory.getBean("helloWorld");
            obj.getMessage();
         }
      }
      ```

      在主程序当中，我们需要注意以下两点：

      - 第一步利用框架提供的 **XmlBeanFactory()** API 去生成工厂 bean 以及利用 **ClassPathResource()** API 去加载在路径 CLASSPATH 下可用的 bean 配置文件。**XmlBeanFactory()** API 负责创建并初始化所有的对象，即在配置文件中提到的 bean。
      - 第二步利用第一步生成的 bean 工厂对象的 **getBean()** 方法得到所需要的 bean。 这个方法通过配置文件中的 bean ID 来返回一个真正的对象，该对象最后可以用于实际的对象。一旦得到这个对象，就可以利用这个对象来调用任何方法。

    - Spring ApplicationContext 容器

      最常被使用的 ApplicationContext 接口实现：

      - **FileSystemXmlApplicationContext**：该容器从 XML 文件中加载已被定义的 bean。在这里，你需要提供给构造器 XML 文件的完整路径
      - **ClassPathXmlApplicationContext**：该容器从 XML 文件中加载已被定义的 bean。在这里，你不需要提供 XML 文件的完整路径，只需正确配置 CLASSPATH 环境变量即可，因为，容器会从 CLASSPATH 中搜索 bean 配置文件。
      - **WebXmlApplicationContext**：该容器会在一个 web 应用程序的范围内加载在 XML 文件中已被定义的 bean。

      **例子**

      下面是文件 **MainApp.java** 的内容：

      ```java
      package com.tutorialspoint;
      import org.springframework.context.ApplicationContext;
      import org.springframework.context.support.FileSystemXmlApplicationContext;
      public class MainApp {
         public static void main(String[] args) {
            ApplicationContext context = new FileSystemXmlApplicationContext
                  ("C:/Users/ZARA/workspace/HelloSpring/src/Beans.xml");
            HelloWorld obj = (HelloWorld) context.getBean("helloWorld");
            obj.getMessage();
         }
      }
      ```

      在主程序当中，我们需要注意以下两点：

      - 第一步生成工厂对象。加载完指定路径下 bean 配置文件后，利用框架提供的 **FileSystemXmlApplicationContext** API 去生成工厂 bean。**FileSystemXmlApplicationContext** 负责生成和初始化所有的对象，比如，所有在 XML bean 配置文件中的 bean。
      - 第二步利用第一步生成的上下文中的 **getBean()** 方法得到所需要的 bean。 这个方法通过配置文件中的 bean ID 来返回一个真正的对象。一旦得到这个对象，就可以利用这个对象来调用任何方法。

  - Bean 定义

    被称作 bean 的对象是构成应用程序的支柱也是由 Spring IoC 容器管理的。bean 是一个被实例化，组装，并通过 Spring IoC 容器所管理的对象。这些 bean 是由用容器提供的配置元数据创建的，例如，已经在先前章节看到的，在 XML 的表单中的 定义。

    bean 定义包含称为**配置元数据**的信息，容器也需要知道下述配置元数据：

    - 如何创建一个 bean
    - bean 的生命周期的详细信息
    - bean 的依赖关系

    上述所有的配置元数据转换成一组构成每个 bean 定义的下列属性。

    | 属性                     | 描述                                                         |
    | ------------------------ | ------------------------------------------------------------ |
    | class                    | 这个属性是强制性的，并且指定用来创建 bean 的 bean 类。       |
    | name                     | 这个属性指定唯一的 bean 标识符。在基于 XML 的配置元数据中，你可以使用 ID 和/或 name 属性来指定 bean 标识符。 |
    | scope                    | 这个属性指定由特定的 bean 定义创建的对象的作用域，它将会在 bean 作用域的章节中进行讨论。 |
    | constructor-arg          | 它是用来注入依赖关系的，并会在接下来的章节中进行讨论。       |
    | properties               | 它是用来注入依赖关系的，并会在接下来的章节中进行讨论。       |
    | autowiring mode          | 它是用来注入依赖关系的，并会在接下来的章节中进行讨论。       |
    | lazy-initialization mode | 延迟初始化的 bean 告诉 IoC 容器在它第一次被请求时，而不是在启动时去创建一个 bean 实例。 |
    | initialization 方法      | 在 bean 的所有必需的属性被容器设置之后，调用回调方法。它将会在 bean 的生命周期章节中进行讨论。 |
    | destruction 方法         | 当包含该 bean 的容器被销毁时，使用回调方法。它将会在 bean 的生命周期章节中进行讨论。 |

  - Bean 的作用域

    当在 Spring 中定义一个 时，你必须声明该 bean 的作用域的选项。例如，为了强制 Spring 在每次需要时都产生一个新的 bean 实例，你应该声明 bean 的作用域的属性为 **prototype**。同理，如果你想让 Spring 在每次需要时都返回同一个bean实例，你应该声明 bean 的作用域的属性为 **singleton**。

    Spring 框架支持以下五个作用域，如果你使用 web-aware ApplicationContext 时，其中三个是可用的。

    | 作用域         | 描述                                                         |
    | -------------- | ------------------------------------------------------------ |
    | singleton      | 该作用域将 bean 的定义的限制在每一个 Spring IoC 容器中的一个单一实例(默认)。 |
    | prototype      | 该作用域将单一 bean 的定义限制在任意数量的对象实例。         |
    | request        | 该作用域将 bean 的定义限制为 HTTP 请求。只在 web-aware Spring ApplicationContext 的上下文中有效。 |
    | session        | 该作用域将 bean 的定义限制为 HTTP 会话。 只在web-aware Spring ApplicationContext的上下文中有效。 |
    | global-session | 该作用域将 bean 的定义限制为全局 HTTP 会话。只在 web-aware Spring ApplicationContext 的上下文中有效。 |

    **singleton 作用域：**

    如果作用域设置为 singleton，那么 Spring IoC 容器刚好创建一个由该 bean 定义的对象的实例。该单一实例将存储在这种单例 bean 的高速缓存中，以及针对该 bean 的所有后续的请求和引用都返回缓存对象。

    默认作用域是始终是 singleton，但是当仅仅需要 bean 的一个实例时，你可以在 bean 的配置文件中设置作用域的属性为 singleton，如下所示：

    ```xml
    <!-- A bean definition with singleton scope -->
    <bean id="..." class="..." scope="singleton">
        <!-- collaborators and configuration for this bean go here -->
    </bean>
    ```

    **例子**

    下面是 MainApp.java 文件的内容：

    ```java
    package com.tutorialspoint;
    import org.springframework.context.ApplicationContext;
    import org.springframework.context.support.ClassPathXmlApplicationContext;
    public class MainApp {
       public static void main(String[] args) {
          ApplicationContext context = new ClassPathXmlApplicationContext("Beans.xml");
          HelloWorld objA = (HelloWorld) context.getBean("helloWorld");
          objA.setMessage("I'm object A");
          objA.getMessage();
          HelloWorld objB = (HelloWorld) context.getBean("helloWorld");
          objB.getMessage();
       }
    }
    ```

    下面是 singleton 作用域必需的配置文件 **Beans.xml**：

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    
    <beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
    
       <bean id="helloWorld" class="com.tutorialspoint.HelloWorld" 
          scope="singleton">
       </bean>
    
    </beans>
    ```

    一旦你创建源代码和 bean 配置文件完成后，我们就可以运行该应用程序。如果你的应用程序一切都正常，将输出以下信息：

    ```
    Your Message : I'm object A
    Your Message : I'm object A
    ```

    **prototype 作用域**

    如果作用域设置为 prototype，那么每次特定的 bean 发出请求时 Spring IoC 容器就创建对象的新的 Bean 实例。一般说来，满状态的 bean 使用 prototype 作用域和没有状态的 bean 使用 singleton 作用域。

    为了定义 prototype 作用域，你可以在 bean 的配置文件中设置作用域的属性为 prototype，如下所示：

    ```xml
    <!-- A bean definition with singleton scope -->
    <bean id="..." class="..." scope="prototype">
       <!-- collaborators and configuration for this bean go here -->
    </bean>
    ```

    **例子**

    面是 **MainApp.java** 文件的内容：

    ```java
    package com.tutorialspoint;
    import org.springframework.context.ApplicationContext;
    import org.springframework.context.support.ClassPathXmlApplicationContext;
    public class MainApp {
       public static void main(String[] args) {
          ApplicationContext context = new ClassPathXmlApplicationContext("Beans.xml");
          HelloWorld objA = (HelloWorld) context.getBean("helloWorld");
          objA.setMessage("I'm object A");
          objA.getMessage();
          HelloWorld objB = (HelloWorld) context.getBean("helloWorld");
          objB.getMessage();
       }
    }
    ```

    下面是 **prototype** 作用域必需的配置文件 Beans.xml：

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    
    <beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
    
       <bean id="helloWorld" class="com.tutorialspoint.HelloWorld" 
          scope="prototype">
       </bean>
    
    </beans>
    ```

    一旦你创建源代码和 Bean 配置文件完成后，我们就可以运行该应用程序。如果你的应用程序一切都正常，将输出以下信息：

    ```
    Your Message : I'm object A
    Your Message : null
    ```

  - Bean 的生命周期

    理解 Spring bean 的生命周期很容易。当一个 bean 被实例化时，它可能需要执行一些初始化使它转换成可用状态。同样，当 bean 不再需要，并且从容器中移除时，可能需要做一些清除工作。

    为了定义安装和拆卸一个 bean，我们只要声明带有 **init-method** 和/或 **destroy-method** 参数的 。init-method 属性指定一个方法，在实例化 bean 时，立即调用该方法。同样，destroy-method 指定一个方法，只有从容器中移除 bean 之后，才能调用该方法。

    **初始化回调**

    *org.springframework.beans.factory.InitializingBean* 接口指定一个单一的方法：

    ```java
    void afterPropertiesSet() throws Exception;
    ```

    因此，你可以简单地实现上述接口和初始化工作可以在 afterPropertiesSet() 方法中执行，如下所示：

    ```java
    public class ExampleBean implements InitializingBean {
       public void afterPropertiesSet() {
          // do some initialization work
       }
    }
    ```

    在基于 XML 的配置元数据的情况下，你可以使用 **init-method** 属性来指定带有 void 无参数方法的名称。例如：

    ```xml
    <bean id="exampleBean" 
             class="examples.ExampleBean" init-method="init"/>
    ```

    下面是类的定义：

    ```java
    public class ExampleBean {
       public void init() {
          // do some initialization work
       }
    }
    ```

    **销毁回调**

    *org.springframework.beans.factory.DisposableBean* 接口指定一个单一的方法：

    ```java
    void destroy() throws Exception;
    ```

    因此，你可以简单地实现上述接口并且结束工作可以在 destroy() 方法中执行，如下所示：

    ```java
    public class ExampleBean implements DisposableBean {
       public void destroy() {
          // do some destruction work
       }
    }
    ```

    在基于 XML 的配置元数据的情况下，你可以使用 **destroy-method** 属性来指定带有 void 无参数方法的名称。例如：

    ```xml
    <bean id="exampleBean"
             class="examples.ExampleBean" destroy-method="destroy"/>
    ```

    下面是类的定义：

    ```java
    public class ExampleBean {
       public void destroy() {
          // do some destruction work
       }
    }
    ```

    建议你不要使用 InitializingBean 或者 DisposableBean 的回调方法，因为 XML 配置在命名方法上提供了极大的灵活性。

    **例子**

    这里是 **HelloWorld.java** 的文件的内容：

    ```java
    package com.tutorialspoint;
    
    public class HelloWorld {
       private String message;
    
       public void setMessage(String message){
          this.message  = message;
       }
       public void getMessage(){
          System.out.println("Your Message : " + message);
       }
       public void init(){
          System.out.println("Bean is going through init.");
       }
       public void destroy(){
          System.out.println("Bean will destroy now.");
       }
    }
    ```

    下面是 **MainApp.java** 文件的内容。在这里，你需要注册一个在 AbstractApplicationContext 类中声明的关闭 hook 的 **registerShutdownHook()** 方法。它将确保正常关闭，并且调用相关的 destroy 方法。

    ```java
    package com.tutorialspoint;
    import org.springframework.context.support.AbstractApplicationContext;
    import org.springframework.context.support.ClassPathXmlApplicationContext;
    public class MainApp {
       public static void main(String[] args) {
          AbstractApplicationContext context = new ClassPathXmlApplicationContext("Beans.xml");
          HelloWorld obj = (HelloWorld) context.getBean("helloWorld");
          obj.getMessage();
          context.registerShutdownHook();
       }
    }
    ```

    下面是 init 和 destroy 方法必需的配置文件 **Beans.xml** 文件：

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    
    <beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
    
       <bean id="helloWorld" 
           class="com.tutorialspoint.HelloWorld"
           init-method="init" destroy-method="destroy">
           <property name="message" value="Hello World!"/>
       </bean>
    
    </beans>
    ```

    一旦你创建源代码和 bean 配置文件完成后，我们就可以运行该应用程序。如果你的应用程序一切都正常，将输出以下信息：

    ```
    Bean is going through init.
    Your Message : Hello World!
    Bean will destroy now.
    ```

    **默认的初始化和销毁方法**

    如果你有太多具有相同名称的初始化或者销毁方法的 Bean，那么你不需要在每一个 bean 上声明**初始化方法**和**销毁方法**。框架使用 元素中的 **default-init-method** 和 **default-destroy-method** 属性提供了灵活地配置这种情况，如下所示：

    ```xml
    <beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"
        default-init-method="init" 
        default-destroy-method="destroy">
    
       <bean id="..." class="...">
           <!-- collaborators and configuration for this bean go here -->
       </bean>
    
    </beans>
    ```

  - Bean 后置处理器

    **BeanPostProcessor** 接口定义回调方法，你可以实现该方法来提供自己的实例化逻辑，依赖解析逻辑等。你也可以在 Spring 容器通过插入一个或多个 BeanPostProcessor 的实现来完成实例化，配置和初始化一个bean之后实现一些自定义逻辑回调方法。

    你可以配置多个 BeanPostProcessor接口，通过设置 BeanPostProcessor 实现的 **Ordered** 接口提供的 **order** 属性来控制这些 BeanPostProcessor 接口的执行顺序。

    BeanPostProcessor 可以对 bean（或对象）实例进行操作，这意味着 Spring IoC 容器实例化一个 bean 实例，然后 BeanPostProcessor 接口进行它们的工作。

    **ApplicationContext** 会自动检测由 **BeanPostProcessor** 接口的实现定义的 bean，注册这些 bean 为后置处理器，然后通过在容器中创建 bean，在适当的时候调用它。

    这里是 **HelloWorld.java** 文件的内容：

    ```java
    package com.tutorialspoint;
    public class HelloWorld {
       private String message;
       public void setMessage(String message){
          this.message  = message;
       }
       public void getMessage(){
          System.out.println("Your Message : " + message);
       }
       public void init(){
          System.out.println("Bean is going through init.");
       }
       public void destroy(){
          System.out.println("Bean will destroy now.");
       }
    }
    ```

    这是实现 BeanPostProcessor 的非常简单的例子，它在任何 bean 的初始化的之前和之后输入该 bean 的名称。你可以在初始化 bean 的之前和之后实现更复杂的逻辑，因为你有两个访问内置 bean 对象的后置处理程序的方法。

    这里是 **InitHelloWorld.java** 文件的内容：

    ```java
    package com.tutorialspoint;
    import org.springframework.beans.factory.config.BeanPostProcessor;
    import org.springframework.beans.BeansException;
    public class InitHelloWorld implements BeanPostProcessor {
       public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
          System.out.println("BeforeInitialization : " + beanName);
          return bean;  // you can return any other object as well
       }
       public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
          System.out.println("AfterInitialization : " + beanName);
          return bean;  // you can return any other object as well
       }
    }
    ```

    下面是 **MainApp.java** 文件的内容。在这里，你需要注册一个在 AbstractApplicationContext 类中声明的关闭 hook 的 **registerShutdownHook()** 方法。它将确保正常关闭，并且调用相关的 destroy 方法。

    ```java
    package com.tutorialspoint;
    import org.springframework.context.support.AbstractApplicationContext;
    import org.springframework.context.support.ClassPathXmlApplicationContext;
    public class MainApp {
       public static void main(String[] args) {
          AbstractApplicationContext context = new ClassPathXmlApplicationContext("Beans.xml");
          HelloWorld obj = (HelloWorld) context.getBean("helloWorld");
          obj.getMessage();
          context.registerShutdownHook();
       }
    }
    ```

    下面是 init 和 destroy 方法需要的配置文件 **Beans.xml** 文件：

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    
    <beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
    
       <bean id="helloWorld" class="com.tutorialspoint.HelloWorld"
           init-method="init" destroy-method="destroy">
           <property name="message" value="Hello World!"/>
       </bean>
    
       <bean class="com.tutorialspoint.InitHelloWorld" />
    
    </beans>
    ```

    一旦你创建源代码和 bean 配置文件完成后，我们就可以运行该应用程序。如果你的应用程序一切都正常，将输出以下信息：

    ```
    BeforeInitialization : helloWorld
    Bean is going through init.
    AfterInitialization : helloWorld
    Your Message : Hello World!
    Bean will destroy now.
    ```

  - Bean 定义继承

    bean 定义可以包含很多的配置信息，包括构造函数的参数，属性值，容器的具体信息例如初始化方法，静态工厂方法名，等等。

    子 bean 的定义继承父定义的配置数据。子定义可以根据需要重写一些值，或者添加其他值。

    Spring Bean 定义的继承与 Java 类的继承无关，但是继承的概念是一样的。你可以定义一个父 bean 的定义作为模板和其他子 bean 就可以从父 bean 中继承所需的配置。

    当你使用基于 XML 的配置元数据时，通过使用父属性，指定父 bean 作为该属性的值来表明子 bean 的定义。

    **例子**

    下面是配置文件 **Beans.xml**，在该配置文件中我们定义有两个属性 *message1* 和 *message2* 的 “helloWorld” bean。然后，使用 **parent** 属性把 “helloIndia” bean 定义为 “helloWorld” bean 的孩子。这个子 bean 继承 *message2* 的属性，重写 *message1* 的属性，并且引入一个属性 *message3*。

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    
    <beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
    
       <bean id="helloWorld" class="com.tutorialspoint.HelloWorld">
          <property name="message1" value="Hello World!"/>
          <property name="message2" value="Hello Second World!"/>
       </bean>
    
       <bean id="helloIndia" class="com.tutorialspoint.HelloIndia" parent="helloWorld">
          <property name="message1" value="Hello India!"/>
          <property name="message3" value="Namaste India!"/>
       </bean>
    
    </beans>
    ```

    这里是 **HelloWorld.java** 文件的内容：

    ```java
    package com.tutorialspoint;
    public class HelloWorld {
       private String message1;
       private String message2;
       public void setMessage1(String message){
          this.message1  = message;
       }
       public void setMessage2(String message){
          this.message2  = message;
       }
       public void getMessage1(){
          System.out.println("World Message1 : " + message1);
       }
       public void getMessage2(){
          System.out.println("World Message2 : " + message2);
       }
    }
    ```

    这里是 **HelloIndia.java** 文件的内容：

    ```java
    package com.tutorialspoint;
    
    public class HelloIndia {
       private String message1;
       private String message2;
       private String message3;
    
       public void setMessage1(String message){
          this.message1  = message;
       }
    
       public void setMessage2(String message){
          this.message2  = message;
       }
    
       public void setMessage3(String message){
          this.message3  = message;
       }
    
       public void getMessage1(){
          System.out.println("India Message1 : " + message1);
       }
    
       public void getMessage2(){
          System.out.println("India Message2 : " + message2);
       }
    
       public void getMessage3(){
          System.out.println("India Message3 : " + message3);
       }
    }
    ```

    下面是 **MainApp.java** 文件的内容：

    ```java
    package com.tutorialspoint;
    
    import org.springframework.context.ApplicationContext;
    import org.springframework.context.support.ClassPathXmlApplicationContext;
    
    public class MainApp {
       public static void main(String[] args) {
          ApplicationContext context = new ClassPathXmlApplicationContext("Beans.xml");
    
          HelloWorld objA = (HelloWorld) context.getBean("helloWorld");
    
          objA.getMessage1();
          objA.getMessage2();
    
          HelloIndia objB = (HelloIndia) context.getBean("helloIndia");
          objB.getMessage1();
          objB.getMessage2();
          objB.getMessage3();
       }
    }
    ```

    一旦你创建源代码和 bean 配置文件完成后，我们就可以运行该应用程序。如果你的应用程序一切都正常，将输出以下信息：

    ```
    World Message1 : Hello World!
    World Message2 : Hello Second World!
    India Message1 : Hello India!
    India Message2 : Hello Second World!
    India Message3 : Namaste India!
    ```

    在这里你可以观察到，我们创建 “helloIndia” bean 的同时并没有传递 message2，但是由于 Bean 定义的继承，所以它传递了 message2。

    **Bean 定义模板**

    你可以创建一个 Bean 定义模板，不需要花太多功夫它就可以被其他子 bean 定义使用。在定义一个 Bean 定义模板时，你不应该指定**类**的属性，而应该指定带 **true** 值的**抽象**属性，如下所示：

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    
    <beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
    
       <bean id="beanTeamplate" abstract="true">
          <property name="message1" value="Hello World!"/>
          <property name="message2" value="Hello Second World!"/>
          <property name="message3" value="Namaste India!"/>
       </bean>
    
       <bean id="helloIndia" class="com.tutorialspoint.HelloIndia" parent="beanTeamplate">
          <property name="message1" value="Hello India!"/>
          <property name="message3" value="Namaste India!"/>
       </bean>
    
    </beans>
    ```

    父 bean 自身不能被实例化，因为它是不完整的，而且它也被明确地标记为抽象的。当一个定义是抽象的，它仅仅作为一个纯粹的模板 bean 定义来使用的，充当子定义的父定义使用。

  - 依赖注入

    每个基于应用程序的 java 都有几个对象，这些对象一起工作来呈现出终端用户所看到的工作的应用程序。当编写一个复杂的 Java 应用程序时，应用程序类应该尽可能独立于其他 Java 类来增加这些类重用的可能性，并且在做单元测试时，测试独立于其他类的独立性。依赖注入（或有时称为布线）有助于把这些类粘合在一起，同时保持他们独立。

    假设你有一个包含文本编辑器组件的应用程序，并且你想要提供拼写检查。标准代码看起来是这样的：

    ```java
    public class TextEditor {
       private SpellChecker spellChecker;  
       public TextEditor() {
          spellChecker = new SpellChecker();
       }
    }
    ```

    在这里我们所做的就是创建一个 TextEditor 和 SpellChecker 之间的依赖关系。在控制反转的场景中，我们反而会做这样的事情：

    ```java
    public class TextEditor {
       private SpellChecker spellChecker;
       public TextEditor(SpellChecker spellChecker) {
          this.spellChecker = spellChecker;
       }
    }
    ```

    在这里，TextEditor 不应该担心 SpellChecker 的实现。SpellChecker 将会独立实现，并且在 TextEditor 实例化的时候将提供给 TextEditor，整个过程是由 Spring 框架的控制。

    在这里，我们已经从 TextEditor 中删除了全面控制，并且把它保存到其他地方（即 XML 配置文件），且依赖关系（即 SpellChecker 类）通过**类构造函数**被注入到 TextEditor 类中。因此，控制流通过依赖注入（DI）已经“反转”，因为你已经有效地委托依赖关系到一些外部系统。

    依赖注入的第二种方法是通过 TextEditor 类的 **Setter 方法**，我们将创建 SpellChecker 实例，该实例将被用于调用 setter 方法来初始化 TextEditor 的属性。

    - Spring 基于构造函数的依赖注入

      当容器调用带有一组参数的类构造函数时，基于构造函数的 DI 就完成了，其中每个参数代表一个对其他类的依赖。

      这是 **TextEditor.java** 文件的内容：

      ```java
      package com.tutorialspoint;
      public class TextEditor {
         private SpellChecker spellChecker;
         public TextEditor(SpellChecker spellChecker) {
            System.out.println("Inside TextEditor constructor." );
            this.spellChecker = spellChecker;
         }
         public void spellCheck() {
            spellChecker.checkSpelling();
         }
      }
      ```

      下面是另一个依赖类文件 **SpellChecker.java** 的内容：

      ```java
      package com.tutorialspoint;
      public class SpellChecker {
         public SpellChecker(){
            System.out.println("Inside SpellChecker constructor." );
         }
         public void checkSpelling() {
            System.out.println("Inside checkSpelling." );
         } 
      }
      ```

      以下是 **MainApp.java** 文件的内容：

      ```java
      package com.tutorialspoint;
      import org.springframework.context.ApplicationContext;
      import org.springframework.context.support.ClassPathXmlApplicationContext;
      public class MainApp {
         public static void main(String[] args) {
            ApplicationContext context = 
                   new ClassPathXmlApplicationContext("Beans.xml");
            TextEditor te = (TextEditor) context.getBean("textEditor");
            te.spellCheck();
         }
      }
      ```

      下面是配置文件 **Beans.xml** 的内容，它有基于构造函数注入的配置：

      ```xml
      <?xml version="1.0" encoding="UTF-8"?>
      
      <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
      
         <!-- Definition for textEditor bean -->
         <bean id="textEditor" class="com.tutorialspoint.TextEditor">
            <constructor-arg ref="spellChecker"/>
         </bean>
      
         <!-- Definition for spellChecker bean -->
         <bean id="spellChecker" class="com.tutorialspoint.SpellChecker">
         </bean>
      
      </beans>
      ```

      当你完成了创建源和 bean 配置文件后，让我们开始运行应用程序。如果你的应用程序运行顺利的话，那么将会输出下述所示消息：

      ```
      Inside SpellChecker constructor.
      Inside TextEditor constructor.
      Inside checkSpelling.
      ```

      **构造函数参数解析:**

      如果存在不止一个参数时，当把参数传递给构造函数时，可能会存在歧义。要解决这个问题，那么构造函数的参数在 bean 定义中的顺序就是把这些参数提供给适当的构造函数的顺序就可以了。考虑下面的类:

      ```java
      package x.y;
      public class Foo {
         public Foo(Bar bar, Baz baz) {
            // ...
         }
      }
      ```

      下述配置文件工作顺利：

      ```xml
      <beans>
         <bean id="foo" class="x.y.Foo">
            <constructor-arg ref="bar"/>
            <constructor-arg ref="baz"/>
         </bean>
      
         <bean id="bar" class="x.y.Bar"/>
         <bean id="baz" class="x.y.Baz"/>
      </beans>
      ```

      让我们再检查一下我们传递给构造函数不同类型的位置。考虑下面的类：

      ```java
      package x.y;
      public class Foo {
         public Foo(int year, String name) {
            // ...
         }
      }
      ```

      如果你使用 type 属性显式的指定了构造函数参数的类型，容器也可以使用与简单类型匹配的类型。例如：

      ```xml
      <beans>
      
         <bean id="exampleBean" class="examples.ExampleBean">
            <constructor-arg type="int" value="2001"/>
            <constructor-arg type="java.lang.String" value="Zara"/>
         </bean>
      
      </beans>
      ```

      最后并且也是最好的传递构造函数参数的方式，使用 index 属性来显式的指定构造函数参数的索引。下面是基于索引为 0 的例子，如下所示：

      ```xml
      <beans>
      
         <bean id="exampleBean" class="examples.ExampleBean">
            <constructor-arg index="0" value="2001"/>
            <constructor-arg index="1" value="Zara"/>
         </bean>
      
      </beans>
      ```

      最后，如果你想要向一个对象传递一个引用，你需要使用 标签的 **ref** 属性，如果你想要直接传递值，那么你应该使用如上所示的 **value** 属性。

    - Spring 基于设值函数的依赖注入

      当容器调用一个无参的构造函数或一个无参的静态 factory 方法来初始化你的 bean 后，通过容器在你的 bean 上调用设值函数，基于设值函数的 DI 就完成了。

      下面是 **TextEditor.java** 文件的内容：

      ```java
      package com.tutorialspoint;
      public class TextEditor {
         private SpellChecker spellChecker;
         // a setter method to inject the dependency.
         public void setSpellChecker(SpellChecker spellChecker) {
            System.out.println("Inside setSpellChecker." );
            this.spellChecker = spellChecker;
         }
         // a getter method to return spellChecker
         public SpellChecker getSpellChecker() {
            return spellChecker;
         }
         public void spellCheck() {
            spellChecker.checkSpelling();
         }
      }
      ```

      在这里，你需要检查设值函数方法的名称转换。要设置一个变量 **spellChecker**，我们使用 **setSpellChecker()** 方法，该方法与 Java POJO 类非常相似。让我们创建另一个依赖类文件 **SpellChecker.java** 的内容：

      ```java
      package com.tutorialspoint;
      public class SpellChecker {
         public SpellChecker(){
            System.out.println("Inside SpellChecker constructor." );
         }
         public void checkSpelling() {
            System.out.println("Inside checkSpelling." );
         }  
      }
      ```

      以下是 **MainApp.java** 文件的内容：

      ```java
      package com.tutorialspoint;
      import org.springframework.context.ApplicationContext;
      import org.springframework.context.support.ClassPathXmlApplicationContext;
      public class MainApp {
         public static void main(String[] args) {
            ApplicationContext context = 
                   new ClassPathXmlApplicationContext("Beans.xml");
            TextEditor te = (TextEditor) context.getBean("textEditor");
            te.spellCheck();
         }
      }
      ```

      下面是配置文件 **Beans.xml** 的内容，该文件有基于设值函数注入的配置：

      ```xml
      <?xml version="1.0" encoding="UTF-8"?>
      
      <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
      
         <!-- Definition for textEditor bean -->
         <bean id="textEditor" class="com.tutorialspoint.TextEditor">
            <property name="spellChecker" ref="spellChecker"/>
         </bean>
      
         <!-- Definition for spellChecker bean -->
         <bean id="spellChecker" class="com.tutorialspoint.SpellChecker">
         </bean>
      
      </beans>
      ```

      你应该注意定义在基于构造函数注入和基于设值函数注入中的 Beans.xml 文件的区别。唯一的区别就是在基于构造函数注入中，我们使用的是〈bean〉标签中的〈constructor-arg〉元素，而在基于设值函数的注入中，我们使用的是〈bean〉标签中的〈property〉元素。

      第二个你需要注意的点是，如果你要把一个引用传递给一个对象，那么你需要使用 标签的 **ref** 属性，而如果你要直接传递一个值，那么你应该使用 **value** 属性。

      当你完成了创建源和 bean 配置文件后，让我们开始运行应用程序。如果你的应用程序运行顺利的话，那么将会输出下述所示消息：

      ```
      Inside SpellChecker constructor.
      Inside setSpellChecker.
      Inside checkSpelling.
      ```

      **使用 p-namespace 实现 XML 配置：**

      如果你有许多的设值函数方法，那么在 XML 配置文件中使用 **p-namespace** 是非常方便的。让我们查看一下区别：

      以带有 标签的标准 XML 配置文件为例：

      ```xml
      <?xml version="1.0" encoding="UTF-8"?>
      
      <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
      
         <bean id="john-classic" class="com.example.Person">
            <property name="name" value="John Doe"/>
            <property name="spouse" ref="jane"/>
         </bean>
      
         <bean name="jane" class="com.example.Person">
            <property name="name" value="John Doe"/>
         </bean>
      
      </beans>
      ```

      上述 XML 配置文件可以使用 **p-namespace** 以一种更简洁的方式重写，如下所示：

      ```xml
      <?xml version="1.0" encoding="UTF-8"?>
      
      <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:p="http://www.springframework.org/schema/p"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
      
         <bean id="john-classic" class="com.example.Person"
            p:name="John Doe"
            p:spouse-ref="jane"/>
         </bean>
      
         <bean name="jane" class="com.example.Person"
            p:name="John Doe"/>
         </bean>
      
      </beans>
      ```

      在这里，你不应该区别指定原始值和带有 p-namespace 的对象引用。**-ref** 部分表明这不是一个直接的值，而是对另一个 bean 的引用。

  - 注入内部 Beans

    正如你所知道的 Java 内部类是在其他类的范围内被定义的，同理，**inner beans** 是在其他 bean 的范围内定义的 bean。因此在元素内的元素被称为内部bean，如下所示。

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    
    <beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
    
       <bean id="outerBean" class="...">
          <property name="target">
             <bean id="innerBean" class="..."/>
          </property>
       </bean>
    
    </beans>
    ```

    **例子**

    这里是 **TextEditor.java** 文件的内容：

    ```java
    package com.tutorialspoint;
    public class TextEditor {
       private SpellChecker spellChecker;
       // a setter method to inject the dependency.
       public void setSpellChecker(SpellChecker spellChecker) {
          System.out.println("Inside setSpellChecker." );
          this.spellChecker = spellChecker;
       }  
       // a getter method to return spellChecker
       public SpellChecker getSpellChecker() {
          return spellChecker;
       }
       public void spellCheck() {
          spellChecker.checkSpelling();
       }
    }
    ```

    下面是另一个依赖的类文件 **SpellChecker.java** 内容：

    ```java
    package com.tutorialspoint;
    public class SpellChecker {
       public SpellChecker(){
          System.out.println("Inside SpellChecker constructor." );
       }
       public void checkSpelling(){
          System.out.println("Inside checkSpelling." );
       }   
    }
    ```

    下面是 **MainApp.java** 文件的内容：

    ```java
    package com.tutorialspoint;
    import org.springframework.context.ApplicationContext;
    import org.springframework.context.support.ClassPathXmlApplicationContext;
    public class MainApp {
       public static void main(String[] args) {
          ApplicationContext context = new ClassPathXmlApplicationContext("Beans.xml");
          TextEditor te = (TextEditor) context.getBean("textEditor");
          te.spellCheck();
       }
    }
    ```

    下面是使用**内部 bean** 为基于 setter 注入进行配置的配置文件 **Beans.xml** 文件：

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    
    <beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
    
       <!-- Definition for textEditor bean using inner bean -->
       <bean id="textEditor" class="com.tutorialspoint.TextEditor">
          <property name="spellChecker">
             <bean id="spellChecker" class="com.tutorialspoint.SpellChecker"/>
           </property>
       </bean>
    
    </beans>
    ```

    一旦你创建源代码和 bean 配置文件完成后，我们就可以运行该应用程序。如果你的应用程序一切都正常，将输出以下信息：

    ```
    Inside SpellChecker constructor.
    Inside setSpellChecker.
    Inside checkSpelling.
    ```

  - 注入集合

    你已经看到了如何使用 **value** 属性来配置基本数据类型和在你的 bean 配置文件中使用 标签的 **ref** 属性来配置对象引用。这两种情况下处理奇异值传递给一个 bean。

    现在如果你想传递多个值，如 Java Collection 类型 List、Set、Map 和 Properties，应该怎么做呢。为了处理这种情况，Spring 提供了四种类型的集合的配置元素，如下所示：

    | 元素    | 描述                                                        |
    | ------- | ----------------------------------------------------------- |
    | <list>  | 它有助于连线，如注入一列值，允许重复。                      |
    | <set>   | 它有助于连线一组值，但不能重复。                            |
    | <map>   | 它可以用来注入名称-值对的集合，其中名称和值可以是任何类型。 |
    | <props> | 它可以用来注入名称-值对的集合，其中名称和值都是字符串类型。 |

    你可以使用 或 来连接任何 java.util.Collection 的实现或数组。

    你会遇到两种情况（a）传递集合中直接的值（b）传递一个 bean 的引用作为集合的元素。

    **例子**

    这里是 **JavaCollection.java** 文件的内容：

    ```java
    package com.tutorialspoint;
    import java.util.*;
    public class JavaCollection {
       List addressList;
       Set  addressSet;
       Map  addressMap;
       Properties addressProp;
       // a setter method to set List
       public void setAddressList(List addressList) {
          this.addressList = addressList;
       }
       // prints and returns all the elements of the list.
       public List getAddressList() {
          System.out.println("List Elements :"  + addressList);
          return addressList;
       }
       // a setter method to set Set
       public void setAddressSet(Set addressSet) {
          this.addressSet = addressSet;
       }
       // prints and returns all the elements of the Set.
       public Set getAddressSet() {
          System.out.println("Set Elements :"  + addressSet);
          return addressSet;
       }
       // a setter method to set Map
       public void setAddressMap(Map addressMap) {
          this.addressMap = addressMap;
       }  
       // prints and returns all the elements of the Map.
       public Map getAddressMap() {
          System.out.println("Map Elements :"  + addressMap);
          return addressMap;
       }
       // a setter method to set Property
       public void setAddressProp(Properties addressProp) {
          this.addressProp = addressProp;
       } 
       // prints and returns all the elements of the Property.
       public Properties getAddressProp() {
          System.out.println("Property Elements :"  + addressProp);
          return addressProp;
       }
    }
    ```

    下面是 **MainApp.java** 文件的内容：

    ```java
    package com.tutorialspoint;
    import org.springframework.context.ApplicationContext;
    import org.springframework.context.support.ClassPathXmlApplicationContext;
    public class MainApp {
       public static void main(String[] args) {
          ApplicationContext context = 
                 new ClassPathXmlApplicationContext("Beans.xml");
          JavaCollection jc=(JavaCollection)context.getBean("javaCollection");
          jc.getAddressList();
          jc.getAddressSet();
          jc.getAddressMap();
          jc.getAddressProp();
       }
    }
    ```

    下面是配置所有类型的集合的配置文件 **Beans.xml** 文件：

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    
    <beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
    
       <!-- Definition for javaCollection -->
       <bean id="javaCollection" class="com.tutorialspoint.JavaCollection">
    
          <!-- results in a setAddressList(java.util.List) call -->
          <property name="addressList">
             <list>
                <value>INDIA</value>
                <value>Pakistan</value>
                <value>USA</value>
                <value>USA</value>
             </list>
          </property>
    
          <!-- results in a setAddressSet(java.util.Set) call -->
          <property name="addressSet">
             <set>
                <value>INDIA</value>
                <value>Pakistan</value>
                <value>USA</value>
                <value>USA</value>
            </set>
          </property>
    
          <!-- results in a setAddressMap(java.util.Map) call -->
          <property name="addressMap">
             <map>
                <entry key="1" value="INDIA"/>
                <entry key="2" value="Pakistan"/>
                <entry key="3" value="USA"/>
                <entry key="4" value="USA"/>
             </map>
          </property>
    
          <!-- results in a setAddressProp(java.util.Properties) call -->
          <property name="addressProp">
             <props>
                <prop key="one">INDIA</prop>
                <prop key="two">Pakistan</prop>
                <prop key="three">USA</prop>
                <prop key="four">USA</prop>
             </props>
          </property>
    
       </bean>
    
    </beans>
    ```

    一旦你创建源代码和 bean 配置文件完成后，我们就可以运行该应用程序。你应该注意这里不需要配置文件。如果你的应用程序一切都正常，将输出以下信息：

    ```
    List Elements :[INDIA, Pakistan, USA, USA]
    Set Elements :[INDIA, Pakistan, USA]
    Map Elements :{1=INDIA, 2=Pakistan, 3=USA, 4=USA}
    Property Elements :{two=Pakistan, one=INDIA, three=USA, four=USA}
    ```

    **注入 Bean 引用**

    下面的 Bean 定义将帮助你理解如何注入 bean 的引用作为集合的元素。甚至你可以将引用和值混合在一起，如下所示：

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    
    <beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
    
       <!-- Bean Definition to handle references and values -->
       <bean id="..." class="...">
    
          <!-- Passing bean reference  for java.util.List -->
          <property name="addressList">
             <list>
                <ref bean="address1"/>
                <ref bean="address2"/>
                <value>Pakistan</value>
             </list>
          </property>
    
          <!-- Passing bean reference  for java.util.Set -->
          <property name="addressSet">
             <set>
                <ref bean="address1"/>
                <ref bean="address2"/>
                <value>Pakistan</value>
             </set>
          </property>
    
          <!-- Passing bean reference  for java.util.Map -->
          <property name="addressMap">
             <map>
                <entry key="one" value="INDIA"/>
                <entry key ="two" value-ref="address1"/>
                <entry key ="three" value-ref="address2"/>
             </map>
          </property>
    
       </bean>
    
    </beans>
    ```

    为了使用上面的 bean 定义，你需要定义 setter 方法，它们应该也能够是用这种方式来处理引用。

    **注入 null 和空字符串的值**

    如果你需要传递一个空字符串作为值，那么你可以传递它，如下所示：

    ```xml
    <bean id="..." class="exampleBean">
       <property name="email" value=""/>
    </bean>
    ```

    前面的例子相当于 Java 代码：exampleBean.setEmail("")。

    如果你需要传递一个 NULL 值，那么你可以传递它，如下所示：

    ```xml
    <bean id="..." class="exampleBean">
       <property name="email"><null/></property>
    </bean>
    ```

    前面的例子相当于 Java 代码：exampleBean.setEmail(null)。

  - Beans 自动装配

    Spring 容器可以在不使用 <constructor-arg> 和 <property> 元素的情况下**自动装配**相互协作的 bean 之间的关系，这有助于减少编写一个大的基于 Spring 的应用程序的 XML 配置的数量。

    **自动装配模式**

    下列自动装配模式，它们可用于指示 Spring 容器为来使用自动装配进行依赖注入。你可以使用 元素的 **autowire** 属性为一个 bean 定义指定自动装配模式。

    | 模式                                                         | 描述                                                         |
    | ------------------------------------------------------------ | ------------------------------------------------------------ |
    | no                                                           | 这是默认的设置，它意味着没有自动装配，你应该使用显式的bean引用来连线。你不用为了连线做特殊的事。在依赖注入章节你已经看到这个了。 |
    | [byName](https://wiki.jikexueyuan.com/project/spring/beans-auto-wiring/spring-autowiring-byname.html) | 由属性名自动装配。Spring 容器看到在 XML 配置文件中 bean 的*自动装配*的属性设置为 *byName*。然后尝试匹配，并且将它的属性与在配置文件中被定义为相同名称的 beans 的属性进行连接。 |
    | [byType](https://wiki.jikexueyuan.com/project/spring/beans-auto-wiring/spring-autowiring-byType.html) | 由属性数据类型自动装配。Spring 容器看到在 XML 配置文件中 bean 的*自动装配*的属性设置为 *byType*。然后如果它的**类型**匹配配置文件中的一个确切的 bean 名称，它将尝试匹配和连接属性的类型。如果存在不止一个这样的 bean，则一个致命的异常将会被抛出。 |
    | [constructor](https://wiki.jikexueyuan.com/project/spring/beans-auto-wiring/spring-autowiring-by-Constructor.html) | 类似于 byType，但该类型适用于构造函数参数类型。如果在容器中没有一个构造函数参数类型的 bean，则一个致命错误将会发生。 |
    | autodetect                                                   | Spring首先尝试通过 *constructor* 使用自动装配来连接，如果它不执行，Spring 尝试通过 *byType* 来自动装配。 |

    可以使用 **byType** 或者 **constructor** 自动装配模式来连接数组和其他类型的集合。

    **自动装配的局限性**

    当自动装配始终在同一个项目中使用时，它的效果最好。如果通常不使用自动装配，它可能会使开发人员混淆的使用它来连接只有一个或两个 bean 定义。不过，自动装配可以显著减少需要指定的属性或构造器参数，但你应该在使用它们之前考虑到自动装配的局限性和缺点。

    | 限制         | 描述                                                         |
    | ------------ | ------------------------------------------------------------ |
    | 重写的可能性 | 你可以使用总是重写自动装配的 <constructor-arg> 和 <property> 设置来指定依赖关系。 |
    | 原始数据类型 | 你不能自动装配所谓的简单类型包括基本类型，字符串和类。       |
    | 混乱的本质   | 自动装配不如显式装配精确，所以如果可能的话尽可能使用显式装配。 |

    - Spring 自动装配 ‘byName’

      这种模式由属性名称指定自动装配。Spring 容器看作 beans，在 XML 配置文件中 beans 的 *auto-wire* 属性设置为 *byName*。然后，它尝试将它的属性与配置文件中定义为相同名称的 beans 进行匹配和连接。如果找到匹配项，它将注入这些 beans，否则，它将抛出异常。

      例如，在配置文件中，如果一个 bean 定义设置为自动装配 *byName*，并且它包含 *spellChecker* 属性（即，它有一个 *setSpellChecker(...)* 方法），那么 Spring 就会查找定义名为 *spellChecker* 的 bean，并且用它来设置这个属性。你仍然可以使用 <property> 标签连接其余的属性。下面的例子将说明这个概念。

      这里是 **TextEditor.java** 文件的内容：

      ```java
      package com.tutorialspoint;
      public class TextEditor {
         private SpellChecker spellChecker;
         private String name;
         public void setSpellChecker( SpellChecker spellChecker ){
            this.spellChecker = spellChecker;
         }
         public SpellChecker getSpellChecker() {
            return spellChecker;
         }
         public void setName(String name) {
            this.name = name;
         }
         public String getName() {
            return name;
         }
         public void spellCheck() {
            spellChecker.checkSpelling();
         }
      }
      ```

      下面是另一个依赖类文件 **SpellChecker.java** 的内容：

      ```java
      package com.tutorialspoint;
      public class SpellChecker {
         public SpellChecker() {
            System.out.println("Inside SpellChecker constructor." );
         }
         public void checkSpelling() {
            System.out.println("Inside checkSpelling." );
         }   
      }
      ```

      下面是 **MainApp.java** 文件的内容：

      ```java
      package com.tutorialspoint;
      import org.springframework.context.ApplicationContext;
      import org.springframework.context.support.ClassPathXmlApplicationContext;
      public class MainApp {
         public static void main(String[] args) {
            ApplicationContext context = 
                   new ClassPathXmlApplicationContext("Beans.xml");
            TextEditor te = (TextEditor) context.getBean("textEditor");
            te.spellCheck();
         }
      }
      ```

      下面是在正常情况下的配置文件 **Beans.xml** 文件：

      ```xml
      <?xml version="1.0" encoding="UTF-8"?>
      
      <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
      
         <!-- Definition for textEditor bean -->
         <bean id="textEditor" class="com.tutorialspoint.TextEditor">
             <property name="spellChecker" ref="spellChecker" />
             <property name="name" value="Generic Text Editor" />
         </bean>
      
         <!-- Definition for spellChecker bean -->
         <bean id="spellChecker" class="com.tutorialspoint.SpellChecker">
         </bean>
      
      </beans>
      ```

      但是，如果你要使用自动装配 “byName”，那么你的 XML 配置文件将成为如下：

      ```xml
      <?xml version="1.0" encoding="UTF-8"?>
      
      <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
      
         <!-- Definition for textEditor bean -->
         <bean id="textEditor" class="com.tutorialspoint.TextEditor" 
            autowire="byName">
            <property name="name" value="Generic Text Editor" />
         </bean>
      
         <!-- Definition for spellChecker bean -->
         <bean id="spellChecker" class="com.tutorialspoint.SpellChecker">
         </bean>
      
      </beans>
      ```

      一旦你完成了创建源代码和 bean 的配置文件，我们就可以运行该应用程序。如果你的应用程序一切都正常，它将打印下面的消息：

      ```
      Inside SpellChecker constructor.
      Inside checkSpelling.
      ```

    - Spring 自动装配 ‘byType’

      这种模式由属性类型指定自动装配。Spring 容器看作 beans，在 XML 配置文件中 beans 的 *autowire* 属性设置为 *byType*。然后，如果它的 **type** 恰好与配置文件中 beans 名称中的一个相匹配，它将尝试匹配和连接它的属性。如果找到匹配项，它将注入这些 beans，否则，它将抛出异常。

      例如，在配置文件中，如果一个 bean 定义设置为自动装配 *byType*，并且它包含 *SpellChecker* 类型的 *spellChecker* 属性，那么 Spring 就会查找定义名为 *SpellChecker* 的 bean，并且用它来设置这个属性。你仍然可以使用 <property> 标签连接其余属性。下面的例子将说明这个概念，你会发现和上面的例子没有什么区别，除了 XML 配置文件已经被改变。

      这里是 **TextEditor.java** 文件的内容：

      ```java
      package com.tutorialspoint;
      public class TextEditor {
         private SpellChecker spellChecker;
         private String name;
         public void setSpellChecker( SpellChecker spellChecker ) {
            this.spellChecker = spellChecker;
         }
         public SpellChecker getSpellChecker() {
            return spellChecker;
         }
         public void setName(String name) {
            this.name = name;
         }
         public String getName() {
            return name;
         }
         public void spellCheck() {
            spellChecker.checkSpelling();
         }
      }
      ```

      下面是另一个依赖类文件 **SpellChecker.java** 的内容：

      ```java
      package com.tutorialspoint;
      public class SpellChecker {
         public SpellChecker(){
            System.out.println("Inside SpellChecker constructor." );
         }
         public void checkSpelling() {
            System.out.println("Inside checkSpelling." );
         }   
      }
      ```

      下面是 **MainApp.java** 文件的内容：

      ```java
      package com.tutorialspoint;
      import org.springframework.context.ApplicationContext;
      import org.springframework.context.support.ClassPathXmlApplicationContext;
      public class MainApp {
         public static void main(String[] args) {
            ApplicationContext context = 
                   new ClassPathXmlApplicationContext("Beans.xml");
            TextEditor te = (TextEditor) context.getBean("textEditor");
            te.spellCheck();
         }
      }
      ```

      下面是在正常情况下的配置文件 **Beans.xml** 文件：

      ```xml
      <?xml version="1.0" encoding="UTF-8"?>
      
      <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
      
         <!-- Definition for textEditor bean -->
         <bean id="textEditor" class="com.tutorialspoint.TextEditor">
            <property name="spellChecker" ref="spellChecker" />
            <property name="name" value="Generic Text Editor" />
         </bean>
      
         <!-- Definition for spellChecker bean -->
         <bean id="spellChecker" class="com.tutorialspoint.SpellChecker">
         </bean>
      
      </beans>
      ```

      但是，如果你要使用自动装配 “byType”，那么你的 XML 配置文件将成为如下：

      ```xml
      <?xml version="1.0" encoding="UTF-8"?>
      
      <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
      
         <!-- Definition for textEditor bean -->
         <bean id="textEditor" class="com.tutorialspoint.TextEditor" 
            autowire="byType">
            <property name="name" value="Generic Text Editor" />
         </bean>
      
         <!-- Definition for spellChecker bean -->
         <bean id="SpellChecker" class="com.tutorialspoint.SpellChecker">
         </bean>
      
      </beans>
      ```

      一旦你完成了创建源代码和 bean 的配置文件，我们就可以运行该应用程序。如果你的应用程序一切都正常，它将打印下面的消息：

      ```
      Inside SpellChecker constructor.
      Inside checkSpelling.
      ```

    - Spring 由构造函数自动装配

      这种模式与 *byType* 非常相似，但它应用于构造器参数。Spring 容器看作 beans，在 XML 配置文件中 beans 的 *autowire* 属性设置为 *constructor*。然后，它尝试把它的构造函数的参数与配置文件中 beans 名称中的一个进行匹配和连线。如果找到匹配项，它会注入这些 bean，否则，它会抛出异常。

      例如，在配置文件中，如果一个 bean 定义设置为通过*构造函数*自动装配，而且它有一个带有 *SpellChecker* 类型的参数之一的构造函数，那么 Spring 就会查找定义名为 *SpellChecker* 的 bean，并用它来设置构造函数的参数。你仍然可以使用 <constructor-arg> 标签连接其余属性。下面的例子将说明这个概念。

      这里是 **TextEditor.java** 文件的内容：

      ```java
      package com.tutorialspoint;
      public class TextEditor {
         private SpellChecker spellChecker;
         private String name;
         public TextEditor( SpellChecker spellChecker, String name ) {
            this.spellChecker = spellChecker;
            this.name = name;
         }
         public SpellChecker getSpellChecker() {
            return spellChecker;
         }
         public String getName() {
            return name;
         }
         public void spellCheck() {
            spellChecker.checkSpelling();
         }
      }
      ```

      下面是另一个依赖类文件 **SpellChecker.java** 的内容：

      ```java
      package com.tutorialspoint;
      public class SpellChecker {
         public SpellChecker(){
            System.out.println("Inside SpellChecker constructor." );
         }
         public void checkSpelling()
         {
            System.out.println("Inside checkSpelling." );
         }  
      }
      ```

      下面是 **MainApp.java** 文件的内容：

      ```java
      package com.tutorialspoint;
      import org.springframework.context.ApplicationContext;
      import org.springframework.context.support.ClassPathXmlApplicationContext;
      public class MainApp {
         public static void main(String[] args) {
            ApplicationContext context = 
                   new ClassPathXmlApplicationContext("Beans.xml");
            TextEditor te = (TextEditor) context.getBean("textEditor");
            te.spellCheck();
         }
      }
      ```

      下面是在正常情况下的配置文件 **Beans.xml** 文件：

      ```xml
      <?xml version="1.0" encoding="UTF-8"?>
      
      <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
      
         <!-- Definition for textEditor bean -->
         <bean id="textEditor" class="com.tutorialspoint.TextEditor">
            <constructor-arg  ref="spellChecker" />
            <constructor-arg  value="Generic Text Editor"/>
         </bean>
      
         <!-- Definition for spellChecker bean -->
         <bean id="spellChecker" class="com.tutorialspoint.SpellChecker">
         </bean>
      
      </beans>
      ```

      但是，如果你要使用自动装配 “by constructor”，那么你的 XML 配置文件将成为如下：

      ```xml
      <?xml version="1.0" encoding="UTF-8"?>
      
      <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
      
         <!-- Definition for textEditor bean -->
         <bean id="textEditor" class="com.tutorialspoint.TextEditor" 
            autowire="constructor">
            <constructor-arg value="Generic Text Editor"/>
         </bean>
      
         <!-- Definition for spellChecker bean -->
         <bean id="SpellChecker" class="com.tutorialspoint.SpellChecker">
         </bean>
      
      </beans>
      ```

      一旦你完成了创建源代码和 bean 的配置文件，我们就可以运行该应用程序。如果你的应用程序一切都正常，它将打印下面的消息：

      ```
      Inside SpellChecker constructor.
      Inside checkSpelling.
      ```

  - 基于注解的配置

    从 Spring 2.5 开始就可以使用**注解**来配置依赖注入。而不是采用 XML 来描述一个 bean 连线，你可以使用相关类，方法或字段声明的注解，将 bean 配置移动到组件类本身。

    在 XML 注入之前进行注解注入，因此后者的配置将通过两种方式的属性连线被前者重写。

    注解连线在默认情况下在 Spring 容器中不打开。因此，在可以使用基于注解的连线之前，我们将需要在我们的 Spring 配置文件中启用它。所以如果你想在 Spring 应用程序中使用的任何注解，可以考虑到下面的配置文件。

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    
    <beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:context="http://www.springframework.org/schema/context"
        xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context-3.0.xsd">
    
       <context:annotation-config/>
       <!-- bean definitions go here -->
    
    </beans>
    ```
    - Spring @Required 注释

      **@Required** 注释应用于 bean 属性的 setter 方法，它表明受影响的 bean 属性在配置时必须放在 XML 配置文件中，否则容器就会抛出一个 BeanInitializationException 异常。下面显示的是一个使用 @Required 注释的示例。

      下面是 **Student.java** 文件的内容：

      ```java
      package com.tutorialspoint;
      import org.springframework.beans.factory.annotation.Required;
      public class Student {
         private Integer age;
         private String name;
         @Required
         public void setAge(Integer age) {
            this.age = age;
         }
         public Integer getAge() {
            return age;
         }
         @Required
         public void setName(String name) {
            this.name = name;
         }
         public String getName() {
            return name;
         }
      }
      ```

      下面是 **MainApp.java** 文件的内容：

      ```java
      package com.tutorialspoint;
      import org.springframework.context.ApplicationContext;
      import org.springframework.context.support.ClassPathXmlApplicationContext;
      public class MainApp {
         public static void main(String[] args) {
            ApplicationContext context = new ClassPathXmlApplicationContext("Beans.xml");
            Student student = (Student) context.getBean("student");
            System.out.println("Name : " + student.getName() );
            System.out.println("Age : " + student.getAge() );
         }
      }
      ```

      下面是配置文件 **Beans.xml:** 文件的内容：

      ```xml
      <?xml version="1.0" encoding="UTF-8"?>
      
      <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:context="http://www.springframework.org/schema/context"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
          http://www.springframework.org/schema/context
          http://www.springframework.org/schema/context/spring-context-3.0.xsd">
      
         <context:annotation-config/>
      
         <!-- Definition for student bean -->
         <bean id="student" class="com.tutorialspoint.Student">
            <property name="name"  value="Zara" />
      
            <!-- try without passing age and check the result -->
            <!-- property name="age"  value="11"-->
         </bean>
      
      </beans>
      ```

      一旦你已经完成的创建了源文件和 bean 配置文件，让我们运行一下应用程序。如果你的应用程序一切都正常的话，这将引起 *BeanInitializationException* 异常，并且会输出一下错误信息和其他日志消息：

      ```
      Property 'age' is required for bean 'student'
      ```

      下一步，在你按照如下所示从 “age” 属性中删除了注释，你可以尝试运行上面的示例：

      ```xml
      <?xml version="1.0" encoding="UTF-8"?>
      
      <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:context="http://www.springframework.org/schema/context"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
          http://www.springframework.org/schema/context
          http://www.springframework.org/schema/context/spring-context-3.0.xsd">
      
         <context:annotation-config/>
      
         <!-- Definition for student bean -->
         <bean id="student" class="com.tutorialspoint.Student">
            <property name="name"  value="Zara" />
            <property name="age"  value="11"/>
         </bean>
      
      </beans>
      ```

      现在上面的示例将产生如下结果：

      ```
      Name : Zara
      Age : 11
      ```

    - Spring @Autowired 注释

      **@Autowired** 注释对在哪里和如何完成自动连接提供了更多的细微的控制。

      @Autowired 注释可以在 setter 方法中被用于自动连接 bean，就像 @Autowired 注释，容器，一个属性或者任意命名的可能带有多个参数的方法。

      **Setter 方法中的 @Autowired**

      你可以在 XML 文件中的 setter 方法中使用 **@Autowired** 注释来除去 元素。当 Spring遇到一个在 setter 方法中使用的 @Autowired 注释，它会在方法中视图执行 **byType** 自动连接。

      这里是 **TextEditor.java** 文件的内容：

      ```java
      package com.tutorialspoint;
      import org.springframework.beans.factory.annotation.Autowired;
      public class TextEditor {
         private SpellChecker spellChecker;
         @Autowired
         public void setSpellChecker( SpellChecker spellChecker ){
            this.spellChecker = spellChecker;
         }
         public SpellChecker getSpellChecker( ) {
            return spellChecker;
         }
         public void spellCheck() {
            spellChecker.checkSpelling();
         }
      }
      ```

      下面是另一个依赖的类文件 **SpellChecker.java** 的内容：

      ```java
      package com.tutorialspoint;
      public class SpellChecker {
         public SpellChecker(){
            System.out.println("Inside SpellChecker constructor." );
         }
         public void checkSpelling(){
            System.out.println("Inside checkSpelling." );
         }  
      }
      ```

      下面是 **MainApp.java** 文件的内容：

      ```java
      package com.tutorialspoint;
      import org.springframework.context.ApplicationContext;
      import org.springframework.context.support.ClassPathXmlApplicationContext;
      public class MainApp {
         public static void main(String[] args) {
            ApplicationContext context = new ClassPathXmlApplicationContext("Beans.xml");
            TextEditor te = (TextEditor) context.getBean("textEditor");
            te.spellCheck();
         }
      }
      ```

      下面是配置文件 **Beans.xml**：

      ```xml
      <?xml version="1.0" encoding="UTF-8"?>
      
      <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:context="http://www.springframework.org/schema/context"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
          http://www.springframework.org/schema/context
          http://www.springframework.org/schema/context/spring-context-3.0.xsd">
      
         <context:annotation-config/>
      
         <!-- Definition for textEditor bean without constructor-arg  -->
         <bean id="textEditor" class="com.tutorialspoint.TextEditor">
         </bean>
      
         <!-- Definition for spellChecker bean -->
         <bean id="spellChecker" class="com.tutorialspoint.SpellChecker">
         </bean>
      
      </beans>
      ```

      一旦你已经完成的创建了源文件和 bean 配置文件，让我们运行一下应用程序。如果你的应用程序一切都正常的话，这将会输出以下消息：

      ```
      Inside SpellChecker constructor.
      Inside checkSpelling.
      ```

      **属性中的 @Autowired**

      你可以在属性中使用 **@Autowired** 注释来除去 setter 方法。当时使用 为自动连接属性传递的时候，Spring 会将这些传递过来的值或者引用自动分配给那些属性。所以利用在属性中 @Autowired 的用法，你的 **TextEditor.java** 文件将变成如下所示：

      ```java
      package com.tutorialspoint;
      import org.springframework.beans.factory.annotation.Autowired;
      public class TextEditor {
         @Autowired
         private SpellChecker spellChecker;
         public TextEditor() {
            System.out.println("Inside TextEditor constructor." );
         }  
         public SpellChecker getSpellChecker( ){
            return spellChecker;
         }  
         public void spellCheck(){
            spellChecker.checkSpelling();
         }
      }
      ```

      下面是配置文件 **Beans.xml**：

      ```xml
      <?xml version="1.0" encoding="UTF-8"?>
      
      <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:context="http://www.springframework.org/schema/context"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
          http://www.springframework.org/schema/context
          http://www.springframework.org/schema/context/spring-context-3.0.xsd">
      
         <context:annotation-config/>
      
         <!-- Definition for textEditor bean -->
         <bean id="textEditor" class="com.tutorialspoint.TextEditor">
         </bean>
      
         <!-- Definition for spellChecker bean -->
         <bean id="spellChecker" class="com.tutorialspoint.SpellChecker">
         </bean>
      
      </beans>
      ```

      一旦你在源文件和 bean 配置文件中完成了上面两处改变，让我们运行一下应用程序。如果你的应用程序一切都正常的话，这将会输出以下消息：

      ```
      Inside TextEditor constructor.
      Inside SpellChecker constructor.
      Inside checkSpelling.
      ```

      **构造函数中的 @Autowired**

      你也可以在构造函数中使用 @Autowired。一个构造函数 @Autowired 说明当创建 bean 时，即使在 XML 文件中没有使用 元素配置 bean ，构造函数也会被自动连接。让我们检查一下下面的示例。

      这里是 **TextEditor.java** 文件的内容：

      ```java
      package com.tutorialspoint;
      import org.springframework.beans.factory.annotation.Autowired;
      public class TextEditor {
         private SpellChecker spellChecker;
         @Autowired
         public TextEditor(SpellChecker spellChecker){
            System.out.println("Inside TextEditor constructor." );
            this.spellChecker = spellChecker;
         }
         public void spellCheck(){
            spellChecker.checkSpelling();
         }
      }
      ```

      下面是配置文件 **Beans.xml**：

      ```xml
      <?xml version="1.0" encoding="UTF-8"?>
      
      <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:context="http://www.springframework.org/schema/context"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
          http://www.springframework.org/schema/context
          http://www.springframework.org/schema/context/spring-context-3.0.xsd">
      
         <context:annotation-config/>
      
         <!-- Definition for textEditor bean without constructor-arg  -->
         <bean id="textEditor" class="com.tutorialspoint.TextEditor">
         </bean>
      
         <!-- Definition for spellChecker bean -->
         <bean id="spellChecker" class="com.tutorialspoint.SpellChecker">
         </bean>
      
      </beans>
      ```

      一旦你在源文件和 bean 配置文件中完成了上面两处改变，让我们运行一下应用程序。如果你的应用程序一切都正常的话，这将会输出以下消息：

      ```
      Inside TextEditor constructor.
      Inside SpellChecker constructor.
      Inside checkSpelling.
      ```

      **@Autowired 的（required=false）选项**

      默认情况下，@Autowired 注释意味着依赖是必须的，它类似于 @Required 注释，然而，你可以使用 @Autowired 的 **（required=false）** 选项关闭默认行为。

      即使你不为 age 属性传递任何参数，下面的示例也会成功运行，但是对于 name 属性则需要一个参数。你可以自己尝试一下这个示例，因为除了只有 **Student.java** 文件被修改以外，它和 @Required 注释示例是相似的。

      ```java
      package com.tutorialspoint;
      import org.springframework.beans.factory.annotation.Autowired;
      public class Student {
         private Integer age;
         private String name;
         @Autowired(required=false)
         public void setAge(Integer age) {
            this.age = age;
         }  
         public Integer getAge() {
            return age;
         }
         @Autowired
         public void setName(String name) {
            this.name = name;
         }   
         public String getName() {
            return name;
         }
      }
      ```

    - Spring @Qualifier 注释

      可能会有这样一种情况，当你创建多个具有相同类型的 bean 时，并且想要用一个属性只为它们其中的一个进行装配，在这种情况下，你可以使用 **@Qualifier** 注释和 **@Autowired** 注释通过指定哪一个真正的 bean 将会被装配来消除混乱。下面显示的是使用 @Qualifier 注释的一个示例。  

      这里是 **Student.java** 文件的内容：

      ```java
      package com.tutorialspoint;
      public class Student {
         private Integer age;
         private String name;
         public void setAge(Integer age) {
            this.age = age;
         }   
         public Integer getAge() {
            return age;
         }
         public void setName(String name) {
            this.name = name;
         }  
         public String getName() {
            return name;
         }
      }
      ```

      这里是 **Profile.java** 文件的内容：

      ```java
      package com.tutorialspoint;
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.beans.factory.annotation.Qualifier;
      public class Profile {
         @Autowired
         @Qualifier("student1")
         private Student student;
         public Profile(){
            System.out.println("Inside Profile constructor." );
         }
         public void printAge() {
            System.out.println("Age : " + student.getAge() );
         }
         public void printName() {
            System.out.println("Name : " + student.getName() );
         }
      }
      ```

      下面是 **MainApp.java** 文件的内容：

      ```java
      package com.tutorialspoint;
      import org.springframework.context.ApplicationContext;
      import org.springframework.context.support.ClassPathXmlApplicationContext;
      public class MainApp {
         public static void main(String[] args) {
            ApplicationContext context = new ClassPathXmlApplicationContext("Beans.xml");
            Profile profile = (Profile) context.getBean("profile");
            profile.printAge();
            profile.printName();
         }
      }
      ```

      考虑下面配置文件 **Beans.xml** 的示例：

      ```xml
      <?xml version="1.0" encoding="UTF-8"?>
      
      <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:context="http://www.springframework.org/schema/context"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
          http://www.springframework.org/schema/context
          http://www.springframework.org/schema/context/spring-context-3.0.xsd">
      
         <context:annotation-config/>
      
         <!-- Definition for profile bean -->
         <bean id="profile" class="com.tutorialspoint.Profile">
         </bean>
      
         <!-- Definition for student1 bean -->
         <bean id="student1" class="com.tutorialspoint.Student">
            <property name="name"  value="Zara" />
            <property name="age"  value="11"/>
         </bean>
      
         <!-- Definition for student2 bean -->
         <bean id="student2" class="com.tutorialspoint.Student">
            <property name="name"  value="Nuha" />
            <property name="age"  value="2"/>
         </bean>
      
      </beans>
      ```

      一旦你在源文件和 bean 配置文件中完成了上面两处改变，让我们运行一下应用程序。如果你的应用程序一切都正常的话，这将会输出以下消息：

      ```
      Inside Profile constructor.
      Age : 11
      Name : Zara
      ```

    - Spring JSR-250 注释

      Spring还使用基于 JSR-250 注释，它包括 @PostConstruct， @PreDestroy 和 @Resource 注释。因为你已经有了其他的选择，尽管这些注释并不是真正所需要的，但是关于它们仍然让我给出一个简短的介绍。

      **@PostConstruct 和 @PreDestroy 注释：**

      为了定义一个 bean 的安装和卸载，我们使用 **init-method** 和/或 **destroy-method** 参数简单的声明一下 。init-method 属性指定了一个方法，该方法在 bean 的实例化阶段会立即被调用。同样地，destroy-method 指定了一个方法，该方法只在一个 bean 从容器中删除之前被调用。

      你可以使用 **@PostConstruct** 注释作为初始化回调函数的一个替代，**@PreDestroy** 注释作为销毁回调函数的一个替代，其解释如下示例所示。 

      这里是 **HelloWorld.java** 文件的内容：

      ```java
      package com.tutorialspoint;
      import javax.annotation.*;
      public class HelloWorld {
         private String message;
         public void setMessage(String message){
            this.message  = message;
         }
         public String getMessage(){
            System.out.println("Your Message : " + message);
            return message;
         }
         @PostConstruct
         public void init(){
            System.out.println("Bean is going through init.");
         }
         @PreDestroy
         public void destroy(){
            System.out.println("Bean will destroy now.");
         }
      }
      ```

      下面是 **MainApp.java** 文件的内容。这里你需要注册一个关闭钩 **registerShutdownHook()** 方法，该方法在 AbstractApplicationContext 类中被声明。这将确保一个完美的关闭并调用相关的销毁方法。

      ```java
      package com.tutorialspoint;
      import org.springframework.context.support.AbstractApplicationContext;
      import org.springframework.context.support.ClassPathXmlApplicationContext;
      public class MainApp {
         public static void main(String[] args) {
            AbstractApplicationContext context = 
                                new ClassPathXmlApplicationContext("Beans.xml");
            HelloWorld obj = (HelloWorld) context.getBean("helloWorld");
            obj.getMessage();
            context.registerShutdownHook();
         }
      }
      ```

      下面是配置文件 **Beans.xml**，该文件在初始化和销毁方法中需要使用。

      ```xml
      <?xml version="1.0" encoding="UTF-8"?>
      
      <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:context="http://www.springframework.org/schema/context"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
          http://www.springframework.org/schema/context
          http://www.springframework.org/schema/context/spring-context-3.0.xsd">
      
         <context:annotation-config/>
      
         <bean id="helloWorld" 
             class="com.tutorialspoint.HelloWorld"
             init-method="init" destroy-method="destroy">
             <property name="message" value="Hello World!"/>
         </bean>
      
      </beans>
      ```

      一旦你在源文件和 bean 配置文件中完成了上面两处改变，让我们运行一下应用程序。如果你的应用程序一切都正常的话，这将会输出以下消息：

      ```
      Bean is going through init.
      Your Message : Hello World!
      Bean will destroy now.
      ```

      **@Resource 注释：**

      你可以在字段中或者 setter 方法中使用 **@Resource** 注释，它和在 Java EE 5 中的运作是一样的。@Resource 注释使用一个 ‘name’ 属性，该属性以一个 bean 名称的形式被注入。你可以说，它遵循 **by-name** 自动连接语义，如下面的示例所示：

      ```java
      package com.tutorialspoint;
      import javax.annotation.Resource;
      public class TextEditor {
         private SpellChecker spellChecker;
         @Resource(name= "spellChecker")
         public void setSpellChecker( SpellChecker spellChecker ){
            this.spellChecker = spellChecker;
         }
         public SpellChecker getSpellChecker(){
            return spellChecker;
         }
         public void spellCheck(){
            spellChecker.checkSpelling();
         }
      }
      ```

      如果没有明确地指定一个 ‘name’，默认名称源于字段名或者 setter 方法。在字段的情况下，它使用的是字段名；在一个 setter 方法情况下，它使用的是 bean 属性名称。

  - 基于 Java 的配置

    到目前为止，你已经看到如何使用 XML 配置文件来配置 Spring bean。如果你熟悉使用 XML 配置，那么我会说，不需要再学习如何进行基于 Java 的配置是，因为你要达到相同的结果，可以使用其他可用的配置。

    基于 Java 的配置选项，可以使你在不用配置 XML 的情况下编写大多数的 Spring，但是一些有帮助的基于 Java 的注解，解释如下：

    **@Configuration 和 @Bean 注解**

    带有 **@Configuration** 的注解类表示这个类可以使用 Spring IoC 容器作为 bean 定义的来源。**@Bean** 注解告诉 Spring，一个带有 @Bean 的注解方法将返回一个对象，该对象应该被注册为在 Spring 应用程序上下文中的 bean。最简单可行的 @Configuration 类如下所示：

    ```java
    package com.tutorialspoint;
    import org.springframework.context.annotation.*;
    @Configuration
    public class HelloWorldConfig {
       @Bean 
       public HelloWorld helloWorld(){
          return new HelloWorld();
       }
    }
    ```

    上面的代码将等同于下面的 XML 配置：

    ```xml
    <beans>
       <bean id="helloWorld" class="com.tutorialspoint.HelloWorld" />
    </beans>
    ```

    在这里，带有 @Bean 注解的方法名称作为 bean 的 ID，它创建并返回实际的 bean。你的配置类可以声明多个 @Bean。一旦定义了配置类，你就可以使用 *AnnotationConfigApplicationContext* 来加载并把他们提供给 Spring 容器，如下所示：

    ```java
    public static void main(String[] args) {
       ApplicationContext ctx = 
       new AnnotationConfigApplicationContext(HelloWorldConfig.class); 
       HelloWorld helloWorld = ctx.getBean(HelloWorld.class);
       helloWorld.setMessage("Hello World!");
       helloWorld.getMessage();
    }
    ```

    你可以加载各种配置类，如下所示：

    ```java
    public static void main(String[] args) {
       AnnotationConfigApplicationContext ctx = 
       new AnnotationConfigApplicationContext();
       ctx.register(AppConfig.class, OtherConfig.class);
       ctx.register(AdditionalConfig.class);
       ctx.refresh();
       MyService myService = ctx.getBean(MyService.class);
       myService.doStuff();
    }
    ```

    **例子**

    这里是 **HelloWorldConfig.java** 文件的内容：

    ```java
    package com.tutorialspoint;
    import org.springframework.context.annotation.*;
    @Configuration
    public class HelloWorldConfig {
       @Bean 
       public HelloWorld helloWorld(){
          return new HelloWorld();
       }
    }
    ```

    这里是 **HelloWorld.java** 文件的内容：

    ```java
    package com.tutorialspoint;
    
    public class HelloWorld {
       private String message;
    
       public void setMessage(String message){
          this.message  = message;
       }
    
       public void getMessage(){
          System.out.println("Your Message : " + message);
       }
    }
    ```

    下面是 **MainApp.java** 文件的内容：

    ```java
    package com.tutorialspoint;
    
    import org.springframework.context.ApplicationContext;
    import org.springframework.context.annotation.*;
    
    public class MainApp {
       public static void main(String[] args) {
          ApplicationContext ctx = 
          new AnnotationConfigApplicationContext(HelloWorldConfig.class);
    
          HelloWorld helloWorld = ctx.getBean(HelloWorld.class);
    
          helloWorld.setMessage("Hello World!");
          helloWorld.getMessage();
       }
    }
    ```

    一旦你完成了创建所有的源文件并添加所需的额外的库后，我们就可以运行该应用程序。你应该注意这里不需要配置文件。如果你的应用程序一切都正常，将输出以下信息：

    ```
    Your Message : Hello World!
    ```

    **注入 Bean 的依赖性**

    当 @Beans 依赖对方时，表达这种依赖性非常简单，只要有一个 bean 方法调用另一个，如下所示：

    ```java
    package com.tutorialspoint;
    import org.springframework.context.annotation.*;
    @Configuration
    public class AppConfig {
       @Bean
       public Foo foo() {
          return new Foo(bar());
       }
       @Bean
       public Bar bar() {
          return new Bar();
       }
    }
    ```

    这里，foo Bean 通过构造函数注入来接收参考基准。现在，让我们看到一个正在执行的例子：

    **例子**

    这里是 **TextEditorConfig.java** 文件的内容：

    ```java
    package com.tutorialspoint;
    import org.springframework.context.annotation.*;
    @Configuration
    public class TextEditorConfig {
       @Bean 
       public TextEditor textEditor(){
          return new TextEditor( spellChecker() );
       }
       @Bean 
       public SpellChecker spellChecker(){
          return new SpellChecker( );
       }
    }
    ```

    这里是 TextEditor.java 文件的内容：

    ```java
    package com.tutorialspoint;
    public class TextEditor {
       private SpellChecker spellChecker;
       public TextEditor(SpellChecker spellChecker){
          System.out.println("Inside TextEditor constructor." );
          this.spellChecker = spellChecker;
       }
       public void spellCheck(){
          spellChecker.checkSpelling();
       }
    }
    ```

    下面是另一个依赖的类文件 **SpellChecker.java** 的内容：

    ```java
    package com.tutorialspoint;
    public class SpellChecker {
       public SpellChecker(){
          System.out.println("Inside SpellChecker constructor." );
       }
       public void checkSpelling(){
          System.out.println("Inside checkSpelling." );
       }
    
    }
    ```

    下面是 **MainApp.java** 文件的内容：

    ```java
    package com.tutorialspoint;
    
    import org.springframework.context.ApplicationContext;
    import org.springframework.context.annotation.*;
    
    public class MainApp {
       public static void main(String[] args) {
          ApplicationContext ctx = 
          new AnnotationConfigApplicationContext(TextEditorConfig.class);
    
          TextEditor te = ctx.getBean(TextEditor.class);
    
          te.spellCheck();
       }
    }
    ```

    一旦你完成了创建所有的源文件并添加所需的额外的库后，我们就可以运行该应用程序。你应该注意这里不需要配置文件。如果你的应用程序一切都正常，将输出以下信息：

    ```
    Inside SpellChecker constructor.
    Inside TextEditor constructor.
    Inside checkSpelling.
    ```

    **@Import 注解:**

    **@import** 注解允许从另一个配置类中加载 @Bean 定义。考虑 ConfigA 类，如下所示：

    ```java
    @Configuration
    public class ConfigA {
       @Bean
       public A a() {
          return new A(); 
       }
    }
    ```

    你可以在另一个 Bean 声明中导入上述 Bean 声明，如下所示：

    ```java
    @Configuration
    @Import(ConfigA.class)
    public class ConfigB {
       @Bean
       public B a() {
          return new A(); 
       }
    }
    ```

    现在，当实例化上下文时，不需要同时指定 ConfigA.class 和 ConfigB.class，只有 ConfigB 类需要提供，如下所示：

    ```java
    public static void main(String[] args) {
       ApplicationContext ctx = 
       new AnnotationConfigApplicationContext(ConfigB.class);
       // now both beans A and B will be available...
       A a = ctx.getBean(A.class);
       B b = ctx.getBean(B.class);
    }
    ```

    **生命周期回调**

    @Bean 注解支持指定任意的初始化和销毁的回调方法，就像在 bean 元素中 Spring 的 XML 的初始化方法和销毁方法的属性：

    ```java
    public class Foo {
       public void init() {
          // initialization logic
       }
       public void cleanup() {
          // destruction logic
       }
    }
    
    @Configuration
    public class AppConfig {
       @Bean(initMethod = "init", destroyMethod = "cleanup" )
       public Foo foo() {
          return new Foo();
       }
    }
    ```

    指定 Bean 的范围：

    默认范围是单实例，但是你可以重写带有 @Scope 注解的该方法，如下所示：

    ```java
    @Configuration
    public class AppConfig {
       @Bean
       @Scope("prototype")
       public Foo foo() {
          return new Foo();
       }
    }
    ```

  - Spring 中的事件处理

    你已经看到了在所有章节中 Spring 的核心是 **ApplicationContext**，它负责管理 beans 的完整生命周期。当加载 beans 时，ApplicationContext 发布某些类型的事件。例如，当上下文启动时，*ContextStartedEvent* 发布，当上下文停止时，*ContextStoppedEvent* 发布。

    通过 *ApplicationEvent* 类和 *ApplicationListener* 接口来提供在 *ApplicationContext* 中处理事件。如果一个 bean 实现 *ApplicationListener*，那么每次 *ApplicationEvent* 被发布到 ApplicationContext 上，那个 bean 会被通知。  

    Spring 提供了以下的标准事件：

    | 序号 | Spring 内置事件 & 描述                                       |
    | ---- | ------------------------------------------------------------ |
    | 1    | **ContextRefreshedEvent** *ApplicationContext* 被初始化或刷新时，该事件被发布。这也可以在 *ConfigurableApplicationContext* 接口中使用 refresh() 方法来发生。 |
    | 2    | **ContextStartedEvent**当使用 *ConfigurableApplicationContext* 接口中的 start() 方法启动 *ApplicationContext* 时，该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。 |
    | 3    | **ContextStoppedEvent**当使用 *ConfigurableApplicationContext* 接口中的 stop() 方法停止 *ApplicationContext* 时，发布这个事件。你可以在接受到这个事件后做必要的清理的工作。 |
    | 4    | **ContextClosedEvent**当使用 *ConfigurableApplicationContext* 接口中的 close() 方法关闭 *ApplicationContext* 时，该事件被发布。一个已关闭的上下文到达生命周期末端；它不能被刷新或重启。 |
    | 5    | **RequestHandledEvent**这是一个 web-specific 事件，告诉所有 bean HTTP 请求已经被服务。 |

    由于 Spring 的事件处理是单线程的，所以如果一个事件被发布，直至并且除非所有的接收者得到的该消息，该进程被阻塞并且流程将不会继续。因此，如果事件处理被使用，在设计应用程序时应注意。

    **监听上下文事件**

    为了监听上下文事件，一个 bean 应该实现只有一个方法 **onApplicationEvent()** 的 *ApplicationListener* 接口。因此，我们写一个例子来看看事件是如何传播的，以及如何可以用代码来执行基于某些事件所需的任务。

    这里是 **HelloWorld.java** 文件的内容：

    ```java
    package com.tutorialspoint;
    public class HelloWorld {
       private String message;
       public void setMessage(String message){
          this.message  = message;
       }
       public void getMessage(){
          System.out.println("Your Message : " + message);
       }
    }
    ```

    下面是 **CStartEventHandler.java** 文件的内容：

    ```java
    package com.tutorialspoint;
    import org.springframework.context.ApplicationListener;
    import org.springframework.context.event.ContextStartedEvent;
    public class CStartEventHandler 
       implements ApplicationListener<ContextStartedEvent>{
       public void onApplicationEvent(ContextStartedEvent event) {
          System.out.println("ContextStartedEvent Received");
       }
    }
    ```

    下面是 **CStopEventHandler.java** 文件的内容：

    ```java
    package com.tutorialspoint;
    import org.springframework.context.ApplicationListener;
    import org.springframework.context.event.ContextStoppedEvent;
    public class CStopEventHandler 
       implements ApplicationListener<ContextStoppedEvent>{
       public void onApplicationEvent(ContextStoppedEvent event) {
          System.out.println("ContextStoppedEvent Received");
       }
    }
    ```

    下面是 **MainApp.java** 文件的内容：

    ```java
    package com.tutorialspoint;
    
    import org.springframework.context.ConfigurableApplicationContext;
    import org.springframework.context.support.ClassPathXmlApplicationContext;
    
    public class MainApp {
       public static void main(String[] args) {
          ConfigurableApplicationContext context = 
          new ClassPathXmlApplicationContext("Beans.xml");
    
          // Let us raise a start event.
          context.start();
    
          HelloWorld obj = (HelloWorld) context.getBean("helloWorld");
    
          obj.getMessage();
    
          // Let us raise a stop event.
          context.stop();
       }
    }
    ```

    下面是配置文件 **Beans.xml** 文件：

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    
    <beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
    
       <bean id="helloWorld" class="com.tutorialspoint.HelloWorld">
          <property name="message" value="Hello World!"/>
       </bean>
    
       <bean id="cStartEventHandler" 
             class="com.tutorialspoint.CStartEventHandler"/>
    
       <bean id="cStopEventHandler" 
             class="com.tutorialspoint.CStopEventHandler"/>
    
    </beans>
    ```

    一旦你完成了创建源和 bean 的配置文件，我们就可以运行该应用程序。如果你的应用程序一切都正常，将输出以下消息：

    ```
    ContextStartedEvent Received
    Your Message : Hello World!
    ContextStoppedEvent Received
    ```

  - Spring 中的自定义事件(?)

    这个是 **CustomEvent.java** 文件的内容：

    ```java
    package com.tutorialspoint;
    import org.springframework.context.ApplicationEvent;
    public class CustomEvent extends ApplicationEvent{ 
       public CustomEvent(Object source) {
          super(source);
       }
       public String toString(){
          return "My Custom Event";
       }
    }
    ```

    下面是 **CustomEventPublisher.java** 文件的内容：

    ```java
    package com.tutorialspoint;
    import org.springframework.context.ApplicationEventPublisher;
    import org.springframework.context.ApplicationEventPublisherAware;
    public class CustomEventPublisher 
       implements ApplicationEventPublisherAware {
       private ApplicationEventPublisher publisher;
       public void setApplicationEventPublisher
                  (ApplicationEventPublisher publisher){
          this.publisher = publisher;
       }
       public void publish() {
          CustomEvent ce = new CustomEvent(this);
          publisher.publishEvent(ce);
       }
    }
    ```

    下面是 **CustomEventHandler.java** 文件的内容：

    ```java
    package com.tutorialspoint;
    import org.springframework.context.ApplicationListener;
    public class CustomEventHandler 
       implements ApplicationListener<CustomEvent>{
       public void onApplicationEvent(CustomEvent event) {
          System.out.println(event.toString());
       }
    }
    ```

    下面是 **MainApp.java** 文件的内容：

    ```java
    package com.tutorialspoint;
    import org.springframework.context.ConfigurableApplicationContext;  
    import org.springframework.context.support.ClassPathXmlApplicationContext;
    public class MainApp {
       public static void main(String[] args) {
          ConfigurableApplicationContext context = 
          new ClassPathXmlApplicationContext("Beans.xml");    
          CustomEventPublisher cvp = 
          (CustomEventPublisher) context.getBean("customEventPublisher");
          cvp.publish();  
          cvp.publish();
       }
    }
    ```

    下面是配置文件 **Beans.xml**：

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    
    <beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
    
       <bean id="customEventHandler" 
          class="com.tutorialspoint.CustomEventHandler"/>
    
       <bean id="customEventPublisher" 
          class="com.tutorialspoint.CustomEventPublisher"/>
    
    </beans>
    ```

    一旦你完成了创建源和 bean 的配置文件后，我们就可以运行该应用程序。如果你的应用程序一切都正常，将输出以下信息：

    ```
    My Custom Event
    My Custom Event
    ```

  - Spring 框架的 AOP

    Spring 框架的一个关键组件是**面向方面的编程**(AOP)框架。面向方面的编程需要把程序逻辑分解成不同的部分称为所谓的关注点。跨一个应用程序的多个点的功能被称为**横切关注点**，这些横切关注点在概念上独立于应用程序的业务逻辑。有各种各样的常见的很好的方面的例子，如日志记录、审计、声明式事务、安全性和缓存等。

    在 OOP 中，关键单元模块度是类，而在 AOP 中单元模块度是方面。依赖注入帮助你对应用程序对象相互解耦和 AOP 可以帮助你从它们所影响的对象中对横切关注点解耦。AOP 是像编程语言的触发物，如 Perl，.NET，Java 或者其他。

    Spring AOP 模块提供拦截器来拦截一个应用程序，例如，当执行一个方法时，你可以在方法执行之前或之后添加额外的功能。  

    **通知的类型**

    Spring 方面可以使用下面提到的五种通知工作：

    | 通知           | 描述                                                         |
    | -------------- | ------------------------------------------------------------ |
    | 前置通知       | 在一个方法执行之前，执行通知。                               |
    | 后置通知       | 在一个方法执行之后，不考虑其结果，执行通知。                 |
    | 返回后通知     | 在一个方法执行之后，只有在方法成功完成时，才能执行通知。     |
    | 抛出异常后通知 | 在一个方法执行之后，只有在方法退出抛出异常时，才能执行通知。 |
    | 环绕通知       | 在建议方法调用之前和之后，执行通知。                         |

    - Spring 中基于 AOP 的 XML架构

      为了在本节的描述中使用 aop 命名空间标签，你需要导入 spring-aop 架构，如下所述：

      ```xml
      <?xml version="1.0" encoding="UTF-8"?>
      <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
          xmlns:aop="http://www.springframework.org/schema/aop"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd 
          http://www.springframework.org/schema/aop 
          http://www.springframework.org/schema/aop/spring-aop-3.0.xsd ">
      
         <!-- bean definition & AOP specific configuration -->
      
      </beans>
      ```

      **声明一个 aspect**

      一个 **aspect** 是使用 元素声明的，支持的 bean 是使用 **ref** 属性引用的，如下所示：

      ```xml
      <aop:config>
         <aop:aspect id="myAspect" ref="aBean">
         ...
         </aop:aspect>
      </aop:config>
      <bean id="aBean" class="...">
      ...
      </bean>
      ```

      这里，“aBean” 将被配置和依赖注入，就像前面的章节中你看到的其他的 Spring bean 一样。

      **声明一个切入点**

      一个**切入点**有助于确定使用不同建议执行的感兴趣的连接点（即方法）。在处理基于配置的 XML 架构时，切入点将会按照如下所示定义：

      ```xml
      <aop:config>
         <aop:aspect id="myAspect" ref="aBean">
         <aop:pointcut id="businessService"
            expression="execution(* com.xyz.myapp.service.*.*(..))"/>
         ...
         </aop:aspect>
      </aop:config>
      <bean id="aBean" class="...">
      ...
      </bean>
      ```

      下面的示例定义了一个名为 “businessService” 的切入点，该切入点将与 com.tutorialspoint 包下的 Student 类中的 getName() 方法相匹配：

      ```xml
      <aop:config>
         <aop:aspect id="myAspect" ref="aBean">
         <aop:pointcut id="businessService"
            expression="execution(* com.tutorialspoint.Student.getName(..))"/>
         ...
         </aop:aspect>
      </aop:config>
      <bean id="aBean" class="...">
      ...
      </bean>
      ```

      **声明建议**

      你可以使用 <aop:{ADVICE NAME}> 元素在一个`<aop:aspect>`中声明五个建议中的任何一个，如下所示：

      ```xml
      <aop:config>
         <aop:aspect id="myAspect" ref="aBean">
            <aop:pointcut id="businessService"
               expression="execution(* com.xyz.myapp.service.*.*(..))"/>
            <!-- a before advice definition -->
            <aop:before pointcut-ref="businessService" 
               method="doRequiredTask"/>
            <!-- an after advice definition -->
            <aop:after pointcut-ref="businessService" 
               method="doRequiredTask"/>
            <!-- an after-returning advice definition -->
            <!--The doRequiredTask method must have parameter named retVal -->
            <aop:after-returning pointcut-ref="businessService"
               returning="retVal"
               method="doRequiredTask"/>
            <!-- an after-throwing advice definition -->
            <!--The doRequiredTask method must have parameter named ex -->
            <aop:after-throwing pointcut-ref="businessService"
               throwing="ex"
               method="doRequiredTask"/>
            <!-- an around advice definition -->
            <aop:around pointcut-ref="businessService" 
               method="doRequiredTask"/>
         ...
         </aop:aspect>
      </aop:config>
      <bean id="aBean" class="...">
      ...
      </bean>
      ```

      你可以对不同的建议使用相同的 **doRequiredTask** 或者不同的方法。这些方法将会作为 aspect 模块的一部分来定义。

      **基于 AOP 的 XML 架构的示例**

      这里是 **Logging.java** 文件的内容。这实际上是 aspect 模块的一个示例，它定义了在各个点调用的方法。

      ```java
      package com.tutorialspoint;
      public class Logging {
         /** 
          * This is the method which I would like to execute
          * before a selected method execution.
          */
         public void beforeAdvice(){
            System.out.println("Going to setup student profile.");
         }
         /** 
          * This is the method which I would like to execute
          * after a selected method execution.
          */
         public void afterAdvice(){
            System.out.println("Student profile has been setup.");
         }
         /** 
          * This is the method which I would like to execute
          * when any method returns.
          */
         public void afterReturningAdvice(Object retVal){
            System.out.println("Returning:" + retVal.toString() );
         }
         /**
          * This is the method which I would like to execute
          * if there is an exception raised.
          */
         public void AfterThrowingAdvice(IllegalArgumentException ex){
            System.out.println("There has been an exception: " + ex.toString());   
         }  
      }
      ```

      下面是 **Student.java** 文件的内容：

      ```java
      package com.tutorialspoint;
      public class Student {
         private Integer age;
         private String name;
         public void setAge(Integer age) {
            this.age = age;
         }
         public Integer getAge() {
            System.out.println("Age : " + age );
            return age;
         }
         public void setName(String name) {
            this.name = name;
         }
         public String getName() {
            System.out.println("Name : " + name );
            return name;
         }  
         public void printThrowException(){
             System.out.println("Exception raised");
             throw new IllegalArgumentException();
         }
      }
      ```

      下面是 **MainApp.java** 文件的内容：

      ```java
      package com.tutorialspoint;
      import org.springframework.context.ApplicationContext;
      import org.springframework.context.support.ClassPathXmlApplicationContext;
      public class MainApp {
         public static void main(String[] args) {
            ApplicationContext context = 
                   new ClassPathXmlApplicationContext("Beans.xml");
            Student student = (Student) context.getBean("student");
            student.getName();
            student.getAge();      
            student.printThrowException();
         }
      }
      ```

      下面是配置文件 **Beans.xml**：

      ```xml
      <?xml version="1.0" encoding="UTF-8"?>
      <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
          xmlns:aop="http://www.springframework.org/schema/aop"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd 
          http://www.springframework.org/schema/aop 
          http://www.springframework.org/schema/aop/spring-aop-3.0.xsd ">
      
         <aop:config>
            <aop:aspect id="log" ref="logging">
               <aop:pointcut id="selectAll" 
               expression="execution(* com.tutorialspoint.*.*(..))"/>
               <aop:before pointcut-ref="selectAll" method="beforeAdvice"/>
               <aop:after pointcut-ref="selectAll" method="afterAdvice"/>
               <aop:after-returning pointcut-ref="selectAll" 
                                    returning="retVal"
                                    method="afterReturningAdvice"/>
               <aop:after-throwing pointcut-ref="selectAll" 
                                   throwing="ex"
                                   method="AfterThrowingAdvice"/>
            </aop:aspect>
         </aop:config>
      
         <!-- Definition for student bean -->
         <bean id="student" class="com.tutorialspoint.Student">
            <property name="name"  value="Zara" />
            <property name="age"  value="11"/>      
         </bean>
      
         <!-- Definition for logging aspect -->
         <bean id="logging" class="com.tutorialspoint.Logging"/> 
      
      </beans>
      ```

      一旦你已经完成的创建了源文件和 bean 配置文件，让我们运行一下应用程序。如果你的应用程序一切都正常的话，这将会输出以下消息：

      ```
      Going to setup student profile.
      Name : Zara
      Student profile has been setup.
      Returning:Zara
      Going to setup student profile.
      Age : 11
      Student profile has been setup.
      Returning:11
      Going to setup student profile.
      Exception raised
      Student profile has been setup.
      There has been an exception: java.lang.IllegalArgumentException
      .....
      other exception content
      ```

      让我们来解释一下上面定义的在 com.tutorialspoint 中 选择所有方法的 。让我们假设一下，你想要在一个特殊的方法之前或者之后执行你的建议，你可以通过替换使用真实类和方法名称的切入点定义中的星号（*）来定义你的切入点来缩短你的执行。

      ```xml
      <?xml version="1.0" encoding="UTF-8"?>
      <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
          xmlns:aop="http://www.springframework.org/schema/aop"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd 
          http://www.springframework.org/schema/aop 
          http://www.springframework.org/schema/aop/spring-aop-3.0.xsd ">
      
         <aop:config>
         <aop:aspect id="log" ref="logging">
            <aop:pointcut id="selectAll" 
            expression="execution(* com.tutorialspoint.Student.getName(..))"/>
            <aop:before pointcut-ref="selectAll" method="beforeAdvice"/>
            <aop:after pointcut-ref="selectAll" method="afterAdvice"/>
         </aop:aspect>
         </aop:config>
      
         <!-- Definition for student bean -->
         <bean id="student" class="com.tutorialspoint.Student">
            <property name="name"  value="Zara" />
            <property name="age"  value="11"/>      
         </bean>
      
         <!-- Definition for logging aspect -->
         <bean id="logging" class="com.tutorialspoint.Logging"/> 
      
      </beans>
      ```

      如果你想要执行通过这些更改之后的示例应用程序，这将会输出以下消息：

      ```
      Going to setup student profile.
      Name : Zara
      Student profile has been setup.
      Age : 11
      Exception raised
      .....
      other exception content
      ```

    - Spring 中基于 AOP 的 @AspectJ

      @AspectJ 作为通过 Java 5 注释注释的普通的 Java 类，它指的是声明 aspects 的一种风格。通过在你的基于架构的 XML 配置文件中包含以下元素，@AspectJ 支持是可用的。

      ```
      <aop:aspectj-autoproxy/>
      ```

      **声明一个 aspect**

      Aspects 类和其他任何正常的 bean 一样，除了它们将会用 @AspectJ 注释之外，它和其他类一样可能有方法和字段，如下所示：

      ```java
      package org.xyz;
      import org.aspectj.lang.annotation.Aspect;
      @Aspect
      public class AspectModule {
      }
      ```

      它们将在 XML 中按照如下进行配置，就和其他任何 bean 一样：

      ```xml
      <bean id="myAspect" class="org.xyz.AspectModule">
         <!-- configure properties of aspect here as normal -->
      </bean>
      ```

      **声明一个切入点**

      一个**切入点**有助于确定使用不同建议执行的感兴趣的连接点（即方法）。在处理基于配置的 XML 架构时，切入点的声明有两个部分：

      - 一个切入点表达式决定了我们感兴趣的哪个方法会真正被执行。
      - 一个切入点标签包含一个名称和任意数量的参数。方法的真正内容是不相干的，并且实际上它应该是空的。

      下面的示例中定义了一个名为 ‘businessService’ 的切入点，该切入点将与 com.tutorialspoint 包下的类中可用的每一个方法相匹配：

      ```java
      import org.aspectj.lang.annotation.Pointcut;
      @Pointcut("execution(* com.xyz.myapp.service.*.*(..))") // expression 
      private void businessService() {}  // signature
      ```

      下面的示例中定义了一个名为 ‘getname’ 的切入点，该切入点将与 com.tutorialspoint 包下的 Student 类中的 getName() 方法相匹配：

      ```java
      import org.aspectj.lang.annotation.Pointcut;
      @Pointcut("execution(* com.tutorialspoint.Student.getName(..))") 
      private void getname() {}
      ```

      **声明建议**

      你可以使用 @{ADVICE-NAME} 注释声明五个建议中的任意一个，如下所示。这假设你已经定义了一个切入点标签方法 businessService()：

      ```java
      @Before("businessService()")
      public void doBeforeTask(){
       ...
      }
      @After("businessService()")
      public void doAfterTask(){
       ...
      }
      @AfterReturning(pointcut = "businessService()", returning="retVal")
      public void doAfterReturnningTask(Object retVal){
        // you can intercept retVal here.
        ...
      }
      @AfterThrowing(pointcut = "businessService()", throwing="ex")
      public void doAfterThrowingTask(Exception ex){
        // you can intercept thrown exception here.
        ...
      }
      @Around("businessService()")
      public void doAroundTask(){
       ...
      }
      ```

      你可以为任意一个建议定义你的切入点内联。下面是在建议之前定义内联切入点的一个示例：

      ```java
      @Before("execution(* com.xyz.myapp.service.*.*(..))")
      public doBeforeTask(){
       ...
      }
      ```

      **基于 AOP 的 @AspectJ 示例**

      为了理解上面提到的关于基于 AOP 的 @AspectJ 的概念，让我们编写一个示例，可以实现几个建议。

      这里是 **Logging.java** 文件的内容。这实际上是 aspect 模块的一个示例，它定义了在各个点调用的方法。

      ```java
      package com.tutorialspoint;
      import org.aspectj.lang.annotation.Aspect;
      import org.aspectj.lang.annotation.Pointcut;
      import org.aspectj.lang.annotation.Before;
      import org.aspectj.lang.annotation.After;
      import org.aspectj.lang.annotation.AfterThrowing;
      import org.aspectj.lang.annotation.AfterReturning;
      import org.aspectj.lang.annotation.Around;
      @Aspect
      public class Logging {
         /** Following is the definition for a pointcut to select
          *  all the methods available. So advice will be called
          *  for all the methods.
          */
         @Pointcut("execution(* com.tutorialspoint.*.*(..))")
         private void selectAll(){}
         /** 
          * This is the method which I would like to execute
          * before a selected method execution.
          */
         @Before("selectAll()")
         public void beforeAdvice(){
            System.out.println("Going to setup student profile.");
         }
         /** 
          * This is the method which I would like to execute
          * after a selected method execution.
          */
         @After("selectAll()")
         public void afterAdvice(){
            System.out.println("Student profile has been setup.");
         }
         /** 
          * This is the method which I would like to execute
          * when any method returns.
          */
         @AfterReturning(pointcut = "selectAll()", returning="retVal")
         public void afterReturningAdvice(Object retVal){
            System.out.println("Returning:" + retVal.toString() );
         }
         /**
          * This is the method which I would like to execute
          * if there is an exception raised by any method.
          */
         @AfterThrowing(pointcut = "selectAll()", throwing = "ex")
         public void AfterThrowingAdvice(IllegalArgumentException ex){
            System.out.println("There has been an exception: " + ex.toString());   
         }  
      }
      ```

      下面是 **Student.java** 文件的内容：

      ```java
      package com.tutorialspoint;
      public class Student {
         private Integer age;
         private String name;
         public void setAge(Integer age) {
            this.age = age;
         }
         public Integer getAge() {
            System.out.println("Age : " + age );
            return age;
         }
         public void setName(String name) {
            this.name = name;
         }
         public String getName() {
            System.out.println("Name : " + name );
            return name;
         }
         public void printThrowException(){
            System.out.println("Exception raised");
            throw new IllegalArgumentException();
         }
      }
      ```

      下面是 **MainApp.java** 文件的内容：

      ```java
      package com.tutorialspoint;
      import org.springframework.context.ApplicationContext;
      import org.springframework.context.support.ClassPathXmlApplicationContext;
      public class MainApp {
         public static void main(String[] args) {
            ApplicationContext context = 
                   new ClassPathXmlApplicationContext("Beans.xml");
            Student student = (Student) context.getBean("student");
            student.getName();
            student.getAge();     
            student.printThrowException();
         }
      }
      ```

      下面是配置文件 **Beans.xml**：

      ```xml
      <?xml version="1.0" encoding="UTF-8"?>
      <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
          xmlns:aop="http://www.springframework.org/schema/aop"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd 
          http://www.springframework.org/schema/aop 
          http://www.springframework.org/schema/aop/spring-aop-3.0.xsd ">
      
          <aop:aspectj-autoproxy/>
      
         <!-- Definition for student bean -->
         <bean id="student" class="com.tutorialspoint.Student">
            <property name="name"  value="Zara" />
            <property name="age"  value="11"/>      
         </bean>
      
         <!-- Definition for logging aspect -->
         <bean id="logging" class="com.tutorialspoint.Logging"/> 
      
      </beans>
      ```

      一旦你已经完成的创建了源文件和 bean 配置文件，让我们运行一下应用程序。如果你的应用程序一切都正常的话，这将会输出以下消息：

      ```
      Going to setup student profile.
      Name : Zara
      Student profile has been setup.
      Returning:Zara
      Going to setup student profile.
      Age : 11
      Student profile has been setup.
      Returning:11
      Going to setup student profile.
      Exception raised
      Student profile has been setup.
      There has been an exception: java.lang.IllegalArgumentException
      .....
      other exception content
      ```

  - JBDC框架(?)

  - 事务管理

    一个数据库事务是一个被视为单一的工作单元的操作序列。这些操作应该要么完整地执行，要么完全不执行。事务管理是一个重要组成部分，RDBMS 面向企业应用程序，以确保数据完整性和一致性。事务的概念可以描述为具有以下四个关键属性说成是 **ACID**：

    - **原子性：**事务应该当作一个单独单元的操作，这意味着整个序列操作要么是成功，要么是失败的。
    - **一致性：**这表示数据库的引用完整性的一致性，表中唯一的主键等。
    - **隔离性：**可能同时处理很多有相同的数据集的事务，每个事务应该与其他事务隔离，以防止数据损坏。
    - **持久性：**一个事务一旦完成全部操作后，这个事务的结果必须是永久性的，不能因系统故障而从数据库中删除。

  - Web MVC框架

    Spring web MVC 框架提供了模型-视图-控制的体系结构和可以用来开发灵活、松散耦合的 web 应用程序的组件。MVC 模式导致了应用程序的不同方面(输入逻辑、业务逻辑和 UI 逻辑)的分离，同时提供了在这些元素之间的松散耦合。

    - **模型**封装了应用程序数据，并且通常它们由 POJO 组成。
    - **视图**主要用于呈现模型数据，并且通常它生成客户端的浏览器可以解释的 HTML 输出。
    - **控制器**主要用于处理用户请求，并且构建合适的模型并将其传递到视图呈现。

    **定义控制器**

    DispatcherServlet 发送请求到控制器中执行特定的功能。**@Controller** 注释表明一个特定类是一个控制器的作用。**@RequestMapping** 注释用于映射 URL 到整个类或一个特定的处理方法。

    ```java
    @Controller
    @RequestMapping("/hello")
    public class HelloController{
       @RequestMapping(method = RequestMethod.GET)
       public String printHello(ModelMap model) {
          model.addAttribute("message", "Hello Spring MVC Framework!");
          return "hello";
       }
    }
    ```

    **@Controller** 注释定义该类作为一个 Spring MVC 控制器。在这里，第一次使用的 **@RequestMapping** 表明在该控制器中处理的所有方法都是相对于 **/hello** 路径的。下一个注释 **@RequestMapping(method = RequestMethod.GET)** 用于声明 *printHello()* 方法作为控制器的默认 service 方法来处理 HTTP GET 请求。你可以在相同的 URL 中定义其他方法来处理任何 POST 请求。

    你可以用另一种形式来编写上面的控制器，你可以在 *@RequestMapping* 中添加额外的属性，如下所示：

    ```java
    @Controller
    public class HelloController{
       @RequestMapping(value = "/hello", method = RequestMethod.GET)
       public String printHello(ModelMap model) {
          model.addAttribute("message", "Hello Spring MVC Framework!");
          return "hello";
       }
    }
    ```

    **值**属性表明 URL 映射到哪个处理方法，**方法**属性定义了 service 方法来处理 HTTP GET 请求。关于上面定义的控制器，这里有以下几个要注意的要点：

    - 你将在一个 service 方法中定义需要的业务逻辑。你可以根据每次需求在这个方法中调用其他方法。
    - 基于定义的业务逻辑，你将在这个**方法**中创建一个模型。你可以设置不同的模型属性，这些属性将被视图访问并显示最终的结果。这个示例创建了一个带有属性 “message” 的模型。
    - 一个定义的 service 方法可以返回一个包含**视图**名称的字符串用于呈现该模型。这个示例返回 “hello” 作为逻辑视图的名称。

- Spring Bean

  > [https://www.awaimai.com/2596.html](<https://www.awaimai.com/2596.html>)

  - 定义

    在 Spring 中，构成应用程序**主干**并由**Spring IoC容器**管理的**对象**称为**bean**。bean是一个由Spring IoC容器实例化、组装和管理的对象。

    关键信息：

    1. bean是对象，一个或者多个不限定
    2. bean由Spring中一个叫IoC的东西管理
    3. 我们的应用程序由一个个bean构成

  - 控制反转（IoC）

    **控制反转**英文全称：**Inversion of Control**，简称就是`IoC`。

    控制反转通过依赖注入（DI）方式**实现对象之间的松耦合关系**。

    程序运行时，依赖对象由【辅助程序】动态生成并注入到被依赖对象中，动态绑定两者的使用关系。

    Spring IoC容器就是这样的辅助程序，它负责对象的生成和依赖的注入，让后在交由我们使用。

    简而言之，就是：IoC就是**一个对象定义其依赖关系而不创建它们的过程**。

    - 私有属性保存依赖

      **第1点：使用私有属性保存依赖对象，并且只能通过构造函数参数传入，**

      构造函数的参数可以是**工厂方法**、**保存类对象的属性**、或者是**工厂方法返回值**。

      假设我们有一个`Computer`类：

      ```java
      public class Computer {
          private String cpu;     // CPU型号
          private int ram;        // RAM大小，单位GB
      
          public Computer(String cpu, int ram) {
              this.cpu = cpu;
              this.ram = ram;
          }
      }
      ```

      我们有另一个`Person`类依赖于`Computer`类，符合IoC的做法是这样：

      ```java
      public class Person {
          private Computer computer;
      
          public Person(Computer computer) {
              this.computer = computer;
          }
      }
      ```

      不符合IoC的做法如下：

      ```java
      // 直接在Person里实例化Computer类
      public class Person {
          private Computer computer = new Computer("AMD", 3);
      }
      
      // 通过【非构造函数】传入依赖
      public class Person {
          private Computer computer;
          
          public void init(Computer computer) {
              this.computer = computer;
          }
      }
      ```

    - 让Spring控制类构建过程

      **第2点：不用**`new`**，让Spring控制**`new`**过程。**

      在Spring中，我们基本不需要 `new` 一个类，这些都是让 Spring 去做的。

      Spring 启动时会把所需的类实例化成对象，如果需要依赖，则先实例化依赖，然后实例化当前类。

      因为依赖必须通过构建函数传入，所以实例化时，当前类就会接收并保存所有依赖的对象。

      这一步也就是所谓的**依赖注入**。

    - 这就是IoC

      在 Spring 中，**类的实例化、依赖的实例化、依赖的传入**都交由 Spring Bean 容器控制，

      而不是用`new`方式实例化对象、通过非构造函数方法传入依赖等常规方式。

      实质的控制权已经交由程序管理，而不是程序员管理，所以叫做控制反转。

  - Bean？

    - 概念1：**Bean容器**，或称spring ioc容器，主要用来管理对象和依赖，以及依赖的注入。
    - 概念2：bean是一个**Java对象**，根据bean规范编写出来的类，并由bean容器生成的对象就是一个bean。
    - 概念3：bean规范。

    ![img](https://www.awaimai.com/wp-content/uploads/2018/11/ioc-bean.png)

    bean规范如下：

    1. 所有属性为private
    2. 提供默认构造方法
    3. 提供getter和setter
    4. 实现serializable接口

- Spring中自动装配的方式

  - no：不进行自动装配，手动设置Bean的依赖关系。
  - byName：根据Bean的名字进行自动装配。
  - byType：根据Bean的类型进行自动装配。
  - constructor：类似于byType，不过是应用于构造器的参数，如果正好有一个Bean与构造器的参数类型相同则可以自动装配，否则会导致错误。
  - autodetect：如果有默认的构造器，则通过constructor的方式进行自动装配，否则使用byType的方式进行自动装配。

  自动装配没有自定义装配方式那么精确，而且不能自动装配简单属性（基本类型、字符串等），在使用时应注意。

  > [https://blog.csdn.net/topwqp/article/details/8686025](<https://blog.csdn.net/topwqp/article/details/8686025>)

  1：no   默认的方式是不进行自动装配，通过手工设置ref 属性来进行装配bean

  2：byName   通过参数名 自动装配，如果一个bean的name 和另外一个bean的 property 相同，就自动装配。

  3：byType   通过参数的数据类型自动自动装配，如果一个bean的数据类型和另外一个bean的property属性的数据类型兼容，就自动装配

  4：construct   构造方法中的参数通过byType的形式，自动装配。

  5：autodetect   如果有默认的构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。用于spring2.5 ，spring3.0测试不通过，估计是废弃了。

  **一： auto-wire  : no(默认方式)**

  首先定义测试需要的类：

  ```java
  package com.myapp.core.autowire;
   
  public class Book {
     public  String  toString(){
  	   return   "I'm  a book, read  me......";
     }
  }
  ```

  ```java
  package com.myapp.core.autowire;
   
  public class Person {
    
  	private  Book book;
  	
  	public  Person(Book book){
  		this.book= book;
  	}
  	
  	public void  setBook(Book book){
  		this.book = book;
  	}
  	
  	public  String  toString(){
  		return  "I'm  a person  I want  to  read  a book   "+ book;
  	}
  	
  	public Person(){
  		
  	}
  }
  ```

  默认方式配置：

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans
             http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
   
    <!-- more bean definitions for data access objects go here -->
    
    <bean id="person" class="com.myapp.core.autowire.Person">
     <property name="book" ref="book" />
    </bean>
    
    <bean  id="book" class="com.myapp.core.autowire.Book"></bean>
    
  </beans>
  ```

  编写测试类：

  ```java
  com.myapp.core.autowire;
   
  import org.springframework.context.ApplicationContext;
  import org.springframework.context.support.ClassPathXmlApplicationContext;
   
  public class MainTest {
  	
  	 public static void main(String[] args) {
  		
  		 ApplicationContext  context  = new ClassPathXmlApplicationContext("resource/autowire.xml");
  		 
  		 Person   person =  (Person)context.getBean("person");
  		 
  		 System.out.println(person.toString());
  	}
    
  }
  ```

  **二：通过byName 自动装配：**

  修改配置文件如下：

  在这个例子中通过bean的属性名自动装配；因为这个 person bean的属性 book和配置文件中id为book的名字相同，所以Spring将通过setBook(Book book)自动装配。

  ```xml
  <!-- byName -->
  <bean id="person" class="com.myapp.core.autowire.Person" autowire="byName"></bean>
  <bean id="book" class="com.myapp.core.autowire.Book"></bean>
  ```

  **三：通过byType自动装配：**

  在这个例子中通过bean的属性名的类型进行自动装配；因为 person bean属性 book的类型和配置文件中id为book的类型相同，所以spring通过setBook(Book  book)自动装配。

  修改配置文件如下：

  ```xml
  <!-- byType -->
  <bean id="person" class="com.myapp.core.autowire.Person" autowire="byType"/>
  <bean id="book" class="com.myapp.core.autowire.Book"></bean>
  ```

  **四：通过construct自动装配：**

  通过构造方法的参数的数据类型进行自动装配，在这个例子中因为person的构造方法参数是Book类型，和配置文件中的id为book的类型相同，所以spring通过Person(Book book)构造方法进行自动装配。

  修改配置文件如下：

  ```xml
  <!-- construct -->
  <bean id="person" class="com.myapp.core.autowire.Person" autowire="constructor"/>
  <bean id="book" class="com.myapp.core.autowire.Book"></bean>
  ```

  **五：通过 autodetect 自动装配：**

  Spring 3.0配置的xml不能用于autodetect，spring3.0应该是去掉了这个功能，改用spring2.5配置可以顺利通过测试。

  首先使用construct的自动装配形式进行装配，如果没有construct就通过 byType的形式进行自动装配。

  ```xml
  <beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
  http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">
      
    <bean id="person" class="com.myapp.core.autowire.Person"   autowire="autodetect"/>
    <bean id="book" class="com.myapp.core.autowire.Book"></bean>
    
  </beans>
  ```

  总结：

  自动装配不容易看出bean之间的引用关系，增加了阅读的复杂度，一般还是采用默认的方式手工进行配置，或者采用annotation的方式进行配置。

- Spring中Bean的作用域有哪些？

  在Spring的早期版本中，仅有两个作用域：singleton和prototype，前者表示Bean以单例的方式存在；后者表示每次从容器中调用Bean时，都会返回一个新的实例，prototype通常翻译为原型。

  设计模式中的创建型模式中也有一个原型模式，原型模式也是一个常用的模式，例如做一个室内设计软件，所有的素材都在工具箱中，而每次从工具箱中取出的都是素材对象的一个原型，可以通过对象克隆来实现原型模式。

  Spring 2.x中针对WebApplicationContext新增了3个作用域，分别是：request（每次HTTP请求都会创建一个新的Bean）、session（同一个HttpSession共享同一个Bean，不同的HttpSession使用不同的Bean）和globalSession（同一个全局Session共享一个Bean）。

  单例模式和原型模式都是重要的设计模式。一般情况下，无状态或状态不可变的类适合使用单例模式。在传统开发中，由于DAO持有Connection这个非线程安全对象因而没有使用单例模式；但在Spring环境下，所有DAO类对可以采用单例模式，因为Spring利用AOP和Java API中的ThreadLocal对非线程安全的对象进行了特殊处理。

- Spring中BeanFactory和ApplicationContext的区别

  > [https://blog.csdn.net/pseudonym_/article/details/72826059](<https://blog.csdn.net/pseudonym_/article/details/72826059>)

  **1. 两者的大概背景**
  BeanFactory：
   **BeanFactory是spring中比较原始，比较古老的Factory。因为比较古老，所以BeanFactory无法支持spring插件，例如：AOP、Web应用等功能。**

  ApplicationContext
    **ApplicationContext是BeanFactory的子类**，因为古老的BeanFactory无法满足不断更新的spring的需求，于是ApplicationContext就基本上代替了BeanFactory的工作，以一种更面向框架的工作方式以及对上下文进行分层和实现继承，并在这个基础上对功能进行扩展：
  <1>MessageSource, 提供国际化的消息访问
  <2>资源访问（如URL和文件）
  <3>事件传递
  <4>Bean的自动装配
  <5>各种不同应用层的Context实现

  **2. 利用BeanFactory获取bean**

  ```java
  //XmlBeanFactory是典型的BeanFactory。
  BeanFactory factory = new XmlBeanFactory("XXX.xml");
  //获取一个叫做mdzz的bean。在这个时候进行实例化。
  factory.getBean("mdzz");
  ```

   重点：**当我们使用BeanFactory去获取Bean的时候，我们只是实例化了该容器，而该容器中的bean并没有被实例化。当我们getBean的时候，才会实时实例化该bean对象。**

  **3. 利用ApplicationContext获取bean**

  ```java
  //当我们实例化XXX.xml的时候，该文件中配置的bean都会被实例化。（该bean scope是singleton）
  ApplicationContext appContext = new ClassPathXmlApplicationContext("XXX.xml");
  ```

   重点：**当我们使用ApplicationContext去获取bean的时候，在加载XXX.xml的时候，会创建所有的配置bean。**

  **4. 三种获取ApplicationContext对象引用的方法**

  ```java
  //第一种加载方法，加载的是classpath下的配置文件。
  ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");
  //第二种加载方法，加载的是磁盘路径下的文件。
  ApplicationContext applicationContext = new FileSystemXmlApplicationContext("applicationContext.xml");
  //第三种加载方法，XmlWebApplicationContext，从web系统中加载。
  
  //得到配置文件后，就能拿到想要的对象。例如：
  HelloService helloService = (HelloService) applicationContext.getBean("userService");
  //在这当中getBean中的参数为你在配置文件下，这个对象的id，一个标识。123456789
  ```

  **5. 区别总结**
  <1>如果使用ApplicationContext，如果配置的bean是singleton，那么不管你有没有或想不想用它，它都会被实例化。好处是可以预先加载，坏处是浪费内存。
  <2>BeanFactory，当使用BeanFactory实例化对象时，配置的bean不会马上被实例化，而是等到你使用该bean的时候（getBean）才会被实例化。好处是节约内存，坏处是速度比较慢。多用于移动设备的开发。
  <3>没有特殊要求的情况下，应该使用ApplicationContext完成。因为BeanFactory能完成的事情，ApplicationContext都能完成，并且提供了更多接近现在开发的功能。

- 什么是IoC和DI？DI是如何实现的？

  IoC叫控制反转，是Inversion of Control的缩写，DI（Dependency Injection）叫依赖注入，是对IoC更简单的诠释。**控制反转是把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的"控制反转"就是对组件对象控制权的转移，从程序代码本身转移到了外部容器，由容器来创建对象并管理对象之间的依赖关系。**IoC体现了好莱坞原则 - "Don’t call me, we will call you"。依赖注入的基本原则是应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由容器负责，查找资源的逻辑应该从应用组件的代码中抽取出来，交给容器来完成。DI是对IoC更准确的描述，即组件之间的依赖关系由容器在运行期决定，形象的来说，即**由容器动态的地将某种依赖关系注入到组件之中**。

  一个类A需要用到接口B中的方法，那么就需要为类A和接口B建立关联或依赖关系，最原始的方法是在类A中创建一个接口B的实现类C的实例，但这种方法需要开发人员自行维护二者的依赖关系，也就是说当依赖关系发生变动的时候需要修改代码并重新构建整个系统。如果通过一个容器来管理这些对象以及对象的依赖关系，则只需要在类A中定义好用于关联接口B的方法（构造器或setter方法），将类A和接口B的实现类C放入容器中，通过对容器的配置来实现二者的关联。

  依赖注入可以通过setter方法注入（设值注入）、构造器注入和接口注入三种方式来实现，Spring支持**setter注入**和**构造器注入**，通常使用构造器注入来注入必须的依赖关系，对于可选的依赖关系，则setter注入是更好的选择，setter注入需要类提供无参构造器或者无参的静态工厂方法来创建对象。

- 依赖注入的方式有哪几种？这些方法如何使用？

- @Controller和@RestController的区别

  @RestController注解相当于@ResponseBody ＋ @Controller合在一起的作用。

- 在以前的学习中有使用过Spring里面的注解吗？如果有请谈一下autowired 和resource区别是什么？

  1、共同点

  两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。

  2、不同点

  （1）@Autowired

  @Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照byType注入。

  **@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。**

  （2）@Resource

  **@Resource默认按照ByName自动注入**，由J2EE提供，需要导入包javax.annotation.Resource。**@Resource有两个重要的属性：name和type，Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。**

- bean的生命周期

  > [https://www.zhihu.com/question/38597960](<https://www.zhihu.com/question/38597960>)

  对于普通的Java对象，当new的时候创建对象，当它没有任何引用的时候被垃圾回收机制回收。而由Spring IoC容器托管的对象，它们的生命周期完全由容器控制。Spring中每个Bean的生命周期如下：

  ![img](https://pic1.zhimg.com/80/v2-baaf7d50702f6d0935820b9415ff364c_hd.jpg)



  1. **实例化Bean**

     对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚未初始化的依赖时，容器就会调用createBean进行实例化。
     对于ApplicationContext容器，当容器启动结束后，便实例化所有的bean。
     容器通过获取BeanDefinition对象中的信息进行实例化。并且这一步仅仅是简单的实例化，并未进行依赖注入。
     实例化对象被包装在BeanWrapper对象中，BeanWrapper提供了设置对象属性的接口，从而避免了使用反射机制设置属性。

  2. **设置对象属性（依赖注入）**

     实例化后的对象被封装在BeanWrapper对象中，并且此时对象仍然是一个原生的状态，并没有进行依赖注入。
     紧接着，Spring根据BeanDefinition中的信息进行依赖注入。
     并且通过BeanWrapper提供的设置属性的接口完成依赖注入。

  3. 注入Aware接口

     紧接着，Spring会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给bean。

  4. **BeanPostProcessor**

     当经过上述几个步骤后，bean对象已经被正确构造，但如果你想要对象被使用前再进行一些自定义的处理，就可以通过BeanPostProcessor接口实现。
     该接口提供了两个函数：

     - postProcessBeforeInitialzation( Object bean, String beanName )
       当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理。
       这个函数会先于InitialzationBean执行，因此称为前置处理。
       所有Aware接口的注入就是在这一步完成的。
     - postProcessAfterInitialzation( Object bean, String beanName )
       当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理。
       这个函数会在InitialzationBean完成后执行，因此称为后置处理。

  5. **InitializingBean与init-method**

     **当BeanPostProcessor的前置处理完成后就会进入本阶段。**
     InitializingBean接口只有一个函数：

     - afterPropertiesSet()

       这一阶段也可以在bean正式构造完成前增加我们自定义的逻辑，但它与前置处理不同，由于该函数并不会把当前bean对象传进来，因此在这一步没办法处理对象本身，只能增加一些额外的逻辑。
       若要使用它，我们需要让bean实现该接口，并把要增加的逻辑写在该函数中。然后Spring会在前置处理完成后检测当前bean是否实现了该接口，并执行afterPropertiesSet函数。

       当然，Spring为了降低对客户代码的侵入性，给bean的配置提供了init-method属性，该属性指定了在这一阶段需要执行的函数名。Spring便会在初始化阶段执行我们设置的函数。init-method本质上仍然使用了InitializingBean接口。

  6. **DisposableBean和destroy-method**

     和init-method一样，通过给destroy-method指定函数，就可以在bean销毁前执行指定的逻辑。

- 请简要说明一下IOC和AOP是什么？

  > [https://blog.csdn.net/bieleyang/article/details/78339361](<https://blog.csdn.net/bieleyang/article/details/78339361>)

  什么是DI机制？

  依赖注入（Dependecy Injection）和控制反转（Inversion of Control）是同一个概念，具体的讲：当某个角色 需要另外一个角色协助的时候，在传统的程序设计过程中，通常由调用者来创建被调用者的实例。但在spring中 创建被调用者的工作不再由调用者来完成，因此称为控制反转。创建被调用者的工作由spring来完成，然后注入调用者 因此也称为依赖注入。 spring以动态灵活的方式来管理对象 ， 注入的两种方式，设置注入和构造注入。 设置注入的优点：直观，自然 构造注入的优点：可以在构造器中决定依赖关系的顺序。

  什么是AOP？

  面向切面编程（AOP）完善spring的依赖注入（DI），面向切面编程在spring中主要表现为两个方面
  1.面向切面编程提供声明式事务管理
  2.spring支持用户自定义的切面

  面向切面编程（aop）是对面向对象编程（oop）的补充，
  面向对象编程将程序分解成各个层次的对象，面向切面编程将程序运行过程分解成各个切面。
  AOP从程序运行角度考虑程序的结构，提取业务处理过程的切面，oop是静态的抽象，aop是动态的抽象，
  是对应用执行过程中的步骤进行抽象，，从而获得步骤之间的逻辑划分。

- Spring支持的事务管理类型有哪些？你在项目中会使用哪种方式？

  Spring支持**编程式事务管理**和**声明式事务管理**。许多Spring框架的用户选择声明式事务管理，因为这种方式和应用程序的关联较少，因此更加符合轻量级容器的概念。声明式事务管理要优于编程式事务管理，尽管在灵活性方面它弱于编程式事务管理，因为编程式事务允许你通过代码控制业务。

  事务分为全局事务和局部事务。全局事务由应用服务器管理，需要底层服务器JTA支持（如WebLogic、WildFly等）。局部事务和底层采用的持久化方案有关，例如使用JDBC进行持久化时，需要使用Connetion对象来操作事务；而采用Hibernate进行持久化时，需要使用Session对象来操作事务。

  这些事务的父接口都是PlatformTransactionManager。Spring的事务管理机制是一种典型的策略模式，PlatformTransactionManager代表事务管理接口，该接口定义了三个方法，该接口并不知道底层如何管理事务，但是它的实现类必须提供getTransaction()方法（开启事务）、commit()方法（提交事务）、rollback()方法（回滚事务）的多态实现，这样就可以用不同的实现类代表不同的事务管理策略。使用JTA全局事务策略时，需要底层应用服务器支持，而不同的应用服务器所提供的JTA全局事务可能存在细节上的差异，因此实际配置全局事务管理器是可能需要使用JtaTransactionManager的子类，如：WebLogicJtaTransactionManager（Oracle的WebLogic服务器提供）、UowJtaTransactionManager（IBM的WebSphere服务器提供）等。

- 你如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？

  a. **连接点**（Joinpoint）：**程序执行的某个特定位置（如：某个方法调用前、调用后，方法抛出异常后）。一个类或一段程序代码拥有一些具有边界性质的特定点，这些代码中的特定点就是连接点。**Spring仅支持方法的连接点。

  b. **切点**（Pointcut）：**如果连接点相当于数据中的记录，那么切点相当于查询条件，一个切点可以匹配多个连接点。**Spring AOP的规则解析引擎负责解析切点所设定的查询条件，找到对应的连接点。

  c. **增强**（Advice）：**增强是织入到目标类连接点上的一段程序代码。**Spring提供的增强接口都是带方位名的，如：BeforeAdvice、AfterReturningAdvice、ThrowsAdvice等。*

  d. 引介（Introduction）：引介是一种特殊的增强，它为类添加一些属性和方法。这样，即使一个业务类原本没有实现某个接口，通过引介功能，可以动态的未该业务类添加接口的实现逻辑，让业务类成为这个接口的实现类。

  e. 织入（Weaving）：织入是将增强添加到目标类具体连接点上的过程，AOP有三种织入方式：①编译期织入：需要特殊的Java编译期（例如AspectJ的ajc）；②装载期织入：要求使用特殊的类加载器，在装载类的时候对类进行增强；③运行时织入：在运行时为目标类生成代理实现增强。Spring采用了动态代理的方式实现了运行时织入，而AspectJ采用了编译期织入和装载期织入的方式。

  f. **切面**（Aspect）：**切面是由切点和增强（引介）组成的**，它包括了对横切关注功能的定义，也包括了对连接点的定义。

- AOP的原理是什么？

  > Java核心面试知识整理

  Spring 提供了两种方式来生成代理对象: JDKProxy 和Cglib，具体使用哪种方式生成由AopProxyFactory 根据AdvisedSupport 对象的配置来决定。默认的策略是如果目标类是接口，则使用JDK 动态代理技术，否则使用Cglib 来生成代理。

  - JDK动态接口代理

    JDK 动态代理主要涉及到java.lang.reflect 包中的两个类：Proxy 和InvocationHandler。InvocationHandler 是一个接口，通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态将横切逻辑和业务逻辑编制在一起。Proxy 利用InvocationHandler 动态创建一个符合某一接口的实例，生成目标类的代理对象。
  
  - CGLib 动态代理

    CGLib 全称为Code Generation Library，是一个强大的高性能，高质量的代码生成类库，可以在运行期扩展Java 类与实现Java 接口，CGLib 封装了asm，可以再运行期动态生成新的class。和JDK 动态代理相比较：JDK 创建代理有一个限制，就是只能为接口创建代理实例，而对于没有通过接口定义业务方法的类，则可以通过CGLib 创建动态代理。

  > [https://juejin.im/post/5bf4fc84f265da611b57f906](<https://juejin.im/post/5bf4fc84f265da611b57f906>)

  **AOP简介**

  相信大家或多或少的了解过AOP，都知道它是面向切面编程，在网上搜索可以找到很多的解释。这里我用一句话来总结：AOP是能够让我们在不影响原有功能的前提下，为软件横向扩展功能。 那么横向扩展怎么理解呢，我们在WEB项目开发中，通常都遵守三层原则，包括控制层（Controller）->业务层（Service）->数据层（dao）,那么从这个结构下来的为纵向，它具体的某一层就是我们所说的横向。我们的AOP就是可以作用于这某一个横向模块当中的所有方法。

  我们在来看一下AOP和OOP的区别：AOP是OOP的补充，当我们需要为多个对象引入一个公共行为，比如日志，操作记录等，就需要在每个对象中引用公共行为，这样程序就产生了大量的重复代码，使用AOP可以完美解决这个问题。

  接下来介绍一下提到AOP就必须要了解的知识点：

  - 切面：拦截器类，其中会定义切点以及通知

  - 切点：具体拦截的某个业务点。

  - 通知：切面当中的方法，声明通知方法在目标业务层的执行位置，通知类型如下：

    1. 前置通知：@Before 在目标业务方法执行之前执行
    
    2. 后置通知：@After 在目标业务方法执行之后执行
    
    3. 返回通知：@AfterReturning 在目标业务方法返回结果之后执行
    
    4. 异常通知：@AfterThrowing 在目标业务方法抛出异常之后
    
    5. 环绕通知：@Around 功能强大，可代替以上四种通知，还可以控制目标业务方法是否执行以及何时执行

  **代码中实现举例**

  上面已经大概的介绍了AOP中需要了解的基本知识，也知道了AOP的好处，那怎么在代码中实现呢？给大家举个例子：我们现在有个学校管理系统，已经实现了对老师和学生的增删改，又新来个需求，说是对老师和学生的每次增删改做一个记录，到时候校长可以查看记录的列表。那么问题来了，怎么样处理是最好的解决办法呢？这里我罗列了三种解决办法，我们来看下他的优缺点。

  ![img](https://user-gold-cdn.xitu.io/2018/11/21/167357a2851d2cfc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

  最简单的就是第一种方法，我们直接在每次的增删改的函数当中直接实现这个记录的方法，这样代码的重复度太高，耦合性太强，不建议使用。

  其次就是我们最长使用的，将记录这个方法抽离出来，其他的增删改调用这个记录函数即可，显然代码重复度降低，但是这样的调用还是没有降低耦合性。

  这个时候我们想一下AOP的定义，再想想我们的场景，其实我们就是要在不改变原来增删改的方法，给这个系统增加记录的方法，而且作用的也是一个层面的方法。这个时候我们就可以采用AOP来实现了。

  我们来看下代码的具体实现：

  1. 首先我定义了一个自定义注解作为切点
  ```java
  @Target(AnnotationTarget.FUNCTION)  //注解作用的范围，这里声明为函数
  @Order(Ordered.HIGHEST_PRECEDENCE)  //声明注解的优先级为最高，假设有多个注解，先执行这个
  annotation class Hanler(val handler: HandlerType)  //自定义注解类，HandlerType是一个枚举类型，里面定义的就是学生和老师的增删改操作，在这里就不展示具体内容了
  ```

  2. 接下来就是要定义切面类了
  ```java
  @Aspect   //该注解声明这个类为一个切面类
  @Component
  class HandlerAspect{
  
      @Autowired
      private lateinit var handlerService: HandlerService
  
      @AfterReturning("@annotation(handler)")   //当有函数注释了注解，将会在函数正常返回后在执行我们定义的方法
      fun hanler(hanler: Hanler) {
          handlerService.add(handler.operate.value)   //这里是真正执行记录的方法
      }
  }
  ```

  3. 最后就是我们本来的业务方法了
  ```java
  /**
  * 删除学生方法
  */
  @Handler(operate= Handler.STUDENT_DELETE)   //当执行到删除学生方法时，切面类就会起作用了,当学生正常删除后就会执行记录方法，我们就可以看到记录方法生成的数据
  fun delete(id：String) {
    studentService.delete(id)
  }
  ```

  **AOP实现原理**

  我们现在了解了代码中如何实现，那么AOP实现的原理是什么呢？之前看了一个博客说到，提到AOP大家都知道他的实现原理是动态代理，显然我之前就是不知道的，哈哈，但是相信阅读文章的你们一定是知道的。

  讲到动态代理就不得不说代理模式了， 代理模式的定义：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式包含如下角色：subject：抽象主题角色，是一个接口。该接口是对象和它的代理共用的接口; RealSubject：真实主题角色，是实现抽象主题接口的类; Proxy:代理角色，内部含有对真实对象RealSubject的引用，从而可以操作真实对象。代理对象提供与真实对象相同的接口，以便代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。如下图所示：

  ![img](https://user-gold-cdn.xitu.io/2018/11/22/1673a262814cef3e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

  ![img](https://user-gold-cdn.xitu.io/2018/11/22/1673a2653b02d775?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

  那么代理又分为静态代理和动态代理，这里写两个小的demo，动态代理采用的就是JDK代理。举个例子就是现在一个班上的学生需要交作业，现在由班长代理交作业，那么班长就是代理，学生就是被代理的对象。

  - 静态代理

    首先，我们创建一个Person接口。这个接口就是学生（被代理类），和班长（代理类）的公共接口，他们都有交作业的行为。这样，学生交作业就可以让班长来代理执行。

    ```java
    /**
     * Created by Mapei on 2018/11/7
     * 创建person接口
     */
    public interface Person {
        //交作业
        void giveTask();
    }
    ```

    Student类实现Person接口，Student可以具体实施交作业这个行为。

    ```java
    /**
     * Created by Mapei on 2018/11/7
     */
    public class Student implements Person {
        private String name;
        public Student(String name) {
            this.name = name;
        }

        public void giveTask() {
            System.out.println(name + "交语文作业");
        }
    }
    ```

    StudentsProxy类，这个类也实现了Person接口，但是还另外持有一个学生类对象，那么他可以代理学生类对象执行交作业的行为。

    ```java
    /**
     * Created by Mapei on 2018/11/7
     * 学生代理类，也实现了Person接口，保存一个学生实体，这样就可以代理学生产生行为
     */
    public class StudentsProxy implements Person{
        //被代理的学生
        Student stu;

        public StudentsProxy(Person stu) {
            // 只代理学生对象
            if(stu.getClass() == Student.class) {
                this.stu = (Student)stu;
            }
        }

        //代理交作业，调用被代理学生的交作业的行为
        public void giveTask() {
            stu.giveTask();
        }
    }
    ```

    下面测试一下，看代理模式如何使用：

    ```java
    /**
     * Created by Mapei on 2018/11/7
     */
    public class StaticProxyTest {
        public static void main(String[] args) {
            //被代理的学生林浅，他的作业上交有代理对象monitor完成
            Person linqian = new Student("林浅");

            //生成代理对象，并将林浅传给代理对象
            Person monitor = new StudentsProxy(linqian);

            //班长代理交作业
            monitor.giveTask();
        }
    }
    ```

    这里并没有直接通过林浅（被代理对象）来执行交作业的行为，而是通过班长（代理对象）来代理执行了。这就是代理模式。代理模式就是在访问实际对象时引入一定程度的间接性，这里的间接性就是指不直接调用实际对象的方法，那么我们在代理过程中就可以加上一些其他用途。比如班长在帮林浅交作业的时候想告诉老师最近林浅的进步很大，就可以轻松的通过代理模式办到。在代理类的交作业之前加入方法即可。这个优点就可以运用在spring中的AOP，我们能在一个切点之前执行一些操作，在一个切点之后执行一些操作，这个切点就是一个个方法。这些方法所在类肯定就是被代理了，在代理过程中切入了一些其他操作。

  - 动态代理

    动态代理和静态代理的区别是，静态代理的的代理类是我们自己定义好的，在程序运行之前就已经变异完成，但是动态代理的代理类是在程序运行时创建的。相比于静态代理，动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。比如我们想在每个代理方法之前都加一个处理方法，我们上面的例子中只有一个代理方法，如果还有很多的代理方法，就太麻烦了，我们来看下动态代理是怎么去实现的。

    首先还是定义一个Person接口:

    ```java
    /**
     * Created by Mapei on 2018/11/7
     * 创建person接口
     */
    public interface Person {
        //交作业
        void giveTask();
    }
    ```

    接下来是创建需要被代理的实际类，也就是学生类：

    ```java
    /**
     * Created by Mapei on 2018/11/7
     */
    public class Student implements Person {
        private String name;
        public Student(String name) {
            this.name = name;
        }

        public void giveTask() {
            System.out.println(name + "交语文作业");
        }
    }
    ```

    创建StuInvocationHandler类，实现InvocationHandler接口，这个类中持有一个被代理对象的实例target。InvocationHandler中有一个invoke方法，所有执行代理对象的方法都会被替换成执行invoke方法。

    ```java
    /**
     * Created by Mapei on 2018/11/7
     */
    public class StuInvocationHandler<T> implements InvocationHandler {
        //invocationHandler持有的被代理对象
        T target;

        public StuInvocationHandler(T target) {
            this.target = target;
        }

        /**
        * proxy:代表动态代理对象
        * method：代表正在执行的方法
        * args：代表调用目标方法时传入的实参
        */
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            System.out.println("代理执行" +method.getName() + "方法");
            Object result = method.invoke(target, args);
            return result;
        }
    }
    ```

    那么接下来我们就可以具体的创建代理对象了。

    ```java
    /**
     * Created by Mapei on 2018/11/7
     * 代理类
     */
    public class ProxyTest {
        public static void main(String[] args) {

            //创建一个实例对象，这个对象是被代理的对象
            Person linqian = new Student("林浅");

            //创建一个与代理对象相关联的InvocationHandler
            InvocationHandler stuHandler = new StuInvocationHandler<Person>(linqian);

            //创建一个代理对象stuProxy来代理linqian，代理对象的每个执行方法都会替换执行Invocation中的invoke方法
            Person stuProxy = (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class<?>[]{Person.class}, stuHandler);

            //代理执行交作业的方法
            stuProxy.giveTask();
        }
    }
    ```

    我们执行代理测试类，首先我们创建了一个需要被代理的学生林浅，将林浅传入stuHandler中，我们在创建代理对象stuProxy时，将stuHandler作为参数，那么所有执行代理对象的方法都会被替换成执行invoke方法，也就是说，最后执行的是StuInvocationHandler中的invoke方法。所以在看到下面的运行结果也就理所当然了。

- aop的应用场景有哪些？

  > [https://zhuanlan.zhihu.com/p/83204146](https://zhuanlan.zhihu.com/p/83204146)

  **为什么会有面向切面编程（AOP）？**

  我们知道Java是一个面向对象（OOP）的语言，但它有一些弊端，比如当我们需要为多个不具有继承关系的对象引入一个公共行为，例如日志、权限验证、事务等功能时，只能在在每个对象里引用公共行为。这样做不便于维护，而且有大量重复代码。AOP的出现弥补了OOP的这点不足。

  **Spring AOP 中设计的一些核心知识，面试问题？**

  1、能说一下Spring AOP用的是哪种设计模式？

  回答：代理模式。

  2、 能简单聊一下你对代理模式的理解吗？

  代理模式 balabala......，记住一些贴近日常的示例方便理解，如买火车票，Windows 里面的快捷方式...

  3、 知道JDK代理和Cglib代理有什么区别？

  我们不需要创建代理类，JDK 在运行时为我们动态的来创建，JDK代理是接口 balabala

  若目标类不存在接口,则使用Cglib生成代理，balabala

  不管是JDK代理还是Cglib代理本质上都是对字节码进行操作，balabala

  4、让你实现一个JDK实现动态代理？你的思路是什么？

  照葫芦画瓢，照猫画虎。

  Proxy: 定义一个自己的Proxy类

  InvocationHandler：定义一个自己的InvocationHandler类

  ClassLoad：自定义类加载器（方便加载我们自己指定的路径下面的类）

  **SpringAOP的在实际应用中场景有哪些？**

  1. Authentication 权限
  2. Caching 缓存
  3. Context passing 内容传递
  4. Error handling 错误处理
  5. Lazy loading 懒加载
  6. Debugging 调试
  7. logging，tracing，profiling and monitoring 记录跟踪 优化 校准
  8. Performance optimization 性能优化
  9. Persistence 持久化
  10. Resource pooling 资源池
  11. Synchronization 同步
  12. Transactions 事务
  13. Logging 日志

- Spring框架为企业级开发带来的好处有哪些？

  - 非侵入式：支持基于POJO的编程模式，不强制性的要求实现Spring框架中的接口或继承Spring框架中的类。
  
  - IoC容器：IoC容器帮助应用程序管理对象以及对象之间的依赖关系，对象之间的依赖关系如果发生了改变只需要修改配置文件而不是修改代码，因为代码的修改可能意味着项目的重新构建和完整的回归测试。有了IoC容器，程序员再也不需要自己编写工厂、单例，这一点特别符合Spring的精神"不要重复的发明轮子"。
  
  - AOP（面向切面编程）：将所有的横切关注功能封装到切面（aspect）中，通过配置的方式将横切关注功能动态添加到目标代码上，进一步实现了业务逻辑和系统服务之间的分离。另一方面，有了AOP程序员可以省去很多自己写代理类的工作。
  
  - MVC：Spring的MVC框架为Web表示层提供了更好的解决方案。
  
  - 事务管理：Spring以宽广的胸怀接纳多种持久层技术，并且为其提供了声明式的事务管理，在不需要任何一行代码的情况下就能够完成事务管理。
  
  - 其他：选择Spring框架的原因还远不止于此，Spring为Java企业级开发提供了一站式选择，你可以在需要的时候使用它的部分和全部，更重要的是，甚至可以在感觉不到Spring存在的情况下，在你的项目中使用Spring提供的各种优秀的功能。

- spring框架的优点都有哪些？

  Spring是一个轻量级的DI和AOP容器框架，在项目的中的使用越来越广泛，它的优点主要有以下几点：

  Spring是一个非侵入式框架，其目标是使应用程序代码对框架的依赖最小化，应用代码可以在没有Spring或者其他容器的情况运行。

  Spring提供了一个一致的编程模型，使应用直接使用POJO开发，从而可以使运行环境隔离开来。

  Spring推动应用的设计风格向面向对象及面向接口编程转变，提高了代码的重用性和可测试性。

  Spring改进了结构体系的选择，虽然作为应用平台，Spring可以帮助我们选择不同的技术实现，比如从Hibernate切换到其他的ORM工具，从Struts切换到Spring MVC,尽管我们通常不会这么做，但是我们在技术方案上选择使用Spring作为应用平台，Spring至少为我们提供了这种可能性的选择，从而降低了平台锁定风险。

- Struts拦截器和Spring AOP有什么区别？

  拦截器是AOP的一种实现，struts2 拦截器采用xwork2的interceptor！而spring的AOP基于IoC基础,其底层采用动态代理与CGLIB代理两种方式结合的实现方式。

- 请简单介绍一下spring？

  Spring是一个轻量级框架，可以一站式构建你的企业级应用。

  Spring的模块大概分为6个。分别是：

  1、Core Container（Spring的核心）【重要】

  2、AOP（面向切面变成）【重要】

  3、Messaging（消息发送的支持）

  4、Data Access/Integration（数据访问和集成）

  5、Web（主要是SpringWeb内容，包括MVC）【重要】

  6、Test（Spring测试支持，包含JUint等测试单元的支持） 7、Instrumentation（设备支持，比如Tomcat的支持）

- 持久层设计要考虑的问题有哪些？请谈一下你用过的持久层框架都有哪些？

  所谓"持久"就是将数据保存到可掉电式存储设备中以便今后使用，简单的说，就是将内存中的数据保存到关系型数据库、文件系统、消息队列等提供持久化支持的设备中。持久层就是系统中专注于实现数据持久化的相对独立的层面。

  持久层设计的目标包括：
  - 数据存储逻辑的分离，提供抽象化的数据访问接口。
  - 数据访问底层实现的分离，可以在不修改代码的情况下切换底层实现。
  - 资源管理和调度的分离，在数据访问层实现统一的资源调度（如缓存机制）。
  - 数据抽象，提供更面向对象的数据操作。

  持久层框架有：
  - Hibernate
  - MyBatis
  - TopLink
  - Guzz
  - jOOQ
  - Spring Data
  - ActiveJDBC

## 网络

## 操作系统

- 什么是死锁？

  > 王道操作系统P114

  **死锁是指多个进程因竞争资源而造成一种僵局（互相等待）**，若无外力作用，这些进程都无法向前推进。

  例如，某计算机系统只有一台答应及和一台输入设备，进程P1正占用输入设备，同时又提出使用答应及的请求，但此时打印机正被进程P2所占用，而P2在未释放打印机之前，又提出请求使用正被P1占用着的输入设备。这样两个进程相互无休止地进行下去，均无法继续执行，此时两个进程陷入死锁状态。

  - 死锁预防：破坏死锁产生的四个必要条件，只要其中任一条件不成立，死锁就不会发生。

    - **互斥条件**：进程要求对锁分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占用。此时若有其他进程请求该资源，则请求进程只能等待。

    - **不剥夺条件**：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放）。

    - **请求和保持条件**：进程已经保持了至少一个资源，但由提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。

      为了破坏请求和保持条件，采用预先静态分配方法，即进程在运行前**一次申请完它所需要的全部资源**，在它的资源未满足前，不把它投入运行。

    - **循环等待条件**：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求。

      为了破坏循环等待条件，采用**顺序资源分配法**。首先给系统中的资源编号，规定**每个进程必须按编号递增的顺序请求资源**，同类资源一次申请完。

  - 死锁避免：银行家算法

  - 死锁检测与解除：资源分配图、死锁定理

- JAVA中如何确保N个线程可以访问N个资源，但同时又不导致死锁？

  > [https://www.nowcoder.com/questionTerminal/7192c9454277483d8711a7b4237a0bbe](<https://www.nowcoder.com/questionTerminal/7192c9454277483d8711a7b4237a0bbe>)

  多线程产生死锁需要四个条件，分别是互斥性，保持和请求，不可剥夺性还有要形成闭环，这四个条件缺一不可，只要破坏了其中一个条件就可以破坏死锁，其中最简单的方法就是线程都是以同样的顺序加锁和释放锁，也就是破坏了第四个条件。

## 数据库

## 系统设计

## 工具





