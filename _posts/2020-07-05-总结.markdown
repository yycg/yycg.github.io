---
layout:     post
title:      "总结"
subtitle:   ""
date:       2020-07-05 12:00:00
author:     "盈盈冲哥"
header-img: "img/fleabag.jpg"
mathjax: true
catalog: true
tags:
    - 学习
---

> [https://snailclimb.gitee.io/javaguide/#/?id=java]https://snailclimb.gitee.io/javaguide/#/?id=java

> [https://github.com/hanggegreat/CS-Tree](https://github.com/hanggegreat/CS-Tree)

> [https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#nginx](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#nginx)

## 大型网站技术架构

[大型网站技术架构](https://yycg.github.io/2020/03/05/大型网站技术架构/)

1. 分层：应用层、服务层、数据层

2. 如何优化性能？

    - 缓存：CDN、反向代理、本地缓存、分布式缓存（一致性Hash算法）
    - 均衡负载：分布式（不同服务部署在不同）、集群（多台机器提供相同的服务）
    - 异步（消息队列削峰、线程池）
    - 数据库分库分表、读写分离

3. 分布式缓存的一致性Hash算法

    一致性Hash算法通过一致性Hash环实现key到缓存服务器的Hash映射。

    具体算法过程为：先构造一个长度为$2^32$的整数环（一致性Hash环），根据节点名称的Hash值将缓存服务器节点放置在这个Hash环上。然后根据需要缓存的数据的key值计算得到其Hash值，在Hash环上顺时针查找距离这个key的Hash值最近的缓存服务器节点。

    当缓存服务器集群需要扩容时，只需要将新加入的节点名称的Hash值放入一致性Hash环中，由于key时顺时针查找其最近的节点，因此新加入的节点只影响整个环中的一小段。

4. session管理

  - session复制：在集群中的几台服务器之间同步session对象，使得每台服务器上都保存所有用户的session信息。
  
  - session绑定：负载均衡服务器总是将来源于同一IP的请求分发到同一台服务器上。
  
  - 利用cookie记录session
  
  - session服务器

5. 指标：吞吐量（TPS、QPS、HPS）、响应时间、并发数

6. 安全

	- XSS攻击（跨站点脚本攻击）：注入恶意HTML脚本

    手段：消毒、HTTPOnly

	- SQL注入攻击：攻击者在HTTP请求中注入恶意SQL命令

    手段：关闭错误回显、消毒、参数绑定

	- CSRF攻击（跨站点请求伪造）：攻击者通过跨站请求，以合法的用户身份伪造请求进行非法操作

    手段：表单Token、验证码、Referer check

7. 加密

	- 单项散列加密：MD5, SHA1

    虽然不能通过算法将单向散列密文反算得到密文，但是由于人们设置密码具有一定的模式，因此通过彩虹表（人们常用密码和对应的密文关系表）等手段可以进行猜测式破解。

    为了加强单项散列计算的安全性，还会给散列算法加点盐，盐相当于加密的密钥，增加破解难度。

	- 对称加密：DES、RC

    对称加密是指加密和解密使用的密钥是同一个密钥（或者可以互相推算）。

	- 非对称加密：RSA

    不同于对称加密，非对称加密和解密使用的密钥不是同一密钥，其中一个对外界公开，被称作公钥，另一个只有所有者知道，被称为私钥。用公钥加密的信息必须用私钥才能解开，反之，用私钥加密的信息只有用公钥才能解开。

8. 高可用设计：服务降级、服务限流、超时设置、缓存、异步、幂等性设计

## 幂等
  
[幂等](https://yycg.github.io/2020/07/25/幂等/)

- 概念：一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。

- 我们常用的HTTP协议的方法是具有幂等性语义要求的，比如：get方法用于获取资源，不应有副作用，因此是幂等的；post方法用于创建资源，每次请求都会产生新的资源，因此不具备幂等性；put方法用于更新资源，是幂等的；delete方法用于删除资源，也是幂等的。

- 保证幂等的手段：通过悲观锁、乐观锁、唯一索引、Redis缓存来保证业务单号或者token的唯一性

## 分布式

[分布式](https://yycg.github.io/2020/03/05/分布式/)

## Zookeeper

[Zookeeper](https://yycg.github.io/2020/03/05/Zookeeper/)

## Kafka

[Kafka](https://yycg.github.io/2020/03/05/Kafka/)

## Redis

[Redis](https://yycg.github.io/2020/03/05/Redis/)

## MySQL

[高性能MySQL](https://yycg.github.io/2020/03/05/高性能MySQL/)

[MySQL](https://yycg.github.io/2020/03/05/MySQL/)

## 网络

[网络](https://yycg.github.io/2020/03/05/网络/)

1. OSI七层模型：物理层、数据链路层、网络层、传输层、会话层（会话管理）、表示层（数据格式转换）、应用层

2. ARP协议（网络层）：IP地址->MAC地址

    每个主机都设有一个ARP高速缓存，先查ARP表，如果没有就通过使用目的MAC地址为FF-FF-FF-FF-FF-FF的帧来封装并广播ARP请求分组。

3. TCP和UDP

    TCP提供可靠的面向连接的服务，增加了开销，用于文件传输、发送和接收邮件、远程登录等场景。

    UDP不建立连接，不提供可靠服务，用于语音、视频。

4. TCP为什么可靠一些

    TCP连接管理：三次握手、四次挥手

    TCP可靠传输：累计确认、超时和冗余ACK

    TCP流量控制：发送窗口的实际大小是接受窗口和拥塞窗口的最小值

    TCP拥塞控制：慢开始（指数规模增长）、拥塞避免（加法增大）、快恢复（乘法减小）

5. 滑动窗口的作用

    - 滑动窗口实现面向流的可靠性，只有在收到ACK确认的情况下移动左边界

    - 滑动窗口的流控特性

6. TCP连接和释放过程

    三次握手

    1. 客户机到服务器：SYN
    2. 服务器到客户机：SYN/ACK
    3. 客户机到服务器：ACK

    四次挥手

    1. 客户机到服务器：FIN
    2. 服务器到客户机：ACK
    
        CLOSE_WAIT

    3. 服务器到客户机：FIN/ACK

        TIME_WAIT
    
    4. 客户机到服务器：ACK

    - 为什么A还要发送一次确认呢？

      防止已经失效的连接请求报文段突然又传到了B，因而产生错误，浪费B的资源。
    
    - CLOSE_WAIT：半关闭状态，即A已经没有数据要发送了，但B若发送数据，A仍要接受。

    - TIME_WAIT：为什么A在TIME_WAIT状态必须等待2MSL（最长报文段寿命，建议为2min）？

      1. 为了保证A发送的最后一个ACK报文段能够到达B
      2. 防止已失效的连接请求报文段出现在本连接中
    
7. DNS的寻址过程

    1. 浏览器缓存、DNS缓存
    2. hosts文件
    3. 本地域名服务器分别请求根域名服务器、顶级域名服务器、权限域名服务器
    
        递归查询（比较少用）、迭代查询
    
8. 在浏览器输入url到显示主页的过程：DNS解析、TCP连接、发送HTTP请求、服务器解析渲染页面

9. 状态码

    1XX：信息性状态码

    2XX：成功状态码

    3XX：重定向状态码

    4XX：客户端错误状态码

    5XX：服务端错误状态码

    - **200 OK**：表示从客户端发来的请求在服务端被正常处理了。
    - 201 Created：请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。
    - **202 Accepted**：服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。
    - **204 No Content**：代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。
    - **206 Partial Content**：表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。

    - **301 Moved Permanently**：永久性重定向。表示请求的资源已被分配了新的URL，以后应使用资源现在所指的URL。
    - **302 Found**：临时性重定向。表示请求的资源已被分配了新的URL，希望用户能使用新的URL访问。和301状态码相似，但302状态码代表资源不是被永久移动，只是临时性质的。
    - 304 Not Modified：表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304.

    - **400 Bad Request**：表示请求报文中存在语法错误。
    - **401 Unauthorized**：表示发送的请求需要有通过HTTP认证的认证信息。
    - **403 Forbidden**：对请求资源的访问被服务器拒绝了。
    - **404 Not Found**：表明服务器上无法找到请求的资源。

    - **500 Internal Server Error**：表示服务器端在执行请求时发生了错误。
    - **503 Service Unavailable**：表明服务器暂时处于超负荷或正在进行停机维护，现在无法处理请求。

10. HTTP/1.1默认使用长连接，在响应头加入Connection: keep-alive。在使用长连接的情况下，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭。

11. HTTPS过程

  客户端向服务端发送HTTPS请求，服务端将自己的公钥发送给客户端，客户端利用公钥加密密钥，发起第二个HTTPS请求，将加密之后的密钥发送给服务端，服务端用私钥解密密钥，将加密后的密文发送给客户端，客户端利用密钥解密。

12. HTTP 2.0

  多个请求可同时在一个连接上并行执行。

13. HTTPS与HTTP的区别

  - 传输信息安全性不同
  - 连接方式不同：HTTPS由SSL+HTTP协议构建
  - 端口不同：HTTP 80, HTTPS 443
  - 证书申请方式不同：HTTPS需要到CA申请证书

14. 请求报文的结构

  - 请求行：请求方法GET/POST、URL、协议版本HTTP1.0/HTTP1.1
  - 请求首部：图解HTTP P80
  - 请求主体

  通用首部字段

  - Cache-Control：控制缓存的行为
  - Connection：逐跳首部、连接的管理

  请求首部字段

  - Accept：用户代理可处理的媒体类型
  - Accept-Charset：优先的字符集
  - Accept-Encoding：优先的内容编码
  - Accept-Language：优先的语言（自然语言）
  - Host：请求资源所在服务器
  - Range：实体的字节范围请求
  - Referer：对请求中URL的原始获取方
  - User-Agent：HTTP客户端程序的信息

  响应首部字段

  实体首部字段

  - Content-Encoding：实体主体适用的编码方式
  - Content-Language：实体主体的自然语言
  - Content-Length：实体主体的大小
  - Content-Type：实体主体的媒体类型
  
  非HTTP/1.1首部字段

  - Cookie
  - Set-Cookie

15. GET请求和POST请求

  - GET请求参数在URL中，POST请求在请求主体中
  - GET请求具有幂等性，多次调用和一次调用是一样的，没有副作用

## 设计模式

[大话设计模式](https://yycg.github.io/2020/03/05/大话设计模式/)

[设计模式](https://yycg.github.io/2020/03/05/设计模式/)

1. 面对对象

  - 封装：对象包含它能操作所需的所有信息，包括变量和方法，好处是减少耦合，内部可以自由修改，具有清晰的对外接口。
  - 继承：is-a的关系，父类变子类不得不变，强耦合。
  - 多态：子类以父类的身份出现，调用父类的方法，使用的是子类的实现。

2. 原则

  - 单一职责原则：就一个类而言，应该仅有一个引起它变化的原因。
  - 开放封闭原则：软件实体对于扩展是开放的，对于更改是封闭的。
  - 依赖倒转原则：A.高层模块不应该依赖低层模块，两个都应该依赖抽象。B. 抽象不应该依赖细节，细节应该依赖抽象。
  - 里氏替换原则：子类型必须能够替换掉它们的父类型。
  - 合成/聚合复用原则：尽量使用合成/聚合，尽量不要使用继承。

3. 设计模式

  - 简单工厂模式
  - 工程方法模式：产品接口、工厂接口、具体产品、具体工厂，一个具体工厂生产一个具体产品。
  - 抽象工厂模式：一个具体工厂创建一组具体工厂。
  - 策略模式：上下文类（维护一个对策略的引用），策略类，具体策略类
  - 代理模式：主体类（定义真是主体类和代理类的共同接口），真实主体类，代理类（保存一个引用是的代理可以访问真实主体）
  - 观察者模式（发布-订阅模式）：主体类（可以增加和删除观察者对象）、观察者（再得到主体的通知时更新自己）、具体主体、具体观察者
  - 适配器模式：将一个类的接口转换成客户希望的另一个接口
  - 桥接模式：实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这种多角度分离出来让它们独立变化，减少它们之间的耦合。
  - 单例模式

    ```java
    public class Singleton {
        private volatile static Sinleton uniqueInstance;
        private Singleton() {}
        public static SIngleton getInstance() {
            if (uniqueInstance == null) {
                synchronized (Singleton.class) {
                    if (uniqueInstance == null) {
                        uniqueInstance = new Singleton();
                    }
                }
            }
        }
    }
    ```

4. 领域驱动设计(DDD)的六边形架构

  六边形每条不同的边代表了不同类型的端口，通过“端口”跟外部进行交互。通过适配器调用应用程序和领域模型。

  领域模型中的实体类可细分为4种类型：VO、DTO、DO、PO。
      
  - VO（View Ob-ject）：视图对象，用于展示层视图状态对应的对象
  - DTO（Data Transfer Object）：数据传输对象，原来的目的是为EJB的分布式应用提供粗粒度的数据实体，以降低分布式调用的次数，提高分布式调用的性能，后来一般泛指用于展示层与服务层之间的数据传输对象，因此可以将DTO看成一个组合版的DO
  - DO（Domain Object）：领域对象，即业务实体对象
  - PO（Persistent Object）：持久化对象，表示持久层的数据结构（如数据库表）

## Java 

[Java](https://yycg.github.io/2020/03/05/Java/)

1. 简单类型8种：short, int, long, float, double, boolean, byte, char

2. NIO：非阻塞IO，调用者不用一直等着结果返回。线程控制选择器，选择不同的通道来读取缓存区。

3. Linux的5中IO模型：阻塞、非阻塞、异步、IO复用、信号驱动IO

4. select, poll, epoll的区别

  - select需要把文件描述符(fd)集合从用户态拷贝到内核态，并在内核态遍历文件描述符。
  - poll与select类似，文件描述符集合的描述结构不同。
  - epoll会在注册时把所有文件描述符拷贝进内核，每个文件描述符只会拷贝一次，挂到等待队列上。

5. Object类方法：hashCode(), equals(), notify(), wait(), toString(), clone(), getClass(), finalize()

6. 接口和抽象类的区别：方法在接口中不能有实现；一个类可以实现多个接口，但只能继承一个抽象类。

7. String：不可变
StringBuffer：可变，线程安全synchronized
StringBuilder：可变，线程不安全

8. final

  - 修饰变量：值再初始化后不能更改
  - 修饰类：类不能被继承，所有成员方法都会被隐式指定为final

9. static

  - 修饰成员变量和方法
  - 静态代码块
  - 静态内部类（不能引用外部非static成员变量和方法）

10. 通配符?用于实例化泛型对象，T用于定义泛型类

11. List, Set, Map

  - List: ArrayList, Vector, LinkedList
  - Set, Map: HashMap, HashTable, LinkedHashMap, TreeMap

12. HashMap

  - hash = h ^ (h >>> 16)，高16位和低16位都反映到低位上，使hash更均匀
  - 到table[(n-1)&hash]取值（取hash的低位）
  - 扩容：新数组newTable为原数组的2倍；如果节点是TreeNode，分成2棵树；如果是节点，hash&oldCap==0放在原索引，否则原索引+oldCap.
  - JDK 8前，并发扩容产生循环链表，get时死循环。JDK 8不会死循环，但仍然会产生数据丢失。

13. ==和equals()的区别

  - ==判断2个对象的地址是否相等
  - equals()没有重写时等价于==，可以重写

14. hashCode()和equals()

  - HashMap比较key是否相同时，先判断hashCode是否相同，再比较equals()是否相同。
  - 2个对象相等，散列码相同。
  - equals()重写过，hashCode()也要重写，否则有可能2个对象相同散列码不同，散列到不同的散列桶中找不到key

15. 重写equals()的约定

    (1) 使用==操作符检查参数是否时这个对象的引用

    (2) 使用instance检查是否为正确的类型

    (3) 把参数转换成正确的类型

    (4) 比较每个关键域是否匹配

    (5) 思考equals()方法是否满足自反性、对称性、传递性、一致性、非空性

16. 重写hashCode

    (1) int result = 17;

    (2) 对于每个关键域：

    a. 计算关键域int类型的散列码c，float, double转成int, long, long: (int) (f^(f>>>32))
    
    b. result=31*result+c

17. TreeMap的底层实现是红黑树，AVL树是严格平衡，红黑树是弱平衡

18. 红黑树性质

    (1) 每个节点要么是红色，要么是黑色

    (2) 根节点永远是黑色的

    (3) 叶结点是空节点，并且是黑色的

    (4) 每个红色节点的2个子节点都是黑色的
    
    (5)从任一节点到其子树的每个叶结点都包含相同数量的黑色节点

19. Java 8

  - lambda表达式
  - 方法引用
  - 接口的默认方法
  - stream()
  - Optional

## 并发

[Java并发编程的艺术](https://yycg.github.io/2020/03/05/Java并发编程的艺术/)

[并发](https://yycg.github.io/2020/03/05/并发/)

1. 并发执行有可能比串行慢，因为线程有创建和上下文切换的开销

2. 使用Lmbench测量上下文切换时长，vmstat测量上下文切换的次数

3. 如何减少上下文切换

  - CAS算法，不用加锁
  - 使用最少线程
  - 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换

4. synchronized

  - 3种形式
  
    - 对于普通的同步方法，锁的是当前实例对象
    - 对于静态同步方法，锁的是当前类的Class对象
    - 对于同步方法块，锁的是synchronized括号里配置的对象
  
  - JVM基于进入和退出Monitor对象来实现方法同步和代码块同步。代码块同步是使用monitorenter和monitorexit指令实现的，而方法同步时使用ACC_SYNCHRONIZED标志位实现的。

5. Java对象头的Mark Word中存储对象的hashCode、分代年龄和锁标记位。

  - 偏向锁：Mark Word中存储指向当前线程的偏向锁。
  - 轻量级锁：线程尝试使用CAS将对象头中的MarkWord替换为指向锁记录的指针。
  - 重量级锁

6. CAS的三大问题

  (1) ABA问题
  (2) 循环时间长开销大
  (3) 只能保证一个共享变量的原子操作

7. JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。

  如果线程A要和B通信，必须要经历下面2个步骤：
  
  (1) 线程A把本地内存A中更新过的共享变量刷新到主内存中去。
  (2) 线程B到主内存中去读取线程A之前已经更新过的共享变量。

8. 为什么要使用多线程（主要原因是IO阻塞和多CPU）

  - 单核时代提高CPU和IO的综合利用率
  - 多核时代提高CPU利用率
  - 业务更快的响应时间

9. 设置线程优先级时，针对频繁阻塞的线程需设置较高的优先级，而偏重计算的线程设置较低的优先级，确保处理器不会被独占。

10. 线程的状态

  - NEW
  - TERMINATED
  - RUNNABLE：运行中，包括就绪和运行
  - BLOCKED：阻塞于锁
  - WAITING：等待其他线程通知
  - TIME_WAITING：超时等待，可以在指定时间自行返回

11. 当一个Java虚拟机中不存在非Daemon线程时，Java虚拟机将会退出。

12. 线程通过方法isInterrupted()来判断是否被中断，也可以调用静态方法Thread.interrupted()对当前线程的中断标志位进行复位。

13. 除了中断以外，还可以利用一个boolean变量来控制是否需要停止任务并终止该线程。

14. suspend()调用后不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态。

  stop()终结一个线程时不会保证线程资源正常释放
  
  yield()方法会临时暂停正在执行的线程，来让有同样优先级的线程有机会执行。yield()方法不保证当前的线程会暂停或停止，但是可以保证当前线程调用yield方法时会放弃CPU。

15. 线程间通信

  - wait/notify
  - volatile/synchronized
  - join
  - countdownlatch/cyclicbarrier
  - semaphore

16. Fork/Join框架

  Fork就是把一个大任务切分成若干子任务，Join就是合并这些子任务的执行结果。
  
  工作窃取算法是指某个线程从其他队列中窃取任务来执行。充分利用线程进行并行计算，减少了线程的竞争。

17. AtomicInteger

  ```java
  public final int getAndIncrement() {
      for (;;) {
          int current = get();
          int next = current + 1;
          if (compareAndSet(current, next)) {
              return current;
          }
      }
  }
 
  public final boolean compareAndSet(int expect, int update) {
      return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
  }
  ```

18. 线程池的好处

  - 降低资源消耗
  - 提高响应速度
  - 提高线程的可管理性
   
19. 线程池的参数

  (1) corePoolSize：核心线程数

  (2) runnableTaskQueue：任务队列

  ArrayBockingQueue：有界

  LinkedBlockingQueue：有界，默认Integer.MAX_VALUE

  SynchronousQueue：不存储元素

  PriorityBlockingQueue：具有优先级、无限

  (3) maxPoolSize：线程池的最大数量

  (4) ThreadFactory：创建线程的工厂

  (5) RejectExxcutionHandler 饱和策略

  AbortPolicy 直接抛出异常

  CallerRunPolicy 调用者所用线程

  DiscardOldestPolicy 丢弃最早

  DiscardPolicy 丢弃

  (6) keepAliveTime 线程池工作线程空闲后，保持存活的时间

20. 线程池提交任务

  execute()提交不需要返回值的任务，输入Runnable类实例

  submit()提交需要返回值的任务，输入Runnale或Callable，返回一个future对象，future的get()方法会阻塞到任务完成并返回返回值

21. 关闭线程池

  RUNNING

  SHUTDOWN(shutdown) 继续处理等待队列

  STOP(shutdownNow) 不再处理等待队列，中断正在执行的线程

22. CPU密集型任务应配置尽可能小的线程，如N_CPU+1; IO密集型任务线程并不是一直在执行任务，应配置尽可能多的线程，如2N_CPU.

23. Executor

  (1) FixedThreadPool
  (2) SingleThreadExecutor
  (3) CachedThreadExecutor
  (4) ScheduledThreadExecutor

24. Future接口和实现Future接口的FutureTask类用来表示异步计算的结果。

25. Runnable接口不会返回结果，而Callable接口可以返回结果。

26. CopyOnWriteArrayList：修改时，复制原有数据，将修改内容写入副本。写完后再去替换原来的数据。

27. java.util.comncurrent并发包

  并发容器 concurrentHashMap, copyOnWriteArrayList

  原子变量 AtomicInteger

  显式锁 lock

  同步工具 semaphore, countdownlatch, cyclicbarrier

	线程池

28. 可重入锁独有的功能

	- 指定公平锁还是非公平锁
	- Condition条件类，分组唤醒需要唤醒的线程
	- 中断等待锁

29. ThreadLocal内存泄漏

	key为弱引用，value为强引用，key被清理掉，value未被清理

30. 强引用：不会被清理

  弱引用：生存到下一次垃圾收集发生之前
	
	软引用：系统将要内存溢出异常前回收

	虚引用：唯一目的就是被回收前收到一个系统通知

31. CountDownLatch: countDown()计数减1，计数为0时释放等待线程，一等多

  CyclicBarrier: await()计数减1，计数为0时释放等待线程，多个线程互相等待

32. 创建线程的方法

	- 继承Thread类
	- 实现Runnable接口，传进Thread
	- 实现Callable接口，传进Thread
	- 线程池

33. 线程同步的方法

  - synchronized
	- volatile
	- 重入锁
	- ThreadLocal
	- 阻塞队列
	- 原子变量

34. 重入：获取锁的操作粒度是线程而不是调用，一个线程如果获取了锁之后那么也可以再次获取这个锁。

35. AQS

  > [AQS](https://snailclimb.gitee.io/javaguide/#/docs/java/Multithread/AQS)
  
  AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。
  
  CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。
  
  AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。

  AQS 定义两种资源共享方式

  1)Exclusive（独占）

  只有一个线程能执行，如 ReentrantLock。又可分为公平锁和非公平锁,ReentrantLock 同时支持两种锁,下面以 ReentrantLock 对这两种锁的定义做介绍：

  - 公平锁：按照线程在队列中的排队顺序，先到者先拿到锁
  - 非公平锁：当线程要获取锁时，先通过两次 CAS 操作去抢锁，如果没抢到，当前线程再加入到队列中等待唤醒。
  
  2)Share（共享）

  多个线程可同时执行，如 Semaphore/CountDownLatch。
  
  AQS 底层使用了模板方法模式

  同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：

  使用者继承 AbstractQueuedSynchronizer 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放）

  将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。

  这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用，下面简单的给大家介绍一下模板方法模式，模板方法模式是一个很容易理解的设计模式之一。

  模板方法模式是基于”继承“的，主要是为了在不改变模板结构的前提下在子类中重新定义模板中的内容以实现复用代码。举个很简单的例子假如我们要去一个地方的步骤是：购票buyTicket()->安检securityCheck()->乘坐某某工具回家ride()->到达目的地arrive()。我们可能乘坐不同的交通工具回家比如飞机或者火车，所以除了ride()方法，其他方法的实现几乎相同。我们可以定义一个包含了这些方法的抽象类，然后用户根据自己的需要继承该抽象类然后修改 ride()方法。

## JVM

[JVM](https://yycg.github.io/2020/03/05/JVM/)

1. 双亲委派模型

  如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委托给父类加载器完成。只有当父类加载器自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子类加载器才会尝试自己去加载。
  
2. 三种系统提供的类加载器

  - 启动类加载器
  - 扩展类加载器
  - 应用程序类加载器

3. 破坏双亲委派模型

  - ClassLoader.loadClass()方法
  - 线程上下文加载器
  - 用户对程序的动态性要求

4. 双亲委派模型的好处

  - 避免类的重复加载
  - Java的核心API不被篡改

5. 线程的实现

  - 内核线程，一对一线程模型
  - 用户线程，一对多线程模型

6. Amdahl定律：并行化来压榨计算机运算能力

7. 类加载的过程

 - 加载
 - 连接：验证、准备、解析
 - 初始化

8. volatile

  - 第一个语义：保证此变量对所有线程的可见性
  - volatile变量的运算在并发下一样是不安全的
  - 第二个语义：禁止指令重排序优化

9. happends-before先行发生

  happens-before是Java内存模型中定义的2项操作之间的偏序关系。如果说操作A先行发生于操作B，其实就是说发生操作B之前，操作A产生的影响能被B观察到。

  程序次序规则、volatile变量规则

10. JVM运行时数据区域

  线程私有的：程序计数器、虚拟机栈、本地方法栈
  
  线程共享的：堆、方法区

  JDK 8中用元数据去代替永久代实现方法区，并把字符串常量池和类静态变量迁移到堆中存放。

  为什么要用元数据区代替永久代？
  
  (1) 字符串存在永久代，容易出现性能问题
  
  (2) 类信息比较难确定大小，永久代空间分配困难

11. 垃圾回收GC

  - 根搜索算法：GC Roots向下搜索，判断是否可达
  
    GC Roots包括下面几种：
  
    1. 虚拟机栈中引用的对象
    2. 本地方法栈中引用的对象
    3. 方法区中的的常量变量引用的对象
    4. 方法区中的类静态变量引用的对象

  - 分代收集算法
  
    Eden: From Survivor: To Survivor = 8:1:1
    
    Eden区和From Survivor区中还存活的对象移动到To Survivor区，对象优先在Eden区分配，大对象直接进入老年代，长期存活的对象将进入老年代（15岁），老年代分配担保
  
  - Minor GC的触发条件：Eden区满
  
  - Full GC的触发条件
  
    1. 调用System.gc时建议执行Full GC
    2. 老年代空间不足
    3. 方法区空间不足
    4. 老年代担保空间不足
  
  - 新生代的收集器：Serial（串行）、ParNew（并行）、Parallel（高吞吐量），使用复制算法
  
  - 老年代的收集器有Serial Old、Parallel Old，使用标记-整理算法
  
  - CMS收集器基于标记-清除算法，步骤分为初始标记、并发标记、重新标记、并发清除
  
  - G1收集器将Java堆划分为多个大小相等的独立区域（Region），相关引用记录在Region对应的Remembered Set中。从整体看基于标记-整理算法，从局部（2个Region之间）看基于复制算法。步骤分为初始标记、并发标记、最终标记、筛选回收。

12. OOM、CPU占用过高排查

  - jsp：列出正在运行的虚拟机进程
  - jstat：统计信息，包括分区占用情况
  - **jmap：内存映像**
  - **jstack：堆栈跟踪**
  - VisualVM：生成浏览堆转储快照、分析CPU、内存性能
  - top ps

## Spring

[Spring揭秘](https://yycg.github.io/2020/03/05/Spring揭秘/)

[Spring](https://yycg.github.io/2020/03/05/Spring/)

## 操作系统

[操作系统](https://yycg.github.io/2020/03/05/操作系统/)

[操作系统](https://snailclimb.gitee.io/javaguide/#/docs/operating-system/basis?id=_11-%e4%bb%80%e4%b9%88%e6%98%af%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%ef%bc%9f)

1. 死锁

  - 死锁预防：互斥、不剥夺、请求保持（一次申请完所需的全部资源）、循环等待（顺序资源分配法）
  - 死锁避免：银行家算法
  - 死锁检测与解除：资源分配图、死锁定理

2. 页式存储

  - 页号根据页表查到块号，与页内偏移量拼接，得到物理地址
  - 连续的逻辑地址->不连续的物理地址

3. 缺页中断

  在请求分页系统中，每当所要访问的页面不在内存时，便产生一个缺页中断，请求操作系统将所缺页调入内存。
	
4. 页面置换算法

  OPT, FIFO, LRU, CLOCK
