---
layout:     post
title:      "总结"
subtitle:   ""
date:       2020-07-05 12:00:00
author:     "盈盈冲哥"
header-img: "img/fleabag.jpg"
mathjax: true
catalog: true
tags:
    - 学习
---

> [https://snailclimb.gitee.io/javaguide/#/?id=java]https://snailclimb.gitee.io/javaguide/#/?id=java

> [https://github.com/hanggegreat/CS-Tree](https://github.com/hanggegreat/CS-Tree)

> [https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#nginx](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#nginx)

## 分布式

1. 分层：应用层、服务层、数据层

2. 如何优化性能？

	- 缓存：CDN、反向代理、本地缓存、分布式缓存（一致性Hash算法）
	- 均衡负载：分布式（不同服务部署在不同）、集群（多台机器提供相同的服务）
	- 异步（消息队列削峰、线程池）
  - 数据库分库分表、读写分离

3. 分布式缓存的一致性Hash算法

  一致性Hash算法通过一致性Hash环实现key到缓存服务器的Hash映射。

  具体算法过程为：先构造一个长度为$2^32$的整数环（一致性Hash环），根据节点名称的Hash值将缓存服务器节点放置在这个Hash环上。然后根据需要缓存的数据的key值计算得到其Hash值，在Hash环上顺时针查找距离这个key的Hash值最近的缓存服务器节点。

  当缓存服务器集群需要扩容时，只需要将新加入的节点名称的Hash值放入一致性Hash环中，由于key时顺时针查找其最近的节点，因此新加入的节点只影响整个环中的一小段。

3. session管理

  - session复制：在集群中的几台服务器之间同步session对象，使得每台服务器上都保存所有用户的session信息。
  
  - session绑定：负载均衡服务器总是将来源于同一IP的请求分发到同一台服务器上。
  
  - 利用cookie记录session
  
  - session服务器

4. 指标：吞吐量（TPS、QPS、HPS）、响应时间、并发数

5. 安全

	- XSS攻击（跨站点脚本攻击）：注入恶意HTML脚本
	- SQL注入攻击：攻击者在HTTP请求中注入恶意SQL命令
	- CSRF攻击（跨站点请求伪造）：攻击者通过跨站请求，以合法的用户身份伪造请求进行非法操作

6. 加密

	- 单项散列加密：MD5, SHA1

    虽然不能通过算法将单向散列密文反算得到密文，但是由于人们设置密码具有一定的模式，因此通过彩虹表（人们常用密码和对应的密文关系表）等手段可以进行猜测式破解。

    为了加强单项散列计算的安全性，还会给散列算法加点盐，盐相当于加密的密钥，增加破解难度。

	- 对称加密：DES、RC

    对称加密是指加密和解密使用的密钥是同一个密钥（或者可以互相推算）。

	- 非对称加密：RSA

    不同于对称加密，非对称加密和解密使用的密钥不是同一密钥，其中一个对外界公开，被称作公钥，另一个只有所有者知道，被称为私钥。用公钥加密的信息必须用私钥才能解开，反之，用私钥加密的信息只有用公钥才能解开。

7. 高可用设计：服务降级、服务限流、超时设置、缓存、异步、幂等性设计

8. 幂等

  > https://www.jianshu.com/p/cea3675a590b
  > https://www.cnblogs.com/wxgblogs/p/6639272.html
  
  - 概念：一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。

  - 我们常用的HTTP协议的方法是具有幂等性语义要求的，比如：get方法用于获取资源，不应有副作用，因此是幂等的；post方法用于创建资源，每次请求都会产生新的资源，因此不具备幂等性；put方法用于更新资源，是幂等的；delete方法用于删除资源，也是幂等的。

  - 幂等的应用场景

    1）微服务场景，除了成功、失败两种状态，还会有第三个情况【未知】，也就是超时。如果超时了，微服务框架一般会进行重试。

    2）用户交互的时候多次点击。如：快速点击按钮多次。

    3）MQ消息中间件，消息重复消费。

    4）第三方平台的接口（如：支付成功回调接口），因为异常也会导致多次异步回调。

    5）其他应用服务根据自身的特性，也有可能进行重试。

  - 保证幂等的手段

    唯一的业务单号[悲观锁、乐观锁、唯一索引、Redis缓存]、token

    - 唯一业务单号

      最简单的，需要通过唯一的业务单号来保证幂等。也就是说相同的业务单号，认为是同一笔业务。使用这个唯一的业务单号来确保，后面多次的相同的业务单号的处理逻辑和执行效果是一致的。

    - 对变更行为加锁

      上述的保证幂等方案是分成两步的，第②步依赖第①步的查询结果，无法保证原子性的。在高并发下就会出现下面的情况：第二次请求在第一次请求第②步订单状态还没有修改为‘已支付状态’的情况下到来。既然得出了这个结论，余下的问题也就变得简单：把查询和变更状态操作加锁，将并行操作改为串行操作。

    - 唯一索引

      但是，在某些场景，你可能又想提供无锁的高并发幂等，那么你可以选择为业务单号加上唯一的索引或者组合索引，在并发的场景中，只有第一笔插入的交易请求能够成功，后续的请求哪怕是慢1ms或者更短时间，都会触发数据库的唯一索引异常而失败，那么你可以捕获这个异常。

    - 数据库操作时使用插入或更新（select + insert）

      如果已经存在就更新，不存在时才插入

    - 多版本控制

      这种方法适合在更新的场景中，比如我们要更新商品的名字，这时我们就可以在更新的接口中增加一个版本号，来做幂等

    - 防重-Redis缓存

      又或者你想把幂等放在服务的最前端，减少实际服务处理的资源浪费，在请求一到达时就提前去重，不让他有执行的机会，那么你可以考虑引入一个redis或类似的组件，将业务请求单号缓存在这个分布式锁的组件内。那么，每当订单发起交易请求，交易系统会去Redis缓存中查询是否存在该订单号的Key，如果不存在，则向Redis增加Key为订单号。查询订单是否已经执行，如果没有则转发到交易系统，执行完成后删除该订单号的Key。当然，Redis是提供分布式节点下的原子事务操作的。

    - 状态机

      通常是根据业务流程构建一个状态机，保证业务中每个流程只会在对应的状态下执行。如果一个业务操作步骤完成就进入下一个状态，这时候来了上一个状态的操作就不允许变更状态，保证了业务的幂等性。

    - token机制

      通常是每次操作都生成一个唯一 token 凭证，服务器通过这个唯一凭证保证同样的操作不会被执行两次，服务器在去重实现上可以采用独立kv数据库，去重表等多种实现。Token 机制应该是适用范围最广泛的一种幂等设计方案。比如AWS的API就是采用这一机制，调用方生成client token，要求token全局唯一，AWS根据client token做幂等操作。

8. 微服务

	> [大白话入门 Spring Cloud](https://snailclimb.gitee.io/javaguide/#/docs/system-design/micro-service/spring-cloud?id=%e5%bc%95%e5%87%ba-spring-cloud-bus)
  
  Spring Cloud抽象了一套通用的开发模式，依赖于RPC、网关、服务发现、配置管理、限流熔断、分布式链路跟踪的具体实现。

  - Eureka 服务发现框架

    服务发现：其实就是一个“中介”，整个过程中有三个角色：服务提供者(出租房子的)、服务消费者(租客)、服务中介(房屋中介)。

    服务提供者： 就是提供一些自己能够执行的一些服务给外界。

    服务消费者： 就是需要使用一些服务的“用户”。

    服务中介： 其实就是服务提供者和服务消费者之间的“桥梁”，服务提供者可以把自己注册到服务中介那里，而服务消费者如需要消费一些服务(使用一些功能)就可以在服务中介中寻找注册在服务中介的服务提供者。

    服务注册 Register：

    官方解释：当 Eureka 客户端向 Eureka Server 注册时，它提供自身的元数据，比如IP地址、端口，运行状况指示符URL，主页等。

    结合中介理解：房东 (提供者 Eureka Client Provider)在中介 (服务器 Eureka Server) 那里登记房屋的信息，比如面积，价格，地段等等(元数据 metaData)。

    服务续约 Renew：

    官方解释：Eureka 客户会每隔30秒(默认情况下)发送一次心跳来续约。 通过续约来告知 Eureka Server 该 Eureka 客户仍然存在，没有出现问题。 正常情况下，如果 Eureka Server 在90秒没有收到 Eureka 客户的续约，它会将实例从其注册表中删除。

    结合中介理解：房东 (提供者 Eureka Client Provider) 定期告诉中介 (服务器 Eureka Server) 我的房子还租(续约) ，中介 (服务器Eureka Server) 收到之后继续保留房屋的信息。

    获取注册列表信息 Fetch Registries：

    官方解释：Eureka 客户端从服务器获取注册表信息，并将其缓存在本地。客户端会使用该信息查找其他服务，从而进行远程调用。该注册列表信息定期（每30秒钟）更新一次。每次返回注册列表信息可能与 Eureka 客户端的缓存信息不同, Eureka 客户端自动处理。如果由于某种原因导致注册列表信息不能及时匹配，Eureka 客户端则会重新获取整个注册表信息。 Eureka 服务器缓存注册列表信息，整个注册表以及每个应用程序的信息进行了压缩，压缩内容和没有压缩的内容完全相同。Eureka 客户端和 Eureka 服务器可以使用JSON / XML格式进行通讯。在默认的情况下 Eureka 客户端使用压缩 JSON 格式来获取注册列表的信息。

    结合中介理解：租客(消费者 Eureka Client Consumer) 去中介 (服务器 Eureka Server) 那里获取所有的房屋信息列表 (客户端列表 Eureka Client List) ，而且租客为了获取最新的信息会定期向中介 (服务器 Eureka Server) 那里获取并更新本地列表。

    服务下线 Cancel：

    官方解释：Eureka客户端在程序关闭时向Eureka服务器发送取消请求。 发送请求后，该客户端实例信息将从服务器的实例注册表中删除。该下线请求不会自动完成，它需要调用以下内容：DiscoveryManager.getInstance().shutdownComponent();

    结合中介理解：房东 (提供者 Eureka Client Provider) 告诉中介 (服务器 Eureka Server) 我的房子不租了，中介之后就将注册的房屋信息从列表中剔除。

    服务剔除 Eviction：

    官方解释：在默认的情况下，当Eureka客户端连续90秒(3个续约周期)没有向Eureka服务器发送服务续约，即心跳，Eureka服务器会将该服务实例从服务注册列表删除，即服务剔除。

    结合中介理解：房东(提供者 Eureka Client Provider) 会定期联系 中介 (服务器 Eureka Server) 告诉他我的房子还租(续约)，如果中介 (服务器 Eureka Server) 长时间没收到提供者的信息，那么中介会将他的房屋信息给下架(服务剔除)。

  - Ribbon 进程内负载均衡器

    Ribbon 是运行在消费者端的负载均衡器，其工作原理就是 Consumer 端获取到了所有的服务列表之后，在其内部使用负载均衡算法，进行对多个系统的调用。

    Nginx 和 Ribbon 的对比

    和 Ribbon 不同的是，Nignx是一种集中式的负载均衡器。

    何为集中式呢？简单理解就是 将所有请求都集中起来，然后再进行负载均衡。

    在 Nginx 中请求是先进入负载均衡器，而在 Ribbon 中是先在客户端进行负载均衡才进行请求的。

    Ribbon 的几种负载均衡算法

    负载均衡，不管 Nginx 还是 Ribbon 都需要其算法的支持，如果我没记错的话 Nginx 使用的是 轮询和加权轮询算法。而在 Ribbon 中有更多的负载均衡调度算法，其默认是使用的 RoundRobinRule 轮询策略。

    - RoundRobinRule：轮询策略。Ribbon 默认采用的策略。若经过一轮轮询没有找到可用的 provider，其最多轮询 10 轮。若最终还没有找到，则返回 null。
    - RandomRule: 随机策略，从所有可用的 provider 中随机选择一个。
    - RetryRule: 重试策略。先按照 RoundRobinRule 策略获取 provider，若获取失败，则在指定的时限内重试。默认的时限为 500 毫秒。

  - Open Feign 服务调用映射

  - Hystrix 服务降级熔断器

    所谓 熔断 就是服务雪崩的一种有效解决方案。当指定时间窗内的请求失败率达到设定阈值时，系统将通过 断路器 直接将此请求链路断开。

    也就是我们上面服务B调用服务C在指定时间窗内，调用的失败率到达了一定的值，那么 Hystrix 则会自动将 服务B与C 之间的请求都断了，以免导致服务雪崩现象。

    降级是为了更好的用户体验，当一个方法调用异常时，通过执行另一种代码逻辑来给用户友好的回复。

  - Zuul 微服务网关

  - Config 微服务统一配置中心

  - Bus 消息总线

9. 分布式id

  https://snailclimb.gitee.io/javaguide/#/docs/system-design/micro-service/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93

9. 限流

  https://snailclimb.gitee.io/javaguide/#/docs/system-design/micro-service/limit-request

9. Zookeeper

  - CAP原理

    - 数据一致性：数据强一致、数据用户一致、数据最终一致
    - 数据可用性
    - 分区耐受性（系统具有跨网络分区的伸缩性）

  - BASE理论

    - 基本可用
    - 软状态
    - 最终一致性

  - 2PC

    阶段一：提交事务请求（投票）

    阶段二：执行事务提交（执行）

  - 3PC

    三阶段提交是两阶段提交的改进版，将两阶段提交协议的提交事务请求（投票）过程一分为二，形成由CanCommit、PreCommit和doCommit三个阶段组成的事务处理协议。

    阶段一：CanCommit

    阶段二：PreCommit

    阶段三：doCommit

  - Paxos算法：解决分布式一致性的算法

    - prepare阶段：提案者将具有全局唯一性的递增的编号N发送给表决者。表决者同意大于本地编号maxN（批准过的最大提案编号）的提案。
    - accept阶段：提案者收到半数以上表决者的批准，就会发送提案和编号。表决者再次比较，同意大于等于批准过的最大提案编号的提案。提案者收到半数以上同意，向所有表决者发送提案提交编号。

  - ZAB协议

    https://www.jianshu.com/p/fb527a64deee

10. 分布式锁

  https://www.cnblogs.com/shoshana-kong/p/9581557.html

10. Kafka

  https://snailclimb.gitee.io/javaguide/#/docs/system-design/data-communication/kafka-inverview

  https://snailclimb.gitee.io/javaguide/#/docs/system-design/data-communication/Kafka%E5%85%A5%E9%97%A8%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86
  
  - 流程

    1: 第一步心跳请求，客户端启动以后，主动链接castle，请求需要往哪个集群上生产和消费

    2: 第二步心跳响应，castle返回客户端，“你往192.168.1.1” 这个broker上生产消息或拉取消息。

    3: 第三步，客户端链接Broker，生产消息到broker上，或从broker上拉取消息消费。

    4: 以后第一步和第二步会一直重复，这就是所谓的“Mafka心跳”，客户端会始终和Castle保持一个“请求/响应”循环，目的是为了接收服务端的调度和控制指令。

  - 名词

    Broker: 存储实际消息的地方，一台服务器，多个服务器(broker)组成一个集群。

    Castle: 中控调度，调度客户端从哪个机器上拉取消息，或把消息生产到哪台机器上去。

    ClientSDK: 业务使用的api，来生产或消费消息。

    Topic: 主题、队列

    生产者、上游

    消费者、下游，多台相同的消费者组成消费组

    Partition、主题分区、消息分片、分片：设想你发给Mafka 一万条消息，Mafka保存的时候，把它切成了4块，每块2500条消息，分别放到了四个不同的机器上。

    消息副本、replica、消息复制

    Topic的Ack属性：3个副本（一个主本，两个副本），如果Ack设为-1表示3个副本都接受到消息才算成功，如果是1表示主本收到消息就算成功，存在消息丢失风险（主本刚接收到消息返回给发送端成功，同步线程还未将消息复制给副本，此时主本机器宕机了，副本机器转换为主本，消息丢失）。同步线程会保证消息主本和副本复制时延在1秒内，所以Ack设置为1的极端情况下最大可能会丢失1秒内的消息。

    死信：某条消息无法消费成功，一直卡在这条消息处，无法消费后面的消息。解决方法：在topic管理页面里打开死信，处理消息如果失败会扔进死信队列，先消费后面的消息，过一段时间再消费。

11. ElasticSearch

12. RPC

  https://snailclimb.gitee.io/javaguide/#/docs/system-design/data-communication/dubbo

  https://snailclimb.gitee.io/javaguide/#/docs/system-design/data-communication/why-use-rpc

  https://blog.csdn.net/testcs_dn/article/details/78050590

  https://blog.csdn.net/kesonyk/article/details/50924489

  https://blog.csdn.net/top_code/article/details/54615853

12. Thrift

13. Redis

14. Databus

  读数据：读缓存，读数据库，写缓存

  写数据：淘汰缓存，写数据库，（写缓存）

  问题：写数据库后，写缓存失败怎么办？读数据后写缓存时，数据库又更新了怎么办？

  解决：Databus，强一致协议（比如两阶段提交，paxos等）

15. 秒杀

  - 超卖

  https://blog.csdn.net/glamour2015/article/details/105179738/

  https://hacpai.com/article/1536335417613

  https://www.jianshu.com/p/39b3a95240c4

## 网络

1. OSI七层模型：物理层、数据链路层、网络层、传输层、会话层（会话管理）、表示层（数据格式转换）、应用层

2. ARP协议（网络层）：IP地址->MAC地址

    每个主机都设有一个ARP高速缓存，先查ARP表，如果没有就通过使用目的MAC地址为FF-FF-FF-FF-FF-FF的帧来封装并广播ARP请求分组。

3. TCP和UDP

    TCP提供可靠的面向连接的服务，增加了开销，用于文件传输、发送和接受邮件、远程登录等场景。

    UDP不建立连接，不提供可靠服务，用于语音、视频。

4. TCP为什么可靠一些

    TCP连接管理：三次握手、四次挥手

    TCP可靠传输：累计确认、超时和冗余ACK

    TCP流量控制：发送窗口的实际大小是接受窗口和拥塞窗口的最小值

    TCP拥塞控制：慢开始（指数规模增长）、拥塞避免（加法增大）、快恢复（乘法减小）

5. 滑动窗口的作用

    - 滑动窗口实现面向六的可靠性，只有在收到ACK确认的情况下移动左边界

    - 滑动窗口的流控特性

6. TCP连接和释放过程

    三次握手

    1. 客户机到服务器：SYN
    2. 服务器到客户机：SYN/ACK
    3. 客户机到服务器：ACK

    四次挥手

    1. 客户机到服务器：FIN
    2. 服务器到客户机：ACK
    
        CLOSE_WAIT

    3. 服务器到客户机：FIN/ACK

        TIME_WAIT
    
    4. 客户机到服务器：ACK

    - 为什么A还要发送一次确认呢？

      防止已经失效的连接请求报文段突然又传到了B，因而产生错误，浪费B的资源。
    
    - CLOSE_WAIT：半关闭状态，即A已经没有数据要发送了，但B若发送数据，A仍要接受。

    - TIME_WAIT：为什么A在TIME_WAIT状态必须等待2MSL（最长报文段寿命，建议为2min）？

      1. 为了保证A发送的最后一个ACK报文段能够到达B
      2. 防止已失效的连接请求报文段出现在本连接中
    
7. DNS的寻址过程

    1. 浏览器缓存、DNS缓存
    2. hosts文件
    3. 本地域名服务器分别请求根域名服务器、顶级域名服务器、权限域名服务器
    
        递归查询（比较少用）、迭代查询
    
8. 在浏览器输入url到显示主页的过程：DNS解析、TCP连接、发送HTTP请求、服务器解析渲染页面

9. 状态码

    1XX：信息性状态码

    2XX：成功状态码

    3XX：重定向状态码

    4XX：客户端错误状态码

    5XX：服务端错误状态码

    - 200 OK：表示从客户端发来的请求在服务端被正常处理了。
    - 201 Created：请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。
    - 202 Accepted：服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。
    - 204 No Content：代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。
    - 206 Partial Content：表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。

    - 301 Moved Permanently：永久性重定向。表示请求的资源已被分配了新的URL，以后应使用资源现在所指的URL。
    - 302 Found：临时性重定向。表示请求的资源已被分配了新的URL，希望用户能使用新的URL访问。和301状态码相似，但302状态码代表资源不是被永久移动，只是临时性质的。
    - 304 Not Modified：表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304.

    - 400 Bad Request：表示请求报文中存在语法错误。
    - 401 Unauthorized：表示发送的请求需要有通过HTTP认证的认证信息。
    - 403 Forbidden：对请求资源的访问被服务器拒绝了。
    - 404 Not Found：表明服务器上无法找到请求的资源。

    - 500 Internal Server Error：表示服务器端在执行请求时发生了错误。
    - 503 Service Unavailable：表明服务器暂时处于超负荷或正在进行停机维护，现在无法处理请求。

10. HTTP/1.1默认使用长连接，在响应头加入Connection: keep-alive。在使用长连接的情况下，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭。

11. HTTPS过程

  客户端向服务端发送HTTPS请求，服务端将自己的公钥发送给客户端，客户端利用公钥加密密钥，发起第二个HTTPS请求，将加密之后的密钥发送给服务端，服务端用私钥解密密钥，将加密后的密文发送给客户端，客户端利用密钥解密。

12. HTTP 2.0

  多个请求可同时在一个连接上并行执行。

13. HTTPS与HTTP的区别

  - 传输信息安全性不同
  - 连接方式不同：HTTPS由SSL+HTTP协议构建
  - 端口不同：HTTP 80, HTTPS 443
  - 证书申请方式不同：HTTPS需要到CA申请证书

14. 请求报文的结构

  - 请求行：请求方法GET/POST、URL、协议版本HTTP1.0/HTTP1.1
  - 请求首部：图解HTTP P80
  - 请求主体

15. GET请求和POST请求

  - GET请求参数在URL中，POST请求在请求主体中
  - GET请求具有幂等性，多词调用和一次调用是一样的，没有副作用

## 设计模式

1. 面对对象

- 封装：对象包含它能操作所需的所有信息，包括变量和方法，好处是减少耦合，内部可以自由修改，具有清晰的对外接口。
- 继承：is-a的关系，弗雷变子类不得不变，强耦合。
- 多态：子类以父类的身份出现，调用父类的方法，使用的是子类的实现。

2. 原则

- 单一职责原则：就一个类而言，应该仅有一个引起它变化的原因。
- 开放封闭原则：软件实体对于扩展是开放的，对于更改是封闭的。
- 依赖倒转原则：A.高层模块不应该依赖低层模块，两个都应该依赖抽象。B. 抽象不应该依赖细节，细节应该依赖抽象。
- 里氏替换原则：子类型必须能够替换掉它们的父类型。
- 合成/聚合复用原则：尽量使用合成/聚合，尽量不要使用继承。

3. 设计模式

- 简单工厂模式
- 工程方法模式：产品接口、工厂接口、具体产品、具体工厂，一个具体工厂生产一个具体产品。
- 抽象工厂模式：一个具体工厂创建一组具体工厂。
- 策略模式：上下文类（维护一个对策略的引用），策略类，具体策略类
- 代理模式：主体类（定义真是主体类和代理类的共同接口），真实主体类，代理类（保存一个引用是的代理可以访问真实主体）
- 观察者模式（发布-订阅模式）：主体类（可以增加和删除观察者对象）、观察者（再得到主体的通知时更新自己）、具体主体、具体观察者
- 适配器模式：将一个类的接口转换成客户希望的另一个接口
- 桥接模式：实现系统可能有多角度分类，每一种分类都有可能变化，那么九八这种多角度分离出来让它们独立变化，减少它们之间的耦合。
- 单例模式

  ```java
  public class Singleton {
      private volatile static Sinleton uniqueInstance;
      private Singleton() {}
      public static SIngleton getInstance() {
          if (uniqueInstance == null) {
	      synchronized (Singleton.class) {
	          if (uniqueInstance == null) {
		      uniqueInstance = new Singleton();
		  }
	      }
	  }
      }
  }
  ```

## 数据库

## Java 

1. 简单类型8种：short, int, long, float, double, boolean, byte, char

2. NIO：非阻塞IO，调用者不用一直等着结果返回。线程控制选择器，选择不同的通道来读取缓存区。

3. Linux的5中IO模型：阻塞、非阻塞、异步、IO复用、信号驱动IO

4. select, poll, epoll的区别

  - select需要把文件描述符(fd)集合从用户态拷贝到内核态，并在内核态遍历文件描述符。
  - poll与select类似，文件描述符集合的描述结构不同。
  - epoll会在注册时吧所有文件描述符拷贝进内核，每个文件描述符只会拷贝一次，挂到等待队列上。

5. Object类方法：hashCode(), equals(), notify(), wait(), toString(), clone(), getClass(), finalize()

6. 接口和抽象类的区别：方法再接口中不能有实现；一个类可以实现多个接口，但只能继承一个抽象类。

7. String：不可变
StringBuffer：可变，线程安全synchronized
StringBuilder：可变，线程不安全

8. final

  - 修饰变量：值再初始化后不能更改
  - 修饰类：类不能被继承，所有成员方法都会被隐式指定为final

9. static

  - 修饰成员变量和方法
  - 静态代码块
  - 静态内部类（不能引用外部非static成员变量和方法）

10. 通配符?用于实例化泛型对象，T用于定义泛型类

11. List, Set, Map

  - List: ArrayList, Vector, LinkedList
  - Set, Map: HashMap, HashTable. LinkedHashMap, TreeMap

12. HashMap

  - hash = h ^ (h >>> 16)，高16位和低16位都反映到低位上，使hash更均匀
  - 到table[(n-1)&hash]取值（取hash的低位）
  - 扩容：新数组newTable为原数组的2倍；如果节点是TreeNode，分成2棵树；如果是节点，hash&oldCap==0放在原索引，否则原索引+oldCap.
  - JDK 8前，并发扩容产生循环链表，get时死循环。JDK 8不会死循环，但仍然会产生数据丢失。

13. ==和equals()的区别

  - ==判断2个对象的地址是否相等
  - equals()没有重写时等价于==，可以重写

14. hashCode()和equals()

  - HashMap比较key是否相同时，先判断hashCode是否相同，再比较equals()是否相同。
  - 2个对象相等，散列码相同。
  - equals()重写过，hashCode()也要重写，否则有可能2个对象相同散列码不同，散列到不同的散列桶中找不到key

15. 重写equals()的约定

  (1) 使用==操作符检查参数是否时这个对象的引用
  (2) 使用instance检查是否为正确的类型
  (3) 把参数转换成正确的类型
  (4) 比较每个关键域是否匹配
  (5) 死牢equals()方法是否满足自反性、对称性、传递性、一致性、非空性

16. 重写hashCode

  (1) int result = 17;
  (2) 对于每个关键域：
  a. 计算关键域int类型的散列码c，float, double转成int, long, long: (int) (f^(f>>>32))
  b. result=31*result+c

17. TreeMap的底层实现是红黑树，AVL树是严格平衡，红黑树是弱平衡

18. 红黑树性质

  (1) 每个节点要么是红色，要么是黑色
  (2) 根节点永远是黑色的
  (3) 叶结点是空节点，并且是黑色的
  (4) 每个红色节点的2个子节点都是黑色的
  (5)从任一节点到其子树的每个叶结点都包含相同数量的黑色节点

19. Java 8

  - lambda表达式
  - 方法引用
  - 接口的默认方法
  - stream()
  - Optional

## 并发

1. 并发执行有可能比串行慢，因为线程有创建和上下文切换的开销

2. 使用Lmbench测量上下文切换时长，vmstat测量上下文切换的次数

3. 如何减少上下文切换

  - CAS算法，不用加锁
  - 使用最少线程
  - 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换

4. synchronized

  - 3种形式
  
    - 对于普通的同步方法，锁的是当前实例对象
    - 对于静态同步方法，锁的是当前类的Class对象
    - 对于同步方法块，锁的是synchronized括号里配置的对象
  
  - JVM基于进入和退出Monitor对象来实现方法同步和代码块同步。代码块同步是使用monitorenter和monitorexit指令实现的，而方法同步时使用ACC_SYNCHRONIZED标志位实现的。

5. Java对象头的Mark Word中存储对象的hashCode、分代年龄和锁标记位。

  - 偏向锁：Mark Word中存储指向当前线程的偏向锁。
  - 轻量级锁：线程尝试使用CAS将对象头中的MarkWord替换为指向锁记录的指针。
  - 重量级锁

6. CAS的三大问题

  (1) ABA问题
  (2) 循环时间长开销大
  (3) 只能保证一个共享变量的原子操作

7. JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。

  如果线程A要和B通信，必须要经历下面2个步骤：
  
  (1) 线程A把本地内存A中更新过的共享变量刷新到主内存中去。
  (2) 线程B到主内存中去读取线程A之前已经更新过的共享变量。

8. 为什么要使用多线程（主要原因是IO阻塞和多CPU）

  - 单核时代提高CPU和IO的综合利用率
  - 多核时代提高CPU利用率
  - 业务更快的响应时间

9. 设置线程优先级时，针对频繁阻塞的线程需设置较高的优先级，而偏重计算的线程设置较低的优先级，确保处理器不会被独占。

10. 线程的状态

  - NEW
  - TERMINATED
  - RUNNABLE：运行中，包括就绪和运行
  - BLOCKED：阻塞于锁
  - WAITING：等待其他线程通知
  - TIME_WAITING：超时等待，可以在指定时间自行返回

11. 当一个Java虚拟机中不存在非Daemon线程时，Java虚拟机将会退出。

12. 线程通过方法isInterrupted()来判断是否被中断，也可以调用静态方法Thread.interrupted()对当前线程的中断标志位进行复位。

13. 除了中断以外，还可以利用一个boolean变量来控制是否需要停止任务并终止该线程。

14. suspend()调用后不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态。

  stop()终结一个线程时不会保证线程资源正常释放
  
  yield()方法会临时暂停正在执行的线程，来让有同样优先级的线程有机会执行。yield()方法不保证当前的线程会暂停或停止，但是可以保证当前线程调用yield方法时会放弃CPU。

15. 线程间通信

  - wait/notify
  - volatile/synchronized
  - join
  - countdownlatch/cyclicbarrier

16. Fork/Join框架

  FOrk就是把一个大任务切分成若干子任务，Join就是合并这些子任务的执行结果。
  
  工作窃取算法是指某个线程从其他队列中窃取任务来执行。充分利用线程进行并行计算，减少了线程的竞争。

17. AtomicInteger

  ```java
  public final int getAndIncrement() {
      for (;;) {
          int current = get();
    int next = current + 1;
    if (compareAndSet(current, next)) {
        return current;
    }
      }
  }
 
  public final boolean compareAndSet(int expect, int update) {
      return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
  }
  ```

18. 线程池的好处

  - 降低资源消耗
  - 提高响应速度
  - 提高线程的可管理性
   
19. 线程池的参数

  (1) corePoolSize：核心线程数

  (2) runnableTaskQueue：任务队列

  ArrayBockingQueue：有界

  LinkedBlockingQueue：有界，默认Integer.MAX_VALUE

  SynchronousQUeue：不存储元素

  PriorityBlockingQueue：具有优先级、无限

  (3) maxPoolSize：线程池的最大数量

  (4) ThreadFactory：创建线程的工厂

  (5) RejectExxcutionHandler 饱和策略

  AbortPolicy 直接抛出异常

  CallerRunPolicy 调用者所用线程

  DiscardOldestPolicy 丢弃最早

  DiscardPolicy 丢弃

  (6) keepAliveTime 线程池工作线程空闲后，保持存活的时间

20. 线程池提交任务

  execute()提交不需要返回值的任务，输入Runnable类实例

  submit()提交需要返回值的任务，输入Runnale或Callable，返回一个future对象，future的get()方法会阻塞到任务完成并返回返回值

21. 关闭线程池

  RUNNING

  SHUTDOWN(shutdown) 继续处理等待队列

  STOP(shutdownNow)不在处理等待队列，中断正在执行的线程

22. CPU密集型任务应配置尽可能小的线程，如N_CPU+1;IO密集型任务线程并不是一直在执行任务，应配置尽可能多的线程，如2N_CPU.

23. Executor

  (1) FixedThreadPool
  (2) SingleThreadExecutor
  (3) CachedThreadExecutor
  (4) ScheduledTHreadExecutor

24. Future接口和实现Future接口的FUtureTask类用来表示异步计算的结果。

25. Runnable接口不会返回结果，而Callable接口可以返回结果。

26. CopyOnWriteArrayList：修改时，复制原有数据，将修改内容写入副本。写完后再去替换原来的数据。

27. java.util.comncurrent并发包

  并发容器 concurrentHashMap

  原子变量 AtomicInteger

  显式锁 lock

  同步工具 semaphore, countdownlatch, cyclicbarrier

	线程池

28. 可重入锁独有的功能

	- 指定公平锁还是非公平锁
	- Condition条件类，分组环形需要唤醒的线程
	- 中断等待锁

29. ThreadLocal内存泄漏

	key为弱引用，value为强引用，key被清理掉，value未被清理

30. 强引用：不会被清理

  弱引用：生存到下一次垃圾收集发生之前
	
	软引用：系统将要内存溢出异常前回收

	虚引用：唯一目的就是被回收前收到一个系统通知

31. CountDownLatch: countDown()，方法技术减1，一等多

  CyclicBarrier: await()计数减1，多个线程互相等待

32. 创建线程的方法

	- 继承Thread类
	- 实现Runnable接口，传进Thread
	- 实现Callable接口，传进Thread
	- 线程池

33. 线程同步的方法

  - synchronized
	- volatile
	- 重入锁
	- ThreadLocal
	- 阻塞队列
	- 原子变量

34. 重入：获取锁的操作粒度是线程而不是调用

35. AQS

  https://www.cnblogs.com/waterystone/p/4920797.html

## JVM

1. 双亲委派模型

  如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委托给父类加载器完成。只有当父类加载器自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子类加载器才会尝试自己去加载。
  
2. 三种系统提供的类加载器

  - 启动类加载器
  - 扩展类加载器
  - 应用程序类加载器

3. 破坏双亲委派模型

  - ClassLoader.loadClass()方法
  - 线程上下文加载器
  - 用户对程序的动态性要求

4. 双亲委派模型的好处

  - 避免类的重复加载
  - Java的核心API不被篡改

5. 线程的实现

  - 内核线程，一对一线程模型
  - 用户线程，一对多线程模型

6. Amdahl定律：并行化来压榨计算机运算能力

7. 类加载的过程

 - 加载
 - 连接：验证、准备、解析
 - 初始化

8. volatile

  - 第一个语义：保证此变量对所有线程的可见性
  - volatile变量的运算再并发下一样时不安全的
  - 第二个语义：禁止指令重排序优化

9. happends-before先行发生

  happens-before是Java内存模型中定义的2项操作之间的偏序关系。如果说操作A先行发生于操作B，其实就是说发生操作B之前，操作A产生的影响能被B观察到。

  程序次序规则、volatile变量规则

10. JVM运行时数据区域

  线程私有的：程序计数器、虚拟机栈、本地方法栈
  
  线程共享的：堆、方法区

  JDK 8中用元数据去代替永久代实现方法区，并把字符串常量池和类静态变量迁移到堆中存放。

  为什么要用元数据区代替永久代？
  
  (1) 字符串存在永久代，容易出现性能问题
  
  (2) 类信息比较难确定大小，永久代空间分配困难

11. 垃圾回收GC

   - 根搜索算法：GC Roots向下搜索，判断是否可达
   
     GC Roots包括下面几种：
   
     1. 虚拟机栈中引用的对象
     2. 本地方法栈中引用的对象
     3. 方法区中的的常量变量引用的对象
     4. 方法区中的类静态变量引用的对象

   - 分代收集算法
   
     Eden: From Survivor: To Survivor = 8:1:1
     
     Eden区和From Survivor区中还存活的对象移动到To Survivor区，对象优先在Eden区分配，大对象直接进入老年代，长期存活的对象将进入老年代（15岁），老年代分配担保
   
   - Minor GC的触发条件：Eden区满
   
   - Full GC的触发条件
   
     1. 调用System.gc时建议执行Full GC
     2. 老年代空间不足
     3. 方法区空间不足
     4. 老年代担保空间不足
   
   - 新生代的收集器：Serial（串行）、ParNew（并行）、Parallel（高吞吐量），使用复制算法
   
   - 老年代的收集器有Serial Old、Parallel Old，使用标记-整理算法
   
   - CMS收集器基于标记-清楚算法，步骤分为初始标记、并发标记、重新标记、并发清除
   
   - G1收集器将Java堆划分为多个大小相等的独立区域（Region），相关引用记录在Region对应的Remembered Set中。从整体看基于标记-整理算法，从局部（2个Region之间）看基于复制算法。步骤分为初始标记、比并发标记、最终标记、筛选回收。

12. OOM、CPU占用过高排查

  - jsp：列出正在运行的虚拟机进程
  - jstat：统计信息，包括分区占用情况
  - **jmap：内存映像**
  - **jstack：堆栈跟踪**
  - VisualVM：生成浏览堆转储快照、分析CPU、内存性能
  - top ps

## Spring

## 操作系统

	1. 死锁：互斥、不剥夺、请求保持（一次申请完所需的全部资源）、循环等待（顺序资源分配法）

	2. 页式存储

		- 页号根据页表查到块号，与页内偏移量拼接，得到物理地址
		- 连续的逻辑地址->不连续的物理地址

	3. 缺页中断

		在请求分页系统中，每当所要访问的页面不在内存时，便产生一个缺页中断，请求操作系统将所缺页调入内存。
	
	4. 页面置换算法

		OPT, FIFO, LRU, CLOCK
