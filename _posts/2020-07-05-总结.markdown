---
layout:     post
title:      "总结"
subtitle:   ""
date:       2020-07-05 12:00:00
author:     "盈盈冲哥"
header-img: "img/fleabag.jpg"
mathjax: true
catalog: true
tags:
    - 学习
---

> [https://snailclimb.gitee.io/javaguide/#/?id=java](https://snailclimb.gitee.io/javaguide/#/?id=java)

> [https://github.com/hanggegreat/CS-Tree](https://github.com/hanggegreat/CS-Tree)

> [https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#nginx](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#nginx)

## 大型网站技术架构

[大型网站技术架构](https://yycg.github.io/2020/03/05/大型网站技术架构/)

1. 分层：应用层、服务层、数据层

2. 如何优化性能？

    - 缓存：CDN、反向代理、本地缓存、分布式缓存（一致性Hash算法）
    - 均衡负载：分布式（不同服务部署在不同）、集群（多台机器提供相同的服务）
    - 异步（消息队列削峰、线程池）
    - 数据库分库分表、读写分离

3. 分布式缓存的一致性Hash算法

    一致性Hash算法通过一致性Hash环实现key到缓存服务器的Hash映射。

    具体算法过程为：先构造一个长度为$2^32$的整数环（一致性Hash环），根据节点名称的Hash值将缓存服务器节点放置在这个Hash环上。然后根据需要缓存的数据的key值计算得到其Hash值，在Hash环上顺时针查找距离这个key的Hash值最近的缓存服务器节点。

    当缓存服务器集群需要扩容时，只需要将新加入的节点名称的Hash值放入一致性Hash环中，由于key时顺时针查找其最近的节点，因此新加入的节点只影响整个环中的一小段。

4. session管理

    - session复制：在集群中的几台服务器之间同步session对象，使得每台服务器上都保存所有用户的session信息。
    
    - session绑定：负载均衡服务器总是将来源于同一IP的请求分发到同一台服务器上。
    
    - 利用cookie记录session
    
    - session服务器

5. 指标：吞吐量（TPS、QPS、HPS）、响应时间、并发数

6. 安全

    - XSS攻击（跨站点脚本攻击）：注入恶意HTML脚本

      手段：消毒、HTTPOnly

    - SQL注入攻击：攻击者在HTTP请求中注入恶意SQL命令

      手段：关闭错误回显、消毒、参数绑定

    - CSRF攻击（跨站点请求伪造）：攻击者通过跨站请求，以合法的用户身份伪造请求进行非法操作

      手段：表单Token、验证码、Referer check

7. 加密

    - 单项散列加密：MD5, SHA1

      虽然不能通过算法将单向散列密文反算得到密文，但是由于人们设置密码具有一定的模式，因此通过彩虹表（人们常用密码和对应的密文关系表）等手段可以进行猜测式破解。

      为了加强单项散列计算的安全性，还会给散列算法加点盐，盐相当于加密的密钥，增加破解难度。

    - 对称加密：DES、RC

      对称加密是指加密和解密使用的密钥是同一个密钥（或者可以互相推算）。

    - 非对称加密：RSA

      不同于对称加密，非对称加密和解密使用的密钥不是同一密钥，其中一个对外界公开，被称作公钥，另一个只有所有者知道，被称为私钥。用公钥加密的信息必须用私钥才能解开，反之，用私钥加密的信息只有用公钥才能解开。

8. 高可用设计：服务降级、服务限流、超时设置、缓存、异步、幂等性设计

## 幂等
  
[幂等](https://yycg.github.io/2020/07/25/幂等/)

1. 概念：一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。

2. 我们常用的HTTP协议的方法是具有幂等性语义要求的，比如：get方法用于获取资源，不应有副作用，因此是幂等的；post方法用于创建资源，每次请求都会产生新的资源，因此不具备幂等性；put方法用于更新资源，是幂等的；delete方法用于删除资源，也是幂等的。

3. 保证幂等的手段：通过悲观锁、乐观锁、唯一索引、Redis缓存来保证业务单号或者token的唯一性

## 分布式

[分布式](https://yycg.github.io/2020/03/05/分布式/)

## Zookeeper

[Zookeeper](https://yycg.github.io/2020/03/05/Zookeeper/)

## Kafka

[Kafka](https://yycg.github.io/2020/03/05/Kafka/)

## ElasticSearch

[ElasticSearch](https://yycg.github.io/2020/03/05/ElasticSearch/)

1. ES和MySQL的区别

    - 索引-数据库，类型-表，文档-行，字段-列
    - 倒排索引（单词->文档）-B+树索引
    - 分布式搜索[一个索引包含多个分片，分片包括主分片(读写)和副本分片(读);选举主节点]-遍历式搜索
    - 没有用户权限控制，没有事务，不支持回滚

2. 倒排索引的原理：FST(有限状态转录机)数据结构，利用前缀后缀压缩空间，O(len(str))的查询复杂度

3. 主节点选举：查找活跃的主节点，选择id最小的主节点。

4. 写入：客户端请求协调节点，协调节点将请求转发主节点，主节点对文档路由将文档写入主分片，同步到副本分片。

    文档写入主分片的过程是：写入缓冲，同时将命令记录到transaction log，每隔1s缓冲将数据刷新进OS Cache。刷新操作后倒排索引才会建立，因此ES是近实时的。

5. 查询：客户端请求协调节点，协调节点根据id路由到相应分片，随机选择主分片或副本分片。

6. 搜索：query and fetch, query then fetch (默认，解决数量问题), dfs query and fetch (解决排名问题), dfs query then fetch

    客户端请求协调节点，协调节点转发给所有分片，每个分片将搜索结果(id)返回协调节点，协调节点进行合并、排序、分页，根据最终结果的id去各分片上拉取文档。

7. 如何优化

    - 数据建模：只写入MySQL表中会被搜索的字段，禁止在ES中处理关联关系，可以直接写入或在应用端处理。
    - OS Cache：使数据量等于OS Cache。或者做一个缓存预热子系统，定时搜索热数据进入OS Cache。或者一个索引放热数据，一个索引放冷数据（冷热分离）。用滚动翻页(search after)来代替深度分页(from/size)，防止出现深度分页的情况。

## Redis

[Redis](https://yycg.github.io/2020/03/05/Redis/)

## MySQL

[高性能MySQL](https://yycg.github.io/2020/03/05/高性能MySQL/)

[MySQL](https://yycg.github.io/2020/03/05/MySQL/)

1. 内连接、左外连接、右外连接、全连接

2. MySQL 七大约束

    - **not null** 不允许为空
    - **default** 默认值
    - comment 列描述
    - zerofill 在数据前面自动填充0
    - **primary key** 主键不能为空，不能重复，一张表有且只能有一个主键，可以是复合主键
    - **auto_increment** 自增长
    - **unique** 唯一键允许为空，但是不能重复

3. MyISAM和InnoDB区别

    - 是否支持行级锁
    - 是否支持事务和崩溃后的安全恢复
    - 是否支持外键
    - 是否支持MVCC

4. 索引：B树索引和哈希索引

    - MyISAM：非聚簇索引，叶节点中取出data域的值，然后以data域的值为地址读取相应的数据记录。
    - InnoDB：聚簇索引的树的叶节点data域保存了完整的数据记录。在根据主键索引（聚簇索引）搜索时，直接找到key所在的节点即可取出数据；再根据辅助索引（二级索引）查找时，则需要先取出主键的值，再走一遍索引。

5. 事务

    事务是逻辑上的一组操作，要么都执行，要么都不执行。

    事务的四大特性 (ACID)

    - 原子性：事务是最小的执行单位，不允许分割，事务中的动作要么全部完成，要么完全不起作用。利用undolog实现。
    - 一致性：事务是的系统从一个一致的状态转换到另一个一致的状态。例子是转账前后需要满足余额不能小于0的约束。建立在AID上，并且依赖于开发者。
    - 隔离性：一个事务不被其他事务干扰，各并发事务之间是独立的。包括4种隔离级别。利用锁和MVCC实现。
    - 持久性：一个事务被提交之后，它对数据库中数据的改变是持久的。利用redolog实现。

6. 并发事务带来的问题

    - 脏读：一个事务读到另一个事务还未提交的数据。
    - 丢失数据：例如事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。
    - 不可重复读：一个事务两次读同一个数据发现不一样。
    - 幻读：一个事务两次查询发现多了一些原本不存在的记录，好像出现了幻觉。

7. MySQL的事务隔离级别

    - 读取未提交
    - 读取已提交（解决脏读）
    - 可重复读（解决不可重复读）
    - 可串行化（解决幻读）

8. 不同事务隔离级别分别会加哪些锁

    - 读取已提交级别：读取不加锁，写入、修改、删除加行锁。
    - 可重复读级别：next-key锁=gap锁+行锁。行锁防止别的事务修改或删除，GAP锁防止别的事务新增，行锁和GAP锁结合形成的的Next-Key锁共同解决了RR级别在写数据时的幻读问题。
    - 可串行化：读加共享锁，写加排他锁，读写互斥。并发能力非常差。

9. MVCC

    数据库并发场景有三种，分别为：
    
    - 读-读：不存在任何问题，也不需要并发控制
    - 读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读
    - 写-写：有线程安全问题，可能会存在更新丢失问题
    
    多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 

    - 在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能。
    - 同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题。

    有了MVCC，这两个组合的方式就可以最大程度的提高数据库并发性能，并解决读写冲突，和写写冲突导致的问题
    
    - MVCC + 悲观锁：MVCC解决读写冲突，悲观锁解决写写冲突
    - MVCC + 乐观锁：MVCC解决读写冲突，乐观锁解决写写冲突

    版本链

    对于使用InnoDB存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列：

    - trx_id：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。
    - roll_pointer：每次对某条记录进行改动时，这个隐藏列会存一个指针，可以通过这个指针找到该记录修改前的信息。

    ReadView

    对于使用READ UNCOMMITTED隔离级别的事务来说，直接读取记录的最新版本就好了，对于使用SERIALIZABLE隔离级别的事务来说，使用加锁的方式来访问记录。对于使用READ COMMITTED和REPEATABLE READ隔离级别的事务来说，就需要用到我们上边所说的版本链了，核心问题就是：需要判断一下版本链中的哪个版本是当前事务可见的。
    
    ReadView中主要包含4个比较重要的内容：

    1. m_ids：表示在生成ReadView时当前系统中活跃的读写事务的事务id列表。
    2. min_trx_id：表示在生成ReadView时当前系统中活跃的读写事务中最小的事务id，也就是m_ids中的最小值。
    3. max_trx_id：表示生成ReadView时系统中应该分配给下一个事务的id值。
    4. creator_trx_id：表示生成该ReadView的事务的事务id。

    有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：

    1. 如果被访问版本的trx_id属性值与ReadView中的creator_trx_id值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。
    2. 如果被访问版本的trx_id属性值小于ReadView中的min_trx_id值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。
    3. 如果被访问版本的trx_id属性值大于ReadView中的max_trx_id值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。
    4. 如果被访问版本的trx_id属性值在ReadView的min_trx_id和max_trx_id之间，那就需要判断一下trx_id属性值是不是在m_ids列表中，如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问

10. 快照读、当前读

    快照读：select ...

    快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。
    
    当前读：select ... lock in share mode (共享锁), select ... for update (排他锁), update, insert, delete

    它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。

11. undolog, redolog, binlog

    - redo log 是重做日志，提供 前滚 操作。Redo Log 保证事务的持久性。Redo 记录某 数据块 被修改 后 的值，可以用来恢复未写入 data file 的已成功事务更新的数据。redo 解决的问题之一就是事务执行过程中的强制刷脏。在事务提交前，只要将 Redo Log 持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是 Redo Log 已经持久化。系统可以根据 Redo Log 的内容，将所有数据恢复到最新的状态。

    - undo log 是回退日志，提供 回滚 操作。Undo Log 保证事务的原子性（在 InnoDB 引擎中，还用 Undo Log 来实现 MVCC）。Undo 记录某 数据 被修改 前 的值，可以用来在事务失败时进行 rollback.
    
    redo/undo log 和 binlog

    - 层次不同。redo/undo 是 innodb 引擎层维护的，而 binlog 是 mysql server 层维护的，跟采用何种引擎没有关系，记录的是所有引擎的更新操作的日志记录。
    - 记录内容不同。redo/undo 记录的是 每个页/每个数据 的修改情况，属于物理日志+逻辑日志结合的方式（redo log 是物理日志，undo log 是逻辑日志）。binlog 记录的都是事务操作内容，binlog 有三种模式：Statement（基于 SQL 语句的复制）、Row（基于行的复制） 以及 Mixed（混合模式）。不管采用的是什么模式，当然格式是二进制的。
    - 记录时机不同。redo/undo 在 事务执行过程中 会不断的写入，而 binlog 是在 事务最终提交前 写入的。binlog 什么时候刷新到磁盘跟参数 sync_binlog 相关。

12. 锁

    - 共享锁Shared Locks（S锁）
    
      兼容性：加了S锁的记录，允许其他事务再加S锁，不允许其他事务再加X锁

      加锁方式：select ... lock in share mode
    
    - 排他锁Exclusive Locks (X锁)

      兼容性：加了X锁的记录，不允许其他事务再加S锁或者X锁

      加锁方式：select ... for update
    
    - 表锁：意向锁 Intention Locks

      意向共享锁（IS锁）：事务在请求S锁前，要先获得IS锁

      意向排他锁（IX锁）：事务在请求X锁前，要先获得IX锁

      意向锁的存在是为了协调行锁和表锁的关系，支持多粒度（表锁与行锁）的锁并存。

      例子：事务A修改user表的记录r，会给记录r上一把行级的排他锁（X），同时会给user表上一把意向排他锁（IX），这时事务B要给user表上一个表级的排他锁就会被阻塞。意向锁通过这种方式实现了行锁和表锁共存且满足事务隔离性的要求。
    
    - 行锁：记录锁 Record Locks

      record lock锁住的永远是索引，而非记录本身
    
    - 行锁：间隙锁 Gap Locks

      区间锁, 仅仅锁住一个索引区间（开区间，不包括双端端点）。

      间隙锁可用于防止幻读，保证索引间的不会被插入数据。
    
    - 行锁：临键锁(Next-Key Locks)

      record lock + gap lock, 左开右闭区间。

      默认情况下，innodb使用next-key locks来锁定记录。

      但当查询的索引含有唯一属性的时候，Next-Key Lock 会进行优化，将其降级为Record Lock，即仅锁住索引本身，不是范围。

13. 联合索引

    - 最左前缀匹配：联合索引(a, b, c)相当于建立了(a), (a, b), (a, b, c)三个索引
    - 检索时，索引字段的顺序是任意的
    - 联合索引实际上是一棵B+树，只有最后一个索引字段可以是大于或者小于

14. explain

    - id
    - select_type: simple, [primary, subquery], [primary, derived (在from子句里)], [primary, union, union result]
    - type: eq_ref, ref, range, index, all
    - extra: using index, using where, using temporary

    一般MySQL能够使用如下三种方式应用WHERE条件，从好到坏依次为：
  
    - 在索引中使用WHERE条件来过滤不匹配的记录。
    - 使用索引覆盖扫描（在Extra列中出现了Using index）来返回记录，直接从索引中过滤不需要的记录并返回命重的结果。
    - 从数据表中返回数据，然后过滤不满足条件的记录（在Extra列中出现Using Where）。

15. 大表优化

    - 限定数据范围
    - 读写分离：主库负责写，从库负责读。
    - 垂直分区：数据表列的拆分，把一张列比较多的表拆分为多张表。
    - 水平分区：数据表行的拆分。分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以水平拆分最好分库 。

16. 数据库连接池：在连接池中，创建连接后，将其放置在池中，并再次使用它，因此不必建立新的连接。如果使用了所有连接，则会建立一个新连接并将其添加到池中。

17. 覆盖索引

    - 什么是覆盖索引

      如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在InnoDB存储引擎中，如果不是主键索引，叶子结点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次，这样就会比较慢。覆盖索引就是要查询出的列和索引是对应的，不做回表操作。
    
    - 覆盖索引使用实例

      现在我创建了索引(username, age)，在查询数据的时候：`select username, age from user where username = 'Java' and age = 22`，要查询出的列在叶子结点都存在，所以就不用回表。

18. 索引优化

    - where, order by, group by, join加索引
    - 有null的列不要加索引
    - 联合索引：区分度高的索引放左边，长度短的索引放左边，运行频率高的索引放左边
    - 主键建议使用自增 ID 值，分库分表要生成全局 id 
    - 对于频繁的查询考虑使用覆盖索引

19. SQL优化

    - *避免使用
    - limit
    - 小表join大表
    - 连接好于子查询
    - explain

20. 索引失效

    - 联合索引未用左列索引
    - like以%开头
    - 需要类型转换
    - where中索引列使用了函数

21. MySQL索引为什么用B+树不用B树或者红黑树

    - B+树做索引而不用B-树：B+树所有的Data域在叶子节点，并且所有叶子节点之间都有一个链指针。这样遍历叶子节点就能获得全部数据，这样就能进行区间访问啦。
    - B+树做索引而不用红黑树：大规模数据存储的时候，红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况。

22. 数据库主从一致性

     **半同步复制**
  
    （1）系统先对DB-master进行了一个写操作，写主库

    （2）等主从同步完成，写主库的请求才返回

    （3）读从库，读到最新的数据（如果读请求先完成，写请求后完成，读取到的是“当时”最新的数据）

    **数据库中间件**

    （1）所有的读写都走数据库中间件，通常情况下，写请求路由到主库，读请求路由到从库

    （2）记录所有路由到写库的key，在经验主从同步时间窗口内（假设是500ms），如果有读请求访问中间件，此时有可能从库还是旧数据，就把这个key上的读请求路由到主库

    （3）经验主从同步时间过完后，对应key的读请求继续路由到从库

    **缓存记录写key法**

    当写请求发生的时候：

    （1）将某个库上的某个key要发生写操作，记录在cache里，并设置“经验主从同步时间”的cache超时时间，例如500ms

    （2）修改数据库

    而读请求发生的时候：

    （1）先到cache里查看，对应库的对应key有没有相关数据

    （2）如果cache hit，有相关数据，说明这个key上刚发生过写操作，此时需要将请求路由到主库读最新的数据

    （3）如果cache miss，说明这个key上近期没有发生过写操作，此时将请求路由到从库，继续读写分离

23. 如何设计数据库表

    E-R图：实体、关系

    一对一（外键）、一对多（多的一方加外键）、多对多（中间表，两列作为联合主键）

    三大范式
    
    - **第一范式（1NF）：要求数据库表的每一列都是不可分割的原子数据项。**

    - 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）

      **第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。**

    - 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）

      **第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。**

## 网络

[网络](https://yycg.github.io/2020/03/05/网络/)

1. OSI七层模型：物理层、数据链路层、网络层、传输层、会话层（会话管理）、表示层（数据格式转换）、应用层

2. ARP协议（网络层）：IP地址->MAC地址

    每个主机都设有一个ARP高速缓存，先查ARP表，如果没有就通过使用目的MAC地址为FF-FF-FF-FF-FF-FF的帧来封装并广播ARP请求分组。

3. TCP和UDP

    TCP提供可靠的面向连接的服务，增加了开销，用于文件传输、发送和接收邮件、远程登录等场景。

    UDP不建立连接，不提供可靠服务，用于语音、视频。

4. TCP为什么可靠一些

    TCP连接管理：三次握手、四次挥手

    TCP可靠传输：累计确认、超时和冗余ACK

    TCP流量控制：发送窗口的实际大小是接受窗口和拥塞窗口的最小值

    TCP拥塞控制：慢开始（指数规模增长）、拥塞避免（加法增大）、快恢复（乘法减小）

5. 滑动窗口的作用

    - 滑动窗口实现面向流的可靠性，只有在收到ACK确认的情况下移动左边界

    - 滑动窗口的流控特性

6. TCP连接和释放过程

    三次握手

    1. 客户机到服务器：SYN
    2. 服务器到客户机：SYN/ACK
    3. 客户机到服务器：ACK

    四次挥手

    1. 客户机到服务器：FIN
    2. 服务器到客户机：ACK
    
        CLOSE_WAIT

    3. 服务器到客户机：FIN/ACK

        TIME_WAIT
    
    4. 客户机到服务器：ACK

    - 为什么A还要发送一次确认呢？

      防止已经失效的连接请求报文段突然又传到了B，因而产生错误，浪费B的资源。
    
    - CLOSE_WAIT：半关闭状态，即A已经没有数据要发送了，但B若发送数据，A仍要接受。

    - TIME_WAIT：为什么A在TIME_WAIT状态必须等待2MSL（最长报文段寿命，建议为2min）？

      1. 为了保证A发送的最后一个ACK报文段能够到达B
      2. 防止已失效的连接请求报文段出现在本连接中
    
7. DNS的寻址过程

    1. 浏览器缓存、DNS缓存
    2. hosts文件
    3. 本地域名服务器分别请求根域名服务器、顶级域名服务器、权限域名服务器
    
        递归查询（比较少用）、迭代查询
    
8. 在浏览器输入url到显示主页的过程：DNS解析、TCP连接、发送HTTP请求、服务器解析渲染页面

9. 状态码

    1XX：信息性状态码

    2XX：成功状态码

    3XX：重定向状态码

    4XX：客户端错误状态码

    5XX：服务端错误状态码

    - **200 OK**：表示从客户端发来的请求在服务端被正常处理了。
    - 201 Created：请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。
    - **202 Accepted**：服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。
    - **204 No Content**：代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。
    - **206 Partial Content**：表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。

    - **301 Moved Permanently**：永久性重定向。表示请求的资源已被分配了新的URL，以后应使用资源现在所指的URL。
    - **302 Found**：临时性重定向。表示请求的资源已被分配了新的URL，希望用户能使用新的URL访问。和301状态码相似，但302状态码代表资源不是被永久移动，只是临时性质的。
    - 304 Not Modified：表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304.

    - **400 Bad Request**：表示请求报文中存在语法错误。
    - **401 Unauthorized**：表示发送的请求需要有通过HTTP认证的认证信息。
    - **403 Forbidden**：对请求资源的访问被服务器拒绝了。
    - **404 Not Found**：表明服务器上无法找到请求的资源。

    - **500 Internal Server Error**：表示服务器端在执行请求时发生了错误。
    - **503 Service Unavailable**：表明服务器暂时处于超负荷或正在进行停机维护，现在无法处理请求。

10. HTTP/1.1默认使用长连接，在响应头加入Connection: keep-alive。在使用长连接的情况下，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭。

11. HTTPS过程

    客户端向服务端发送HTTPS请求，服务端将自己的公钥发送给客户端，客户端利用公钥加密密钥，发起第二个HTTPS请求，将加密之后的密钥发送给服务端，服务端用私钥解密密钥，将加密后的密文发送给客户端，客户端利用密钥解密。

12. HTTP 2.0

    多个请求可同时在一个连接上并行执行。

13. HTTPS与HTTP的区别

    - 传输信息安全性不同
    - 连接方式不同：HTTPS由SSL+HTTP协议构建
    - 端口不同：HTTP 80, HTTPS 443
    - 证书申请方式不同：HTTPS需要到CA申请证书

14. 请求报文的结构

    - 请求行：请求方法GET/POST、URL、协议版本HTTP1.0/HTTP1.1
    - 请求首部：图解HTTP P80
    - 请求主体

    通用首部字段

    - Cache-Control：控制缓存的行为
    - Connection：逐跳首部、连接的管理

    请求首部字段

    - Accept：用户代理可处理的媒体类型
    - Accept-Charset：优先的字符集
    - Accept-Encoding：优先的内容编码
    - Accept-Language：优先的语言（自然语言）
    - Host：请求资源所在服务器
    - Range：实体的字节范围请求
    - Referer：对请求中URL的原始获取方
    - User-Agent：HTTP客户端程序的信息

    响应首部字段

    实体首部字段

    - Content-Encoding：实体主体适用的编码方式
    - Content-Language：实体主体的自然语言
    - Content-Length：实体主体的大小
    - Content-Type：实体主体的媒体类型
    
    非HTTP/1.1首部字段

    - Cookie
    - Set-Cookie

15. GET请求和POST请求

    - GET请求参数在URL中，POST请求在请求主体中
    - GET请求具有幂等性，多次调用和一次调用是一样的，没有副作用

## 设计模式

[大话设计模式](https://yycg.github.io/2020/03/05/大话设计模式/)

[设计模式](https://yycg.github.io/2020/03/05/设计模式/)

1. 面对对象

    - 封装：对象包含它能操作所需的所有信息，包括变量和方法，好处是减少耦合，内部可以自由修改，具有清晰的对外接口。
    - 继承：is-a的关系，父类变子类不得不变，强耦合。
    - 多态：子类以父类的身份出现，调用父类的方法，使用的是子类的实现。

2. 原则

    - 单一职责原则：就一个类而言，应该仅有一个引起它变化的原因。
    - 开放封闭原则：软件实体对于扩展是开放的，对于更改是封闭的。
    - 依赖倒转原则：A.高层模块不应该依赖低层模块，两个都应该依赖抽象。B. 抽象不应该依赖细节，细节应该依赖抽象。
    - 里氏替换原则：子类型必须能够替换掉它们的父类型。
    - 合成/聚合复用原则：尽量使用合成/聚合，尽量不要使用继承。

3. 设计模式

    - 简单工厂模式
    - 工程方法模式：产品接口、工厂接口、具体产品、具体工厂，一个具体工厂生产一个具体产品。
    - 抽象工厂模式：一个具体工厂创建一组具体工厂。
    - 策略模式：上下文类（维护一个对策略的引用），策略类，具体策略类
    - 代理模式：主体类（定义真是主体类和代理类的共同接口），真实主体类，代理类（保存一个引用是的代理可以访问真实主体）
    - 观察者模式（发布-订阅模式）：主体类（可以增加和删除观察者对象）、观察者（再得到主体的通知时更新自己）、具体主体、具体观察者
    - 适配器模式：将一个类的接口转换成客户希望的另一个接口
    - 桥接模式：实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这种多角度分离出来让它们独立变化，减少它们之间的耦合。
    - 单例模式

      ```java
      public class Singleton {
          private volatile static Sinleton uniqueInstance;
          private Singleton() {}
          public static SIngleton getInstance() {
              if (uniqueInstance == null) {
                  synchronized (Singleton.class) {
                      if (uniqueInstance == null) {
                          uniqueInstance = new Singleton();
                      }
                  }
              }
          }
      }
      ```

4. 领域驱动设计(DDD)的六边形架构

    六边形每条不同的边代表了不同类型的端口，通过“端口”跟外部进行交互。通过适配器调用应用程序和领域模型。

    领域模型中的实体类可细分为4种类型：VO、DTO、DO、PO。
        
    - VO（View Ob-ject）：视图对象，用于展示层视图状态对应的对象
    - DTO（Data Transfer Object）：数据传输对象，原来的目的是为EJB的分布式应用提供粗粒度的数据实体，以降低分布式调用的次数，提高分布式调用的性能，后来一般泛指用于展示层与服务层之间的数据传输对象，因此可以将DTO看成一个组合版的DO
    - DO（Domain Object）：领域对象，即业务实体对象
    - PO（Persistent Object）：持久化对象，表示持久层的数据结构（如数据库表）

## Java 

[Java](https://yycg.github.io/2020/03/05/Java/)

1. 简单类型8种：short, int, long, float, double, boolean, byte, char

2. NIO：非阻塞IO，调用者不用一直等着结果返回。线程控制选择器，选择不同的通道来读取缓存区。

3. Linux的5中IO模型：阻塞、非阻塞、异步、IO复用、信号驱动IO

4. select, poll, epoll的区别

    - select需要把文件描述符(fd)集合从用户态拷贝到内核态，并在内核态遍历文件描述符。
    - poll与select类似，文件描述符集合的描述结构不同。
    - epoll会在注册时把所有文件描述符拷贝进内核，每个文件描述符只会拷贝一次，挂到等待队列上。

5. Object类方法：hashCode(), equals(), notify(), wait(), toString(), clone(), getClass(), finalize()

6. 接口和抽象类的区别：方法在接口中不能有实现；一个类可以实现多个接口，但只能继承一个抽象类。

7. String, StringBuffer, StringBuilder

    - String：不可变
    - StringBuffer：可变，线程安全synchronized
    - StringBuilder：可变，线程不安全

8. final

    - 修饰变量：值再初始化后不能更改
    - 修饰类：类不能被继承，所有成员方法都会被隐式指定为final

9. static

    - 修饰成员变量和方法
    - 静态代码块
    - 静态内部类（不能引用外部非static成员变量和方法）

10. 通配符?用于实例化泛型对象，T用于定义泛型类

11. List, Set, Map

    - List: ArrayList, Vector, LinkedList
    - Set, Map: HashMap, HashTable, LinkedHashMap, TreeMap

12. HashMap

    - hash = h ^ (h >>> 16)，高16位和低16位都反映到低位上，使hash更均匀
    - 到table[(n-1)&hash]取值（取hash的低位）
    - 扩容：新数组newTable为原数组的2倍；如果节点是TreeNode，分成2棵树；如果是节点，hash&oldCap==0放在原索引，否则原索引+oldCap.
    - JDK 8前，并发扩容产生循环链表，get时死循环。JDK 8不会死循环，但仍然会产生数据丢失。

13. ==和equals()的区别

    - ==判断2个对象的地址是否相等
    - equals()没有重写时等价于==，可以重写

14. hashCode()和equals()

    - HashMap比较key是否相同时，先判断hashCode是否相同，再比较equals()是否相同。
    - 2个对象相等，散列码相同。
    - equals()重写过，hashCode()也要重写，否则有可能2个对象相同散列码不同，散列到不同的散列桶中找不到key

15. 重写equals()的约定

    (1) 使用==操作符检查参数是否时这个对象的引用

    (2) 使用instance检查是否为正确的类型

    (3) 把参数转换成正确的类型

    (4) 比较每个关键域是否匹配

    (5) 思考equals()方法是否满足自反性、对称性、传递性、一致性、非空性

16. 重写hashCode

    (1) int result = 17;

    (2) 对于每个关键域：

    a. 计算关键域int类型的散列码c，float, double转成int, long, long: (int) (f^(f>>>32))
    
    b. result=31*result+c

17. TreeMap的底层实现是红黑树，AVL树是严格平衡，红黑树是弱平衡

18. 红黑树性质

    (1) 每个节点要么是红色，要么是黑色

    (2) 根节点永远是黑色的

    (3) 叶结点是空节点，并且是黑色的

    (4) 每个红色节点的2个子节点都是黑色的
    
    (5)从任一节点到其子树的每个叶结点都包含相同数量的黑色节点

19. Java 8

    - lambda表达式
    - 方法引用
    - 接口的默认方法
    - stream()
    - Optional

## 并发

[Java并发编程的艺术](https://yycg.github.io/2020/03/05/Java并发编程的艺术/)

[并发](https://yycg.github.io/2020/03/05/并发/)

1. 并发执行有可能比串行慢，因为线程有创建和上下文切换的开销

2. 使用Lmbench测量上下文切换时长，vmstat测量上下文切换的次数

3. 如何减少上下文切换

    - CAS算法，不用加锁
    - 使用最少线程
    - 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换

4. synchronized

    - 3种形式
    
      - 对于普通的同步方法，锁的是当前实例对象
      - 对于静态同步方法，锁的是当前类的Class对象
      - 对于同步方法块，锁的是synchronized括号里配置的对象
    
    - JVM基于进入和退出Monitor对象来实现方法同步和代码块同步。代码块同步是使用monitorenter和monitorexit指令实现的，而方法同步时使用ACC_SYNCHRONIZED标志位实现的。

5. Java对象头的Mark Word中存储对象的hashCode、分代年龄和锁标记位。

    - 偏向锁：Mark Word中存储指向当前线程的偏向锁。
    - 轻量级锁：线程尝试使用CAS将对象头中的MarkWord替换为指向锁记录的指针。
    - 重量级锁

6. CAS的三大问题

    (1) ABA问题
    (2) 循环时间长开销大
    (3) 只能保证一个共享变量的原子操作

7. JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。

    如果线程A要和B通信，必须要经历下面2个步骤：
    
    (1) 线程A把本地内存A中更新过的共享变量刷新到主内存中去。
    (2) 线程B到主内存中去读取线程A之前已经更新过的共享变量。

8. 为什么要使用多线程（主要原因是IO阻塞和多CPU）

    - 单核时代提高CPU和IO的综合利用率
    - 多核时代提高CPU利用率
    - 业务更快的响应时间

9. 设置线程优先级时，针对频繁阻塞的线程需设置较高的优先级，而偏重计算的线程设置较低的优先级，确保处理器不会被独占。

10. 线程的状态

    - NEW
    - TERMINATED
    - RUNNABLE：运行中，包括就绪和运行
    - BLOCKED：阻塞于锁
    - WAITING：等待其他线程通知
    - TIME_WAITING：超时等待，可以在指定时间自行返回

11. 当一个Java虚拟机中不存在非Daemon线程时，Java虚拟机将会退出。

12. 线程通过方法isInterrupted()来判断是否被中断，也可以调用静态方法Thread.interrupted()对当前线程的中断标志位进行复位。

13. 除了中断以外，还可以利用一个boolean变量来控制是否需要停止任务并终止该线程。

14. suspend()调用后不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态。

    stop()终结一个线程时不会保证线程资源正常释放
    
    yield()方法会临时暂停正在执行的线程，来让有同样优先级的线程有机会执行。yield()方法不保证当前的线程会暂停或停止，但是可以保证当前线程调用yield方法时会放弃CPU。

15. 线程间通信

    - wait/notify
    - volatile/synchronized
    - join
    - countdownlatch/cyclicbarrier
    - semaphore

16. Fork/Join框架

    Fork就是把一个大任务切分成若干子任务，Join就是合并这些子任务的执行结果。
    
    工作窃取算法是指某个线程从其他队列中窃取任务来执行。充分利用线程进行并行计算，减少了线程的竞争。

17. AtomicInteger

    ```java
    public final int getAndIncrement() {
        for (;;) {
            int current = get();
            int next = current + 1;
            if (compareAndSet(current, next)) {
                return current;
            }
        }
    }
  
    public final boolean compareAndSet(int expect, int update) {
        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
    }
    ```

18. 线程池的好处

    - 降低资源消耗
    - 提高响应速度
    - 提高线程的可管理性
   
19. 线程池的参数

    (1) corePoolSize：核心线程数

    (2) runnableTaskQueue：任务队列

    ArrayBockingQueue：有界

    LinkedBlockingQueue：有界，默认Integer.MAX_VALUE

    SynchronousQueue：不存储元素

    PriorityBlockingQueue：具有优先级、无限

    (3) maxPoolSize：线程池的最大数量

    (4) ThreadFactory：创建线程的工厂

    (5) RejectExxcutionHandler 饱和策略

    AbortPolicy 直接抛出异常

    CallerRunPolicy 调用者所用线程

    DiscardOldestPolicy 丢弃最早

    DiscardPolicy 丢弃

    (6) keepAliveTime 线程池工作线程空闲后，保持存活的时间

20. 线程池提交任务

    execute()提交不需要返回值的任务，输入Runnable类实例

    submit()提交需要返回值的任务，输入Runnale或Callable，返回一个future对象，future的get()方法会阻塞到任务完成并返回返回值

21. 关闭线程池

    RUNNING

    SHUTDOWN(shutdown) 继续处理等待队列

    STOP(shutdownNow) 不再处理等待队列，中断正在执行的线程

22. CPU密集型任务应配置尽可能小的线程，如N_CPU+1; IO密集型任务线程并不是一直在执行任务，应配置尽可能多的线程，如2N_CPU.

23. Executor

    (1) FixedThreadPool

    (2) SingleThreadExecutor

    (3) CachedThreadExecutor

    (4) ScheduledThreadExecutor

24. Future接口和实现Future接口的FutureTask类用来表示异步计算的结果。

25. Runnable接口不会返回结果，而Callable接口可以返回结果。

26. CopyOnWriteArrayList：修改时，复制原有数据，将修改内容写入副本。写完后再去替换原来的数据。

27. java.util.comncurrent并发包

    并发容器 concurrentHashMap, copyOnWriteArrayList

    原子变量 AtomicInteger

    显式锁 lock

    同步工具 semaphore, countdownlatch, cyclicbarrier

    线程池

28. 可重入锁独有的功能

	- 指定公平锁还是非公平锁
	- Condition条件类，分组唤醒需要唤醒的线程
	- 中断等待锁

29. ThreadLocal内存泄漏

	  key为弱引用，value为强引用，key被清理掉，value未被清理

30. 引用

    强引用：不会被清理

    弱引用：生存到下一次垃圾收集发生之前
    
    软引用：系统将要内存溢出异常前回收

    虚引用：唯一目的就是被回收前收到一个系统通知

31. CountDownLatch, CyclicBarrier

    CountDownLatch: countDown()计数减1，计数为0时释放等待线程，一等多

    CyclicBarrier: await()计数减1，计数为0时释放等待线程，多个线程互相等待

32. 创建线程的方法

    - 继承Thread类
    - 实现Runnable接口，传进Thread
    - 实现Callable接口，传进Thread
    - 线程池

33. 线程同步的方法

    - synchronized
    - volatile
    - 重入锁
    - ThreadLocal
    - 阻塞队列
    - 原子变量

34. 重入：获取锁的操作粒度是线程而不是调用，一个线程如果获取了锁之后那么也可以再次获取这个锁。

35. AQS

    > [AQS](https://snailclimb.gitee.io/javaguide/#/docs/java/Multithread/AQS)
    
    AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。
    
    CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。
    
    AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。

    AQS 定义两种资源共享方式

    1)Exclusive（独占）

    只有一个线程能执行，如 ReentrantLock。又可分为公平锁和非公平锁,ReentrantLock 同时支持两种锁,下面以 ReentrantLock 对这两种锁的定义做介绍：

    - 公平锁：按照线程在队列中的排队顺序，先到者先拿到锁
    - 非公平锁：当线程要获取锁时，先通过两次 CAS 操作去抢锁，如果没抢到，当前线程再加入到队列中等待唤醒。
    
    2)Share（共享）

    多个线程可同时执行，如 Semaphore/CountDownLatch。
    
    AQS 底层使用了模板方法模式

    同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：

    使用者继承 AbstractQueuedSynchronizer 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放）

    将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。

    这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用，下面简单的给大家介绍一下模板方法模式，模板方法模式是一个很容易理解的设计模式之一。

    模板方法模式是基于”继承“的，主要是为了在不改变模板结构的前提下在子类中重新定义模板中的内容以实现复用代码。举个很简单的例子假如我们要去一个地方的步骤是：购票buyTicket()->安检securityCheck()->乘坐某某工具回家ride()->到达目的地arrive()。我们可能乘坐不同的交通工具回家比如飞机或者火车，所以除了ride()方法，其他方法的实现几乎相同。我们可以定义一个包含了这些方法的抽象类，然后用户根据自己的需要继承该抽象类然后修改 ride()方法。

## JVM

[JVM](https://yycg.github.io/2020/03/05/JVM/)

1. 双亲委派模型

    如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委托给父类加载器完成。只有当父类加载器自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子类加载器才会尝试自己去加载。
  
2. 三种系统提供的类加载器

    - 启动类加载器
    - 扩展类加载器
    - 应用程序类加载器

3. 破坏双亲委派模型

    - ClassLoader.loadClass()方法
    - 线程上下文加载器
    - 用户对程序的动态性要求

4. 双亲委派模型的好处

    - 避免类的重复加载
    - Java的核心API不被篡改

5. 线程的实现

    - 内核线程，一对一线程模型
    - 用户线程，一对多线程模型

6. Amdahl定律：并行化来压榨计算机运算能力

7. 类加载的过程

  - 加载
  - 连接：验证、准备、解析
  - 初始化

8. volatile

    - 第一个语义：保证此变量对所有线程的可见性
    - volatile变量的运算在并发下一样是不安全的
    - 第二个语义：禁止指令重排序优化

9. happends-before先行发生

    happens-before是Java内存模型中定义的2项操作之间的偏序关系。如果说操作A先行发生于操作B，其实就是说发生操作B之前，操作A产生的影响能被B观察到。

    程序次序规则、volatile变量规则

10. JVM运行时数据区域

    线程私有的：程序计数器、虚拟机栈、本地方法栈
    
    线程共享的：堆、方法区

    JDK 8中用元数据去代替永久代实现方法区，并把字符串常量池和类静态变量迁移到堆中存放。

    为什么要用元数据区代替永久代？
    
    (1) 字符串存在永久代，容易出现性能问题
    
    (2) 类信息比较难确定大小，永久代空间分配困难

11. 垃圾回收GC

    - 根搜索算法：GC Roots向下搜索，判断是否可达
    
      GC Roots包括下面几种：
    
      1. 虚拟机栈中引用的对象
      2. 本地方法栈中引用的对象
      3. 方法区中的的常量变量引用的对象
      4. 方法区中的类静态变量引用的对象

    - 分代收集算法
    
      Eden: From Survivor: To Survivor = 8:1:1
      
      Eden区和From Survivor区中还存活的对象移动到To Survivor区，对象优先在Eden区分配，大对象直接进入老年代，长期存活的对象将进入老年代（15岁），老年代分配担保
    
    - Minor GC的触发条件：Eden区满
    
    - Full GC的触发条件
    
      1. 调用System.gc时建议执行Full GC
      2. 老年代空间不足
      3. 方法区空间不足
      4. 老年代担保空间不足
    
    - 新生代的收集器：Serial（串行）、ParNew（并行）、Parallel（高吞吐量），使用复制算法
    
    - 老年代的收集器有Serial Old、Parallel Old，使用标记-整理算法
    
    - CMS收集器基于标记-清除算法，步骤分为初始标记、并发标记、重新标记、并发清除
    
    - G1收集器将Java堆划分为多个大小相等的独立区域（Region），相关引用记录在Region对应的Remembered Set中。从整体看基于标记-整理算法，从局部（2个Region之间）看基于复制算法。步骤分为初始标记、并发标记、最终标记、筛选回收。

12. OOM、CPU占用过高排查

    - jsp：列出正在运行的虚拟机进程
    - jstat：统计信息，包括分区占用情况
    - **jmap：内存映像**
    - **jstack：堆栈跟踪**
    - VisualVM：生成浏览堆转储快照、分析CPU、内存性能
    - top ps

## Spring

[Spring揭秘](https://yycg.github.io/2020/03/05/Spring揭秘/)

[Spring](https://yycg.github.io/2020/03/05/Spring/)

1. Spring模块

    - Spring Core： 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注入功能。
    - Spring Aspects ： 该模块为与AspectJ的集成提供支持。
    - Spring AOP ：提供了面向切面的编程实现。
    - Spring JDBC : Java数据库连接。
    - Spring JMS ：Java消息服务。
    - Spring ORM : 用于支持Hibernate等ORM工具。
    - Spring Web : 为创建Web应用程序提供支持。
    - Spring Test : 提供了对 JUnit 和 TestNG 测试的支持。

2. @RestController = @Controller + @ResponseBody

3. Spring IOC & AOP

    - IOC：IoC（Inverse of Control:控制反转）是一种设计思想，就是 将原本在程序中手动创建对象的控制权，交由Spring框架来管理。 IoC 在其他语言中也有应用，并非 Spring 特有。 IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。
    - DI：依赖注入（Dependecy Injection）和控制反转（Inversion of Control）是同一个概念。创建被调用者的工作由spring来完成，然后注入调用者 因此也称为依赖注入。依赖注入可以通过setter方法注入、构造器注入和接口注入三种方式来实现，Spring支持setter注入和构造器注入。
    - AOP：AOP(Aspect-Oriented Programming:面向切面编程)能够分离应用的业务逻辑和系统级服务。将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。

## 操作系统

[操作系统](https://yycg.github.io/2020/03/05/操作系统/)

[操作系统](https://snailclimb.gitee.io/javaguide/#/docs/operating-system/basis?id=_11-%e4%bb%80%e4%b9%88%e6%98%af%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%ef%bc%9f)

1. 死锁

    - 死锁预防：互斥、不剥夺、请求保持（一次申请完所需的全部资源）、循环等待（顺序资源分配法）
    - 死锁避免：银行家算法
    - 死锁检测与解除：资源分配图、死锁定理

2. 页式存储

    - 页号根据页表查到块号，与页内偏移量拼接，得到物理地址
    - 连续的逻辑地址->不连续的物理地址

3. 缺页中断

    在请求分页系统中，每当所要访问的页面不在内存时，便产生一个缺页中断，请求操作系统将所缺页调入内存。
	
4. 页面置换算法

    OPT, FIFO, LRU, CLOCK

## 数据结构

[数据结构](https://yycg.github.io/2020/03/05/数据结构/)

1. 散列表

    - 散列函数

      - 除法：$h(k)=k \mod m$
      - 乘法：将模块轮旋转k个A
      - 加法：位运算、查表、混合

    - 一个好的哈希函数应该具备以下三点：

      - 抗碰撞性，尽量避免冲突。
      - 抗篡改性，只要改动一个字节，其哈希值也会很大不同。
      - 查找效率。

    - 处理冲突

      - 拉链法
      - 开放定址法：线性探查法、平方探查法、再散列法、伪随机序列法

2. B树和B+树的区别

    - B树n个关键字对应n+1棵子树
    - B+树n个关键字对应n棵子树
    - B+树叶节点包含信息，提供数据库的索引范围查询和遍历的功能

3. 布隆过滤器

    - 将输入经过多个hash函数，数字对应下标置1.
    - 布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不存在，一定不存在。
    - 作用：判断给定数据是否存在（防止缓存穿透）、去重

4. 海量数据TopK问题

    - 找重复最多的TopK：散列成多个小数据再统计
    - 找最大TopK：外排、优先队列、分治找最大
    - 去重：布隆过滤器

5. 主方法

    对于形式$T(n)=aT(n/b)+f(n)$的递归，分为3种情况：

    1. $f(n)=O(n^{\log_ba-\varepsilon})$

        $f(n)$多项式地慢于$n^{\log_ba}$增长（相差$n^\varepsilon$）

        结论：$T(n)=\Theta(n^{\log_ba})$

    2. $f(n)=\Theta(n^{\log_ba}\log^kn)$

        $f(n)$与$n^{\log_ba}$以相似速率增长

        结论：$T(n)=\Theta(n^{\log_ba}\log^{k+1}n)$

    3. $f(n)=\Omega(n^{\log_ba+\varepsilon})$

        $f(n)$多项式地快于$n^{\log_ba}$增长（相差$n^\varepsilon$）

        结论：$T(n)=\Theta(f(n))$
