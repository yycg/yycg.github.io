---
layout:     post
title:      "总结"
subtitle:   ""
date:       2020-07-05 12:00:00
author:     "盈盈冲哥"
header-img: "img/fleabag.jpg"
mathjax: true
catalog: true
tags:
    - 学习
---

## 分布式

1. 分层：应用层、服务层、数据层

2. 如何优化性能？

	- 缓存：CDN、反向代理、分布式缓存（一致性Hash算法）
	- 均衡负载：分布式（不同服务部署在不同）、集群（多台机器提供相同的服务）
	- 异步（消息队列削峰、线程池）

3. session管理：session复制、session绑定、利用cookie记录session、session服务器

4. 指标：吞吐量（TPS、QPS、HPS）、响应时间、并发数

5. 安全

	- XSS攻击：跨站点脚本攻击
	- SQL注入攻击
	- CSRF攻击：跨站点请求伪造

6. 加密

	- 单项散列加密：MD5, SHA1
	- 对称加密：DES、RC
	- 非对称加密：RSA

7. 高可用设计：降级、限流、缓存

8. 微服务

	Spring Cloud抽象了一套通用的开发模式，依赖于RPC、网关、服务发现、配置管理、限流熔断、分布式链路跟踪的具体实现。

9. CAP原理

	- 数据一致性：数据强一致、数据用户一致、数据最终一致
	- 数据可用性
	- 分区耐受性（系统具有跨网络分区的伸缩性）

10. BASE理论

	- 基本可用
	- 软状态
	- 最终一致性

11. Paxos算法：解决分布式一致性的算法

	- prepare阶段：提案者将具有全局唯一性的递增的编号N发送给表决者。表决者同意大于本地编号maxN（批准过的最大提案编号）的提案。
	- accept阶段：提案者收到半数以上表决者的批准，就会发送提案和编号。表决者再次比较，同意大于等于批准过的最大提案编号的提案。提案者收到半数以上同意，向所有表决者发送提案提交编号。

## 网络

1. OSI七层模型：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层

2. ARP协议（网络层）：IP地址->MAC地址

    每个主机都设有一个ARP高速缓存，先查ARP表，如果没有就通过使用目的MAC地址为FF-FF-FF-FF-FF-FF的帧来封装并广播ARP请求分组。

3. TCP和UDP

    TCP提供可靠的面向连接的服务，增加了开销，用于文件传输、发送和接受邮件、远程登录等场景。

    UDP不建立连接，不提供可靠服务，用于语音、视频。

4. TCP为什么可靠一些

    TCP连接管理：三次握手、四次挥手

    TCP可靠传输：累计确认、超时和冗余ACK

    TCP流量控制：发送窗口的实际大小是接受窗口和拥塞窗口的最小值

    TCP拥塞控制：慢开始（指数规模增长）、拥塞避免（加法增大）、快恢复（乘法减小）

5. 滑动窗口的作用

    - 滑动窗口实现面向六的可靠性，只有在收到ACK确认的情况下移动左边界

    - 滑动窗口的流控特性

6. TCP连接和释放过程

    三次握手

    1. 客户机到服务器：SYN
    2. 服务器到客户机：SYN/ACK
    3. 客户机到服务器：ACK

    四次挥手

    1. 客户机到服务器：FIN
    2. 服务器到客户机：ACK
    
        CLOSE_WAIT

    3. 服务器到客户机：FIN/ACK

        TIME_WAIT
    
    4. 客户机到服务器：ACK

    - 为什么A还要发送一次确认呢？

      防止已经失效的连接请求报文段突然又传到了B，因而产生错误，浪费B的资源。
    
    - CLOSE_WAIT：半关闭状态，即A已经没有数据要发送了，但B若发送数据，A仍要接受。

    - TIME_WAIT：为什么A在TIME_WAIT状态必须等待2MSL（最长报文段寿命，建议为2min）？

      1. 为了保证A发送的最后一个ACK报文段能够到达B
      2. 防止已失效的连接请求报文段出现在本连接中
    
7. DNS的寻址过程

    1. 浏览器缓存、DNS缓存
    2. hosts文件
    3. 本地域名服务器分别请求根域名服务器、顶级域名服务器、权限域名服务器
    
        递归查询（比较少用）、迭代查询
    
8. 在浏览器输入url到显示主页的过程：DNS解析、TCP连接、发送HTTP请求、服务器解析渲染页面

9. 状态码

    1XX：信息性状态码

    2XX：成功状态码

    3XX：重定向状态码

    4XX：客户端错误状态码

    5XX：服务端错误状态码

10. HTTP/1.1默认使用长连接，在响应头加入Connection: keep-alive。在使用长连接的情况下，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭。

11. HTTPS过程

  客户端向服务端发送HTTPS请求，服务端将自己的公钥发送给客户端，客户端利用公钥加密密钥，发起第二个HTTPS请求，将加密之后的密钥发送给服务端，服务端用私钥解密密钥，将加密后的密文发送给客户端，客户端利用密钥解密。

12. HTTP 2.0

  多个请求可同时在一个连接上并行执行。

13. HTTPS与HTTP的区别

  - 传输信息安全性不同
  - 连接方式不同：HTTPS由SSL+HTTP协议构建
  - 端口不同：HTTP 80, HTTPS 443
  - 证书申请方式不同：HTTPS需要到CA申请证书

14. 请求报文的结构

  - 请求行：请求方法GET/POST、URL、协议版本HTTP1.0/HTTP1.1
  - 请求首部：图解HTTP P80
  - 请求主体

15. GET请求和POST请求

  - GET请求参数在URL中，POST请求在请求主体中
  - GET请求具有幂等性，多词调用和一次调用是一样的，没有副作用

## 设计模式

1. 面对对象

- 封装：对象包含它能操作所需的所有信息，包括变量和方法，好处是减少耦合，内部可以自由修改，具有清晰的对外接口。
- 继承：is-a的关系，弗雷变子类不得不变，强耦合。
- 多态：子类以父类的身份出现，调用父类的方法，使用的是子类的实现。

2. 原则

- 单一职责原则：就一个类而言，应该仅有一个引起它变化的原因。
- 开放封闭原则：软件实体对于扩展是开放的，对于更改是封闭的。
- 依赖倒转原则：A.高层模块不应该依赖低层模块，两个都应该依赖抽象。B. 抽象不应该依赖细节，细节应该依赖抽象。
- 里氏替换原则：子类型必须能够替换掉它们的父类型。
- 合成/聚合复用原则：尽量使用合成/聚合，尽量不要使用继承。

3. 设计模式

- 简单工厂模式
- 工程方法模式：产品接口、工厂接口、具体产品、具体工厂，一个具体工厂生产一个具体产品。
- 抽象工厂模式：一个具体工厂创建一组具体工厂。
- 策略模式：上下文类（维护一个对策略的引用），策略类，具体策略类
- 代理模式：主体类（定义真是主体类和代理类的共同接口），真实主体类，代理类（保存一个引用是的代理可以访问真实主体）
- 观察者模式（发布-订阅模式）：主体类（可以增加和删除观察者对象）、观察者（再得到主体的通知时更新自己）、具体主体、具体观察者
- 适配器模式：将一个类的接口转换成客户希望的另一个接口
- 桥接模式：实现系统可能有多角度分类，每一种分类都有可能变化，那么九八这种多角度分离出来让它们独立变化，减少它们之间的耦合。
- 单例模式

  ```java
  public class Singleton {
      private volatile static Sinleton uniqueInstance;
      private Singleton() {}
      public static SIngleton getInstance() {
          if (uniqueInstance == null) {
	      synchronized (Singleton.class) {
	          if (uniqueInstance == null) {
		      uniqueInstance = new Singleton();
		  }
	      }
	  }
      }
  }
  ```

## 数据库

## Java 

1. 简单类型8种：short, int, long, float, double, boolean, byte, char

2. NIO：非阻塞IO，调用者不用一直等着结果返回。线程控制选择器，选择不同的通道来读取缓存区。

3. Linux的5中IO模型：阻塞、非阻塞、异步、IO复用、信号驱动IO

4. select, poll, epoll的区别

  - select需要把文件描述符(fd)集合从用户态拷贝到内核态，并在内核态遍历文件描述符。
  - poll与select类似，文件描述符集合的描述结构不同。
  - epoll会在注册时吧所有文件描述符拷贝进内核，每个文件描述符只会拷贝一次，挂到等待队列上。

5. Object类方法：hashCode(), equals(), notify(), wait(), toString(), clone(), getClass(), finalize()

6. 接口和抽象类的区别：方法再接口中不能有实现；一个类可以实现多个接口，但只能继承一个抽象类。

7. String：不可变
StringBuffer：可变，线程安全synchronized
StringBuilder：可变，线程不安全

8. final

  - 修饰变量：值再初始化后不能更改
  - 修饰类：类不能被继承，所有成员方法都会被隐式指定为final

9. static

  - 修饰成员变量和方法
  - 静态代码块
  - 静态内部类（不能引用外部非static成员变量和方法）

10. 通配符?用于实例化泛型对象，T用于定义泛型类

11. List, Set, Map

  - List: ArrayList, Vector, LinkedList
  - Set, Map: HashMap, HashTable. LinkedHashMap, TreeMap

12. HashMap

  - hash = h ^ (h >>> 16)，高16位和低16位都反映到低位上，使hash更均匀
  - 到table[(n-1)&hash]取值（取hash的低位）
  - 扩容：新数组newTable为原数组的2倍；如果节点是TreeNode，分成2棵树；如果是节点，hash&oldCap==0放在原索引，否则原索引+oldCap.
  - JDK 8前，并发扩容产生循环链表，get时死循环。JDK 8不会死循环，但仍然会产生数据丢失。

13. ==和equals()的区别

  - ==判断2个对象的地址是否相等
  - equals()没有重写时等价于==，可以重写

14. hashCode()和equals()

  - HashMap比较key是否相同时，先判断hashCode是否相同，再比较equals()是否相同。
  - 2个对象相等，散列码相同。
  - equals()重写过，hashCode()也要重写，否则有可能2个对象相同散列码不同，散列到不同的散列桶中找不到key

15. 重写equals()的约定

  (1) 使用==操作符检查参数是否时这个对象的引用
  (2) 使用instance检查是否为正确的类型
  (3) 把参数转换成正确的类型
  (4) 比较每个关键域是否匹配
  (5) 死牢equals()方法是否满足自反性、对称性、传递性、一致性、非空性

16. 重写hashCode

  (1) int result = 17;
  (2) 对于每个关键域：
  a. 计算关键域int类型的散列码c，float, double转成int, long, long: (int) (f^(f>>>32))
  b. result=31*result+c

17. TreeMap的底层实现是红黑树，AVL树是严格平衡，红黑树是弱平衡

18. 红黑树性质

  (1) 每个节点要么是红色，要么是黑色
  (2) 根节点永远是黑色的
  (3) 叶结点是空节点，并且是黑色的
  (4) 每个红色节点的2个子节点都是黑色的
  (5)从任一节点到其子树的每个叶结点都包含相同数量的黑色节点

19. Java 8

  - lambda表达式
  - 方法引用
  - 接口的默认方法
  - stream()
  - Optional

## 并发

1. 并发执行有可能比串行慢，因为线程有创建和上下文切换的开销

2. 使用Lmbench测量上下文切换时长，vmstat测量上下文切换的次数

3. 如何减少上下文切换

  - CAS算法，不用加锁
  - 使用最少线程
  - 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换

4. synchronized

  - 3种形式
  
    - 对于普通的同步方法，锁的是当前实例对象
    - 对于静态同步方法，锁的是当前类的Class对象
    - 对于同步方法块，锁的是synchronized括号里配置的对象
  
  - JVM基于进入和退出Monitor对象来实现方法同步和代码块同步。代码块同步是使用monitorenter和monitorexit指令实现的，而方法同步时使用ACC_SYNCHRONIZED标志位实现的。

5. Java对象头的Mark Word中存储对象的hashCode、分代年龄和锁标记位。

  - 偏向锁：Mark Word中存储指向当前线程的偏向锁。
  - 轻量级锁：线程尝试使用CAS将对象头中的MarkWord替换为指向锁记录的指针。
  - 重量级锁

6. CAS的三大问题

  (1) ABA问题
  (2) 循环时间长开销大
  (3) 只能保证一个共享变量的原子操作

7. JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。

  如果线程A要和B通信，必须要经历下面2个步骤：
  
  (1) 线程A把本地内存A中更新过的共享变量刷新到主内存中去。
  (2) 线程B到主内存中去读取线程A之前已经更新过的共享变量。

8. 为什么要使用多线程

  - 单核时代提高CPU和IO的综合利用率
  - 多核时代提高CPU利用率
  - 业务更快的响应时间

9. 设置线程优先级时，针对频繁阻塞的线程需设置较高的优先级，而偏重计算的线程设置较低的优先级，确保处理器不会被独占。

10. 线程的状态

  - NEW
  - TERMINATED
  - RUNNABLE：运行中，包括就绪和运行
  - BLOCKED：阻塞于锁
  - WAITING：等待其他线程通知
  - TIME_WAITING：超时等待，可以在指定时间自行返回

11. 当一个Java虚拟机中不存在非Daemon线程时，Java虚拟机将会退出。

12. 线程通过方法isInterrupted()来判断是否被中断，也可以调用静态方法Thread.interrupted()对当前线程的中断标志位进行复位。

13. 除了中断以外，还可以利用一个boolean变量来控制是否需要停止任务并终止该线程。

14. suspend()调用后不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态。

  stop()终结一个线程时不会保证线程资源正常释放
  
  yield()方法会临时暂停正在执行的线程，来让有同样优先级的线程有机会执行。yield()方法不保证当前的线程会暂停或停止，但是可以保证当前线程调用yield方法时会放弃CPU。

15. 线程间通信

  - wait/notify
  - volatile/synchronized
  - join
  - countdownlatch/cyclicbarrier

16. Fork/Join框架

  FOrk就是把一个大任务切分成若干子任务，Join就是合并这些子任务的执行结果。
  
  工作窃取算法是指某个线程从其他队列中窃取任务来执行。充分利用线程进行并行计算，减少了线程的竞争。

17. AtomicInteger

 ```java
 public final int getAndIncrement() {
     for (;;) {
         int current = get();
	 int next = current + 1;
	 if (compareAndSet(current, next)) {
	     return current;
	 }
     }
 }
 
 public final boolean compareAndSet(int expect, int update) {
     return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
 }
 ```

18. 线程池的好处

  - 降低资源消耗
  - 提高响应速度
  - 提高线程的可管理性
   
19. 线程池的参数

  (1) corePoolSize：核心线程数
  (2) runnable

## JVM

1. 双亲委派模型

  如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委托给父类加载器完成。只有当父类加载器自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子类加载器才会尝试自己去加载。
  
2. 三种系统提供的类加载器

  - 启动类加载器
  - 扩展类加载器
  - 应用程序类加载器

3. 破坏双亲委派模型

  - ClassLoader.loadClass()方法
  - 线程上下文加载器
  - 用户对程序的动态性要求

4. 双亲委派模型的好处

  - 避免类的重复加载
  - Java的核心API不被篡改

5. 线程的实现

  - 内核线程，一对一线程模型
  - 用户线程，一对多线程模型

6. Amdahl定律：并行化来压榨计算机运算能力

7. 类加载的过程

 - 加载
 - 连接：验证、准备、解析
 - 初始化

8. volatile

  - 第一个语义：保证此变量对所有线程的可见性
  - volatile变量的运算再并发下一样时不安全的
  - 第二个语义：禁止指令重排序优化

9. happends-before先行发生

  happens-before是Java内存模型中定义的2项操作之间的偏序关系。如果说操作A先行发生于操作B，其实就是说发生操作B之前，操作A产生的影响能被B观察到。

  程序次序规则、volatile变量规则

10. JVM运行时数据区域

  线程私有的：程序计数器、虚拟机栈、本地方法栈
  
  线程共享的：堆、方法区

  JDK 8中用元数据去代替永久代实现方法区，并把字符串常量池和类静态变量迁移到堆中存放。

  为什么要用元数据区代替永久代？
  
  (1) 字符串存在永久代，容易出现性能问题
  
  (2) 类信息比较难确定大小，永久代空间分配困难

11. 垃圾回收GC

   - 根搜索算法：GC Roots向下搜索，判断是否可达
   
     GC Roots包括下面几种：
   
     1. 虚拟机栈中引用的对象
     2. 本地方法栈中引用的对象
     3. 方法区中的的常量变量引用的对象
     4. 方法区中的类静态变量引用的对象

   - 分代收集算法
   
     Eden: From Survivor: To Survivor = 8:1:1
     
     Eden区和From Survivor区中还存活的对象移动到To Survivor区，对象优先在Eden区分配，大对象直接进入老年代，长期存活的对象将进入老年代（15岁），老年代分配担保
   
   - Minor GC的触发条件：Eden区满
   
   - Full GC的触发条件
   
     1. 调用System.gc时建议执行Full GC
     2. 老年代空间不足
     3. 方法区空间不足
     4. 老年代担保空间不足
   
   - 新生代的收集器：Serial（串行）、ParNew（并行）、Parallel（高吞吐量），使用复制算法
   
   - 老年代的收集器有Serial Old、Parallel Old，使用标记-整理算法
   
   - CMS收集器基于标记-清楚算法，步骤分为初始标记、并发标记、重新标记、并发清除
   
   - G1收集器将Java堆划分为多个大小相等的独立区域（Region），相关引用记录在Region对应的Remembered Set中。从整体看基于标记-整理算法，从局部（2个Region之间）看基于复制算法。步骤分为初始标记、比并发标记、最终标记、筛选回收。

12. OOM、CPU占用过高排查

  - jsp：列出正在运行的虚拟机进程
  - jstat：统计信息，包括分区占用情况
  - **jmap：内存映像**
  - **jstack：堆栈跟踪**
  - VisualVM：生成浏览堆转储快照、分析CPU、内存性能
  - top ps

## Spring

## 操作系统

## 数据结构

## 项目
