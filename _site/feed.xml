<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>盈盈冲哥的博客</title>
    <description>没有对生活绝望，就不会爱生活。——阿尔贝·加缪</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 02 Aug 2020 21:07:30 +0800</pubDate>
    <lastBuildDate>Sun, 02 Aug 2020 21:07:30 +0800</lastBuildDate>
    <generator>Jekyll v4.0.0</generator>
    
      <item>
        <title>美团的记忆</title>
        <description>
</description>
        <pubDate>Sat, 01 Aug 2020 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/08/01/meituan/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/08/01/meituan/</guid>
        
        <category>生活</category>
        
        
      </item>
    
      <item>
        <title>总结</title>
        <description>&lt;h2 id=&quot;分布式&quot;&gt;分布式&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;分层：应用层、服务层、数据层&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如何优化性能？&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;缓存：CDN、反向代理、分布式缓存（一致性Hash算法）&lt;/li&gt;
      &lt;li&gt;均衡负载：分布式（不同服务部署在不同）、集群（多台机器提供相同的服务）&lt;/li&gt;
      &lt;li&gt;异步（消息队列削峰、线程池）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;session管理：session复制、session绑定、利用cookie记录session、session服务器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;指标：吞吐量（TPS、QPS、HPS）、响应时间、并发数&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安全&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;XSS攻击：跨站点脚本攻击&lt;/li&gt;
      &lt;li&gt;SQL注入攻击&lt;/li&gt;
      &lt;li&gt;CSRF攻击：跨站点请求伪造&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;加密&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;单项散列加密：MD5, SHA1&lt;/li&gt;
      &lt;li&gt;对称加密：DES、RC&lt;/li&gt;
      &lt;li&gt;非对称加密：RSA&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;高可用设计：降级、限流、缓存&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;微服务&lt;/p&gt;

    &lt;p&gt;Spring Cloud抽象了一套通用的开发模式，依赖于RPC、网关、服务发现、配置管理、限流熔断、分布式链路跟踪的具体实现。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CAP原理&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;数据一致性：数据强一致、数据用户一致、数据最终一致&lt;/li&gt;
      &lt;li&gt;数据可用性&lt;/li&gt;
      &lt;li&gt;分区耐受性（系统具有跨网络分区的伸缩性）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;BASE理论&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;基本可用&lt;/li&gt;
      &lt;li&gt;软状态&lt;/li&gt;
      &lt;li&gt;最终一致性&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Paxos算法：解决分布式一致性的算法&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;prepare阶段：提案者将具有全局唯一性的递增的编号N发送给表决者。表决者同意大于本地编号maxN（批准过的最大提案编号）的提案。&lt;/li&gt;
      &lt;li&gt;accept阶段：提案者收到半数以上表决者的批准，就会发送提案和编号。表决者再次比较，同意大于等于批准过的最大提案编号的提案。提案者收到半数以上同意，向所有表决者发送提案提交编号。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;网络&quot;&gt;网络&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;OSI七层模型：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ARP协议（网络层）：IP地址-&amp;gt;MAC地址&lt;/p&gt;

    &lt;p&gt;每个主机都设有一个ARP高速缓存，先查ARP表，如果没有就通过使用目的MAC地址为FF-FF-FF-FF-FF-FF的帧来封装并广播ARP请求分组。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TCP和UDP&lt;/p&gt;

    &lt;p&gt;TCP提供可靠的面向连接的服务，增加了开销，用于文件传输、发送和接受邮件、远程登录等场景。&lt;/p&gt;

    &lt;p&gt;UDP不建立连接，不提供可靠服务，用于语音、视频。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TCP为什么可靠一些&lt;/p&gt;

    &lt;p&gt;TCP连接管理：三次握手、四次挥手&lt;/p&gt;

    &lt;p&gt;TCP可靠传输：累计确认、超时和冗余ACK&lt;/p&gt;

    &lt;p&gt;TCP流量控制：发送窗口的实际大小是接受窗口和拥塞窗口的最小值&lt;/p&gt;

    &lt;p&gt;TCP拥塞控制：慢开始（指数规模增长）、拥塞避免（加法增大）、快恢复（乘法减小）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;滑动窗口的作用&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;滑动窗口实现面向六的可靠性，只有在收到ACK确认的情况下移动左边界&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;滑动窗口的流控特性&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TCP连接和释放过程&lt;/p&gt;

    &lt;p&gt;三次握手&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;客户机到服务器：SYN&lt;/li&gt;
      &lt;li&gt;服务器到客户机：SYN/ACK&lt;/li&gt;
      &lt;li&gt;客户机到服务器：ACK&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;四次挥手&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;客户机到服务器：FIN&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;服务器到客户机：ACK&lt;/p&gt;

        &lt;p&gt;CLOSE_WAIT&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;服务器到客户机：FIN/ACK&lt;/p&gt;

        &lt;p&gt;TIME_WAIT&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;客户机到服务器：ACK&lt;/li&gt;
    &lt;/ol&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;为什么A还要发送一次确认呢？&lt;/p&gt;

        &lt;p&gt;防止已经失效的连接请求报文段突然又传到了B，因而产生错误，浪费B的资源。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;CLOSE_WAIT：半关闭状态，即A已经没有数据要发送了，但B若发送数据，A仍要接受。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;TIME_WAIT：为什么A在TIME_WAIT状态必须等待2MSL（最长报文段寿命，建议为2min）？&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;为了保证A发送的最后一个ACK报文段能够到达B&lt;/li&gt;
          &lt;li&gt;防止已失效的连接请求报文段出现在本连接中&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DNS的寻址过程&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;浏览器缓存、DNS缓存&lt;/li&gt;
      &lt;li&gt;hosts文件&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;本地域名服务器分别请求根域名服务器、顶级域名服务器、权限域名服务器&lt;/p&gt;

        &lt;p&gt;递归查询（比较少用）、迭代查询&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在浏览器输入url到显示主页的过程：DNS解析、TCP连接、发送HTTP请求、服务器解析渲染页面&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;状态码&lt;/p&gt;

    &lt;p&gt;1XX：信息性状态码&lt;/p&gt;

    &lt;p&gt;2XX：成功状态码&lt;/p&gt;

    &lt;p&gt;3XX：重定向状态码&lt;/p&gt;

    &lt;p&gt;4XX：客户端错误状态码&lt;/p&gt;

    &lt;p&gt;5XX：服务端错误状态码&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP/1.1默认使用长连接，在响应头加入Connection: keep-alive。在使用长连接的情况下，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTTPS过程&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;客户端向服务端发送HTTPS请求，服务端将自己的公钥发送给客户端，客户端利用公钥加密密钥，发起第二个HTTPS请求，将加密之后的密钥发送给服务端，服务端用私钥解密密钥，&lt;/p&gt;

&lt;h2 id=&quot;设计模式&quot;&gt;设计模式&lt;/h2&gt;

&lt;h2 id=&quot;数据库&quot;&gt;数据库&lt;/h2&gt;

&lt;h2 id=&quot;java&quot;&gt;Java&lt;/h2&gt;

&lt;h2 id=&quot;并发&quot;&gt;并发&lt;/h2&gt;

&lt;h2 id=&quot;jvm&quot;&gt;JVM&lt;/h2&gt;

&lt;h2 id=&quot;spring&quot;&gt;Spring&lt;/h2&gt;

&lt;h2 id=&quot;操作系统&quot;&gt;操作系统&lt;/h2&gt;

&lt;h2 id=&quot;数据结构&quot;&gt;数据结构&lt;/h2&gt;

&lt;h2 id=&quot;项目&quot;&gt;项目&lt;/h2&gt;
</description>
        <pubDate>Sun, 05 Jul 2020 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/07/05/summary/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/07/05/summary/</guid>
        
        <category>学习</category>
        
        
      </item>
    
      <item>
        <title>Shell</title>
        <description>&lt;ol&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;  &lt;span class=&quot;nb&quot;&gt;chmod&lt;/span&gt; +x ./test.sh  &lt;span class=&quot;c&quot;&gt;#使脚本具有执行权限&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;不能写成test.sh，因为会去PATH里找。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用变量&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;$变量名&lt;/p&gt;

&lt;p&gt;${变量名}&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;字符串&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;  &lt;span class=&quot;nv&quot;&gt;your_name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'runoob'&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Hello, I know you are &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$your_name&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;! &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$str&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;双引号可以有变量、转义字符&lt;/li&gt;
  &lt;li&gt;字符串长度&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;  &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${#&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;字符串截取&lt;/p&gt;

&lt;p&gt;echo ${string:1:4}&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;数组&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;  &lt;span class=&quot;nv&quot;&gt;array_name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=(&lt;/span&gt;value0 value1 value2 value3&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;valuen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;array_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[n]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;数组中的所有元素&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;  &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;my_array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[*]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;my_array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[@]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;获取数组的长度&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;  &lt;span class=&quot;k&quot;&gt;${#&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;my_array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[*]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;${#&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;my_array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[@]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;传递参数&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;  &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;第一个参数为：&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;参数个数为：$#&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;传递的参数作为一个字符串显示：&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$*&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$*&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;$@&lt;/code&gt;的区别：如果传入3个参数，&lt;code class=&quot;highlighter-rouge&quot;&gt;$*&lt;/code&gt;是一个参数，&lt;code class=&quot;highlighter-rouge&quot;&gt;$@&lt;/code&gt;是3个参数&lt;/p&gt;
</description>
        <pubDate>Sun, 21 Jun 2020 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/06/21/shell/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/06/21/shell/</guid>
        
        <category>学习</category>
        
        
      </item>
    
      <item>
        <title>Maven</title>
        <description>&lt;h1 id=&quot;maven学习笔记&quot;&gt;Maven学习笔记&lt;/h1&gt;
&lt;p&gt;本笔记配合慕课网上maven视频使用效果最佳，链接如上&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;一.介绍
—-&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Maven&lt;/strong&gt;是基于项目对象模型（POM），可以通过一小段描述信息来管理项目的构建、报告和文档的软件项目管理工具。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;bin目录是包含mvn的运行脚本&lt;/li&gt;
  &lt;li&gt;boot目录包含一个类加载器的框架，maven使用它加载自己的类库&lt;/li&gt;
  &lt;li&gt;conf配置文件&lt;/li&gt;
  &lt;li&gt;lib包含maven运行时的依赖类库&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;二环境变量的配置&quot;&gt;二.环境变量的配置&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://maven.apache.org/download.cgi&quot; title=&quot;下载地址&quot;&gt;点击下载&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;maven&lt;/strong&gt;环境配置，增加一个环境变量&lt;strong&gt;MAVEN_HOME&lt;/strong&gt;,值是maven的安装路径（&lt;code class=&quot;highlighter-rouge&quot;&gt;C:\Program Files\apache-maven-3.5.0-bin\apache-maven-3.5.0&lt;/code&gt;）
修改path则是在path最后面添加&lt;code class=&quot;highlighter-rouge&quot;&gt;;%MAVEN_HOME%\bin&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;maven的项目结构&quot;&gt;Maven的项目结构&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-cmd&quot;&gt;项目名
	-src 
	   -main
	        -java
	             -package
	   -test
	        -java
	             -package
	-pom.xml
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;三常用命令&quot;&gt;三.常用命令&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-cmd&quot;&gt;    mvn -v 		查看 maven 版本
	 compile	编译
	 test		测试
	 package	打包

	 clean		删除 target
	 install	安装 jar 包到本地仓库
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;maven快速创建项目骨架目录&quot;&gt;maven快速创建项目骨架目录&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;两种方式：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cmd&quot;&gt;1.  mvn archetype:generate 按照提示进行选择
2.  mvn archetype:generate  -DgroupId=com.imooc.maven   -DartifactId=
  maven-service   -Dversion=1.0.0SNAPSHOT   -Dpackage=com.imooc.maven.demo
	1. -DgroupId=组织名，公司网址反写+项目名
	2. -DartifactId=项目名+模块名
	3. -Dversion=版本号
	4. -Dpackage=代码所存在的包名
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;四.Maven中的坐标和仓库
————–&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;构件坐标:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cmd&quot;&gt;    	1. groupId:公司名字+项目名
    	2. artifactId：项目名+模块名
    	3. varsion:版本号
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;仓库：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cmd&quot;&gt;		1. 本地仓库
		2. 远程仓库
		3. 镜像仓库
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;五更改仓库默认路径&quot;&gt;五.更改仓库默认路径&lt;/h2&gt;
&lt;p&gt;已安装到本地仓库中的jar包位置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cmd&quot;&gt;C:\Users\用户\.m2\repository\com\tiakon\demo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装路径conf文件夹下settings.xml文件
打开找到这段备注是的代码：&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- localRepository
     | The path to the local repository maven will use to store artifacts.
     | Default: ${user.home}/.m2/repository
    &amp;lt;localRepository&amp;gt;/path/to/local/repo&amp;lt;/localRepository&amp;gt;
--&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;复制粘贴出来&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;localRepository&amp;gt;&lt;/span&gt;/path/to/local/repo&lt;span class=&quot;nt&quot;&gt;&amp;lt;/localRepository&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;将localRepository便签内的值替换成新路径即可。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;六maven生命周期&quot;&gt;六.maven生命周期&lt;/h2&gt;

&lt;p&gt;完整的项目构建过程包括：
&lt;strong&gt;清理、编译、测试、打包、集成测试、验证、部署&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;maven三套独立的生命周期&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cmd&quot;&gt;	clean 	清理项目
			1.pre-clean	执行清理前的工作
			2.clean		清理上一次构建生成的所有文件
			3.post-clean 	执行清理后的文件

	default 构建项目（最核心）
			compile test package install

	site 	生成项目站点
			1. pre-site 	在生成项目站点前要完成的工作
			2. site 	生成项目的站点文档
			3. post-site	在生成项目站点后要完成的工作
			4. site-deploy	发布生成的站点到服务器上
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;七maven中pomxml常见元素介绍&quot;&gt;七.maven中pom.xml常见元素介绍&lt;/h2&gt;
&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;project&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;
         &lt;span class=&quot;na&quot;&gt;xmlns:xsi=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
         &lt;span class=&quot;na&quot;&gt;xsi:schemaLocation=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!--指定了当前pom的版本--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;modelVersion&amp;gt;&lt;/span&gt;4.0.0&lt;span class=&quot;nt&quot;&gt;&amp;lt;/modelVersion&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;反写的公司网址+项目名&lt;span class=&quot;nt&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;项目名+模块名&lt;span class=&quot;nt&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!--
        第一个0表示大版本号
        第二个0表示分支版本号
        第三个0表示小版本号
        0.0.1
        snapshot    快照
        alpha       内部测试
        beta        公测
        Release     稳定
        GA          正式发布
    --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span class=&quot;nt&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 打包方式:默认是jar,可选war、zip、pom --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;packaging&amp;gt;&amp;lt;/packaging&amp;gt;&lt;/span&gt;
    

    &lt;span class=&quot;c&quot;&gt;&amp;lt;!--指定编码格式--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;properties&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;project.build.sourceEncoding&amp;gt;&lt;/span&gt;UTF-8&lt;span class=&quot;nt&quot;&gt;&amp;lt;/project.build.sourceEncoding&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/properties&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 项目名 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;name&amp;gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 项目地址 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;url&amp;gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 项目描述 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;description&amp;gt;&amp;lt;/description&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 开发人员列表 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;developers&amp;gt;&amp;lt;/developers&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 许可证信息 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;licenses&amp;gt;&amp;lt;/licenses&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 组织信息 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;organization&amp;gt;&amp;lt;/organization&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;&amp;lt;!--依赖列表--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&amp;lt;!--依赖项--&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;junit&lt;span class=&quot;nt&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;junit&lt;span class=&quot;nt&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;RELEASE&lt;span class=&quot;nt&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;type&amp;gt;&amp;lt;/type&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;c&quot;&gt;&amp;lt;!--依赖范围--&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;scope&amp;gt;&amp;lt;/scope&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;c&quot;&gt;&amp;lt;!--设置依赖是否可选（默认）false--&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;optional&amp;gt;&amp;lt;/optional&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;c&quot;&gt;&amp;lt;!--排斥依赖传递列表--&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;exclusions&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;nt&quot;&gt;&amp;lt;exclusion&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;nt&quot;&gt;&amp;lt;/exclusion&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;/exclusions&amp;gt;&lt;/span&gt;
            
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!--依赖的管理，作用主要定义在父模块中，对子模块进行管理--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;dependencyManagement&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;

        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/dependencyManagement&amp;gt;&lt;/span&gt;
       
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!--对构件的行为提供相应的支持--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&amp;lt;!--插件列表--&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;nt&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.maven.plugins&lt;span class=&quot;nt&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;nt&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-source-plugin&lt;span class=&quot;nt&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;nt&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;3.0.1&lt;span class=&quot;nt&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;

                &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- &amp;lt;executions&amp;gt;
                    &amp;lt;execution&amp;gt;
                        &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;
                        &amp;lt;goals&amp;gt;
                            &amp;lt;goal&amp;gt;
                                jar-no-fork
                            &amp;lt;/goal&amp;gt;
                        &amp;lt;/goals&amp;gt;
                    &amp;lt;/execution&amp;gt;
                &amp;lt;/executions&amp;gt; --&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!--通常用于子模块对父模块pom的继承--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;parent&amp;gt;&amp;lt;/parent&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!--用来聚合运行Maven项目，指定多个模块一起编译--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;modules&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;module&amp;gt;&amp;lt;/module&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/modules&amp;gt;&lt;/span&gt;
       
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;八maven的依赖范围&quot;&gt;八.Maven的依赖范围&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-cmd&quot;&gt;三种 classpath
	1. 编译
	2. 测试
	3. 运行
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;maven提供了6种可选依赖范围:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-cmd&quot;&gt;1. compile:	默认范围，编译测试运行都有效。
2. provided:	在编译和测试时有效。（比如说在做 web 时，你在本地运行的 servlet ，
是需要调用已添加到项目中的 servlet-api.jar 这个 jar 包的。这个过程就包含了编译【就是
把 Java 文件编译成 class 文件的过程中也要调用】和测试【测试就是在本地运行】，那么他说
的运行是指，整个项目已开发完成，编译、测试通过后，将 class 文件或包含有 class 文件的 war 包
发布到服务器上的 Tomcat 中运行，这时启动项目，就可以直接调 Tomcat 中的 servlet-api.jar ，
不必再将自己的 jar 包添加到项目中去。也就是说当你选择 provided 时，项目发布时 Maven 不会将
你添加的 jar 包，加入到项目中。）
3. runtime:	在测试和运行时有效。(典型例子：JDBC驱动的实现。)
4. test:	只在测试是有效。
5. system:	类似 provided，与本机系统相关联，可移植性差。
6. import:	导入范围，他只是用在 dependencyManagement 中，表示从其他的 pom 中导
入dependecy的配置。（以下引用官网案例并不难理解。）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;九.依赖传递&lt;/p&gt;

&lt;exclusions&gt; 排除依赖

十.依赖冲突
------

```cmd
1.短路优先:

	C-&amp;gt;B-&amp;gt;A-&amp;gt;X1(jar)
	C-&amp;gt;B-&amp;gt;X2(jar)

【C依赖B,B依赖A,A和B都包含同一个不同版本的Jar,则取B的依赖版本。（c的pom.xml中不必注明jar坐标）】

2.先声明先优先

	如果路径相同长度相同，则谁先声明，先解析谁。

【C依赖A和B,A和B都包含同一个不同版本的Jar,谁依赖在前取谁的依赖版本。】
```

十一.聚合与继承
-------
### 聚合 ###

```xml
&lt;packaging&gt;pom&lt;/packaging&gt;
&lt;modules&gt;
    &lt;module&gt;../HoictasStudio-MavenDemo01&lt;/module&gt;
    &lt;module&gt;../HoictasStudio-MavenDemo02&lt;/module&gt;
    &lt;module&gt;../HoictasStudio-MavenDemo03&lt;/module&gt;
&lt;/modules&gt;
```

假设在**HoictasStudio-MavenParent**模块中添如以上代码，输入`clean install`命令后，即可同时安装多个jar到本地仓库中

```markdown
    [INFO] HoictasStudio-MavenDemo01 .......................... SUCCESS [  4.618 s]
    [INFO] HoictasStudio-MavenDemo02 .......................... SUCCESS [  0.828 s]
    [INFO] HoictasStudio-MavenDemo03 .......................... SUCCESS [  0.923 s]
    [INFO] HoictasStudio-MavenParent .......................... SUCCESS [  0.021 s]
```


### 继承 ###

**根据官方文档说明继承会根据父模块与子模块的包含与否，对pom.xml的写法则有两种。**

#### 第一种写法 ####

假设我们有两个模块，前一个叫 `com.mycompany.app:my-app:1`，后一个叫`com.mycompany.app:my-module:1`。

my-app的pom文件为：

```xml
&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt;
  &lt;artifactId&gt;my-app&lt;/artifactId&gt;
  &lt;version&gt;1&lt;/version&gt;
&lt;/project&gt;
```

my-module的pom文件为：

```xml
&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt;
  &lt;artifactId&gt;my-module&lt;/artifactId&gt;
  &lt;version&gt;1&lt;/version&gt;
&lt;/project&gt;
```

我们指定如下项目结构：

```xml
	.
	 |-- my-module
	 |   `-- pom.xml
	 `-- pom.xml
```

那么，我们需要`my-module`去继承`my-app`，则需要在`my-module`的pom文件中添加以下代码：

```xml
	&lt;project&gt;
	  &lt;parent&gt;
	    &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt;
	    &lt;artifactId&gt;my-app&lt;/artifactId&gt;
	    &lt;version&gt;1&lt;/version&gt;
	  &lt;/parent&gt;
	  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
	  &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt;
	  &lt;artifactId&gt;my-module&lt;/artifactId&gt;
	  &lt;version&gt;1&lt;/version&gt;
	&lt;/project&gt;
```

#### 第二种写法 ####

```cmd
However, that would work if the parent project was already installed inour local repository or was in that specific 
directory structure (parent pom.xml is one directory higher than that of the module's pom.xml). But what if the parent 
is not yet installed and if the directory structure is
.
```
 	 |-- my-module
 	 |   `-- pom.xml
 	 `-- parent
	     `-- pom.xml	

上一段话摘自官网对继承的介绍，就是说如果你的父模块已在本地安装或者父模块不包含子模块，目录级别甚至是
比子模块的还要高，就在第一种写法上添加`&lt;relativePath&gt;`标签。
​	

```xml
	&lt;project&gt;
		  &lt;parent&gt;
		    &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt;
		    &lt;artifactId&gt;my-app&lt;/artifactId&gt;
		    &lt;version&gt;1&lt;/version&gt;
		    &lt;relativePath&gt;../parent/pom.xml&lt;/relativePath&gt;
		  &lt;/parent&gt;
		  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
		  &lt;artifactId&gt;my-module&lt;/artifactId&gt;
	&lt;/project&gt;
```



笔者在看视频时就发现，当父模块与子模块处于同一级别时，在按照视频中的写法（第一种写法）test时就会报错，
而此时的情况是不包含子模块，所以应该在`&lt;parent&gt;`标签中添加`&lt;relativePath&gt;`标签即可测试通过。

十二.maven配置阿里云镜像
-------

修改`setting.xml`文件，添加镜像地址

```xml
 &lt;mirrors&gt;
      &lt;mirror&gt;
	&lt;id&gt;nexus-aliyun&lt;/id&gt;
	&lt;mirrorOf&gt;*&lt;/mirrorOf&gt;
	&lt;name&gt;Nexus aliyun&lt;/name&gt;
	&lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;
      &lt;/mirror&gt;
  &lt;/mirrors&gt;
```

&amp;gt; 这个地址下载 jar 包的速度，谁用谁知道！

&amp;gt; [https://blog.csdn.net/weixin_37766296/article/details/79594837](https://blog.csdn.net/weixin_37766296/article/details/79594837)

**优点**

1. Maven是一个项目管理和综合工具。Maven提供了开发人员构建一个完整的生命周期框架。
2. 在多个开发团队环境时，Maven可以设置按标准在非常短的时间里完成配置工作，使开发人员的工作更加轻松。
3. Maven增加可重用性并负责建立相关的任务。

&amp;gt; [https://www.cnblogs.com/sgh1023/p/10900130.html](https://www.cnblogs.com/sgh1023/p/10900130.html)

**Maven常用命令**

clean：删除项目中已经编译好的信息，删除target目录

compile：Maven工程的编译命令，用于编译项目的源代码，将src/main/java下的文件编译成class文件输出到target目录下。

test：使用合适的单元测试框架运行测试。

package：将编译好的代码打包成可分发的格式，如JAR，WAR。

install：安装包至本地仓库，以备本地的其它项目作为依赖使用。

deploy：复制最终的包至远程仓库，共享给其它开发人员和项目（通常和一次正式的发布相关）。

每一个构建项目的命令都对应了maven底层一个插件。

**Maven命令package、install、deploy的联系与区别**

mvn clean package依次执行了clean、resources、compile、testResources、testCompile、test、jar(打包)等7个阶段。

mvn clean install依次执行了clean、resources、compile、testResources、testCompile、test、jar(打包)、install等8个阶段。

mvn clean deploy依次执行了clean、resources、compile、testResources、testCompile、test、jar(打包)、install、deploy等9个阶段。

主要区别：

package命令完成了项目编译、单元测试、打包功能，但没有把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库和远程maven私服仓库。

install命令完成了项目编译、单元测试、打包功能，同时把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库，但没有布署到远程maven私服仓库。

deploy命令完成了项目编译、单元测试、打包功能，同时把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库和远程maven私服仓库。　

**Maven生命周期**

清理生命周期：运行mvn clean将调用清理生命周期 。

默认生命周期：是一个软件应用程序构建过程的总体模型 。

compile，test，package，install，deploy

站点生命周期：为一个或者一组项目生成项目文档和报告，使用较少。

&amp;gt; [https://blog.csdn.net/noaman_wgs/article/details/81137893](https://blog.csdn.net/noaman_wgs/article/details/81137893)

Maven中 jar包冲突原理与解决办法
&lt;/relativePath&gt;&lt;/parent&gt;&lt;/relativePath&gt;&lt;/exclusions&gt;
</description>
        <pubDate>Thu, 05 Mar 2020 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/03/05/maven/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/03/05/maven/</guid>
        
        <category>学习</category>
        
        
      </item>
    
      <item>
        <title>Shiro</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/wmyskxz/p/10229148.html&quot;&gt;https://www.cnblogs.com/wmyskxz/p/10229148.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_26648623/article/details/84062666&quot;&gt;https://blog.csdn.net/qq_26648623/article/details/84062666&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;应用安全的四大基石&lt;/p&gt;

    &lt;p&gt;认证：用户身份识别，通常被称为用户“登录”。&lt;/p&gt;

    &lt;p&gt;授权：访问控制。比如某个用户是否具有某个操作的使用权限。&lt;/p&gt;

    &lt;p&gt;会话管理：特定于用户的会话管理,甚至在非web 或 EJB 应用程序。&lt;/p&gt;

    &lt;p&gt;加密：在对数据源使用加密算法加密的同时，保证易于使用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;三个主要的理念&lt;/p&gt;

    &lt;p&gt;Subject：当前用户，Subject 可以是一个人，但也可以是第三方服务、守护进程帐户、时钟守护任务或者其它–当前和软件交互的任何事件。&lt;/p&gt;

    &lt;p&gt;SecurityManager：管理所有Subject，SecurityManager 是 Shiro 架构的核心，配合内部安全组件共同组成安全伞。&lt;/p&gt;

    &lt;p&gt;Realms：用于进行权限信息的验证，我们自己实现。Realm 本质上是一个特定的安全 DAO：它封装与数据源连接的细节，得到Shiro 所需的相关的数据。在配置 Shiro 的时候，你必须指定至少一个Realm 来实现认证（authentication）和/或授权（authorization）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Shiro 加密&lt;/p&gt;

    &lt;p&gt;在之前的学习中，我们在数据库中保存的密码都是明文的，一旦数据库数据泄露，那就会造成不可估算的损失，所以我们通常都会使用非对称加密，简单理解也就是不可逆的加密，而 md5 加密算法就是符合这样的一种算法。&lt;/p&gt;

    &lt;p&gt;如上面的 123456 用 Md5 加密后，得到的字符串：e10adc3949ba59abbe56e057f20f883e，就无法通过计算还原回 123456，我们把这个加密的字符串保存在数据库中，等下次用户登录时我们把密码通过同样的算法加密后再从数据库中取出这个字符串进行比较，就能够知道密码是否正确了，这样既保留了密码验证的功能又大大增加了安全性，但是问题是：虽然无法直接通过计算反推回密码，但是我们仍然可以通过计算一些简单的密码加密后的 Md5 值进行比较，推算出原来的密码&lt;/p&gt;

    &lt;p&gt;比如我的密码是 123456，你的密码也是，通过 md5 加密之后的字符串一致，所以你也就能知道我的密码了，如果我们把常用的一些密码都做 md5 加密得到一本字典，那么就可以得到相当一部分的人密码，这也就相当于“破解”了一样，所以其实也没有我们想象中的那么“安全”。&lt;/p&gt;

    &lt;p&gt;既然相同的密码 md5 一样，那么我们就让我们的原始密码再加一个随机数，然后再进行 md5 加密，这个随机数就是我们说的盐(salt)，这样处理下来就能得到不同的 Md5 值，当然我们需要把这个随机数盐也保存进数据库中，以便我们进行验证。&lt;/p&gt;

    &lt;p&gt;另外我们可以通过多次加密的方法，即使黑客通过一定的技术手段拿到了我们的密码 md5 值，但它并不知道我们到底加密了多少次，所以这也使得破解工作变得艰难。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/romantic_PK/article/details/81510003&quot;&gt;https://blog.csdn.net/romantic_PK/article/details/81510003&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Shiro认证流程&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;subject(主体)请求认证，调用subject.login(token)&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;SecurityManager (安全管理器)执行认证&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;SecurityManager通过ModularRealmAuthenticator进行认证。&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;ModularRealmAuthenticator将token传给realm，realm根据token中用户信息从数据库查询用户信息（包括身份和凭证）&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;realm如果查询不到用户给ModularRealmAuthenticator返回null，ModularRealmAuthenticator抛出异常（用户不存在）&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;realm如果查询到用户给ModularRealmAuthenticator返回AuthenticationInfo(认证信息)&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;ModularRealmAuthenticator拿着AuthenticationInfo(认证信息)去进行凭证（密码）比对。&lt;/strong&gt;如果一致则认证通过，如果不致抛出异常（凭证错误）。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Shiro授权流程&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;对subject进行授权，调用方法isPermitted(“&lt;em&gt;“)或者hasRole(“&lt;/em&gt;”)&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;SecurityManager执行授权，通过ModularRealmAuthorizer执行授权&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;ModularRealmAuthorizer执行realm（自定义的CustomRealm）从数据库查询权限数据调用realm的授权方法：doGetAuthorizationInfo&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;realm从数据库查询权限数据，返回ModularRealmAuthorizer&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;ModularRealmAuthorizer调用PermissionResolver进行权限串比对&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;如果比对后，isPermitted中”permission串”在realm查询到权限数据中，说明用户访问permission串有权限，否则没有权限，抛出异常。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;慕课网&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;什么是Shiro？&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Apache的强大灵活的开源安全框架&lt;/li&gt;
  &lt;li&gt;认证、授权、企业会话管理、缓存管理、安全加密&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Shiro与Spring Security比较&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Apache Shiro：简单、灵活，可脱离Spring，粒度较粗&lt;/li&gt;
  &lt;li&gt;Spring Security：复杂、笨重，不可脱离Spring，粒度更细&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Shiro整体架构&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SecurityManager是Shiro的核心，Shiro通过Security Manager提供安全服务。&lt;/li&gt;
  &lt;li&gt;认证器(Authenticator)管理登入登出，授权器(Authorizer)赋予主体有哪些权限。Realm是Shiro和数据库之间的桥梁，Shiro获取认证数据、权限数据都是通过Realm。主体提交请求到Security Manager，SecurityManager调用认证器去认证，认证器获取认证数据的时候是通过Realm来获取，从数据库中来获取信息和主题提交过来的认证数据去比对。&lt;/li&gt;
  &lt;li&gt;session管理器，shiro自己实现了一套session管理机制，可以不借助任何web容器的情况下使用session。Session Dao提供了Session的操作，主要是由增删改查。&lt;/li&gt;
  &lt;li&gt;Cache Manager是缓存管理器，可以缓存角色数据和权限数据。&lt;/li&gt;
  &lt;li&gt;Cryptography是用来做数据加密的。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/li383200888/article/details/76904284&quot;&gt;https://blog.csdn.net/li383200888/article/details/76904284&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;认证原理：&lt;/p&gt;

&lt;p&gt;1、通过ini配置文件创建securityManager&lt;/p&gt;

&lt;p&gt;2、调用subject.login方法主体提交认证，提交的token&lt;/p&gt;

&lt;p&gt;3、securityManager进行认证，securityManager最终由ModularRealmAuthenticator进行认证。&lt;/p&gt;

&lt;p&gt;4、ModularRealmAuthenticator调用IniRealm(给realm传入token) 去ini配置文件中查询用户信息&lt;/p&gt;

&lt;p&gt;5、IniRealm根据输入的token（UsernamePasswordToken，即这里的token是用户从页面输入的信息）从 shiro-first.ini查询用户信息（这里是测试阶段，后面都是查询的数据库，注入service，调用dao），根据账号查询用户信息（账号和密码）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;      如果查询到用户信息，就给ModularRealmAuthenticator返回用户信息（账号和密码）

      如果查询不到，就给ModularRealmAuthenticator返回null
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;6、ModularRealmAuthenticator接收IniRealm返回Authentication认证信息&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;      如果返回的认证信息是null，ModularRealmAuthenticator抛出异常（org.apache.shiro.authc.UnknownAccountException）

      如果返回的认证信息不是null（说明inirealm找到了用户），对IniRealm返回用户密码 （在ini文件中存在）和 token中的密码 进行对比，如果不一致抛出异常（org.apache.shiro.authc.IncorrectCredentialsException）
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/baidu_22254181/article/details/82594072&quot;&gt;https://blog.csdn.net/baidu_22254181/article/details/82594072&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;对称加密：AES/DES/3DES&lt;/li&gt;
  &lt;li&gt;非对称加密：RSA、ECC&lt;/li&gt;
  &lt;li&gt;散列加密：MD5、SHA1&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 05 Mar 2020 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/03/05/shiro/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/03/05/shiro/</guid>
        
        <category>学习</category>
        
        
      </item>
    
      <item>
        <title>操作系统</title>
        <description>&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;什么是死锁？&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;王道操作系统P114&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;&lt;strong&gt;死锁是指多个进程因竞争资源而造成一种僵局（互相等待）&lt;/strong&gt;，若无外力作用，这些进程都无法向前推进。&lt;/p&gt;

    &lt;p&gt;例如，某计算机系统只有一台答应及和一台输入设备，进程P1正占用输入设备，同时又提出使用答应及的请求，但此时打印机正被进程P2所占用，而P2在未释放打印机之前，又提出请求使用正被P1占用着的输入设备。这样两个进程相互无休止地进行下去，均无法继续执行，此时两个进程陷入死锁状态。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;死锁预防：破坏死锁产生的四个必要条件，只要其中任一条件不成立，死锁就不会发生。&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;互斥条件&lt;/strong&gt;：进程要求对锁分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占用。此时若有其他进程请求该资源，则请求进程只能等待。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;不剥夺条件&lt;/strong&gt;：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放）。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;请求和保持条件&lt;/strong&gt;：进程已经保持了至少一个资源，但由提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。&lt;/p&gt;

            &lt;p&gt;为了破坏请求和保持条件，采用预先静态分配方法，即进程在运行前&lt;strong&gt;一次申请完它所需要的全部资源&lt;/strong&gt;，在它的资源未满足前，不把它投入运行。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;循环等待条件&lt;/strong&gt;：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求。&lt;/p&gt;

            &lt;p&gt;为了破坏循环等待条件，采用&lt;strong&gt;顺序资源分配法&lt;/strong&gt;。首先给系统中的资源编号，规定&lt;strong&gt;每个进程必须按编号递增的顺序请求资源&lt;/strong&gt;，同类资源一次申请完。&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;死锁避免：银行家算法&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;死锁检测与解除：资源分配图、死锁定理&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;JAVA中如何确保N个线程可以访问N个资源，但同时又不导致死锁？&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/questionTerminal/7192c9454277483d8711a7b4237a0bbe&quot;&gt;https://www.nowcoder.com/questionTerminal/7192c9454277483d8711a7b4237a0bbe&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;多线程产生死锁需要四个条件，分别是互斥性，保持和请求，不可剥夺性还有要形成闭环，这四个条件缺一不可，只要破坏了其中一个条件就可以破坏死锁，其中最简单的方法就是线程都是以同样的顺序加锁和释放锁，也就是破坏了第四个条件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;怎么理解操作系统里的内存碎片，有什么解决办法？&lt;/p&gt;

    &lt;p&gt;内存碎片分为：内部碎片和外部碎片。&lt;/p&gt;

    &lt;p&gt;内部碎片就是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间；&lt;/p&gt;

    &lt;p&gt;内部碎片是处于区域内部或页面内部的存储块。占有这些区域或页面的进程并不使用这个存储块。而在进程占有这块存储块时，系统无法利用它。直到进程释放它，或进程结束时，系统才有可能利用这个存储块。&lt;/p&gt;

    &lt;p&gt;单道连续分配只有内部碎片。多道固定连续分配既有内部碎片，又有外部碎片。&lt;/p&gt;

    &lt;p&gt;外部碎片指的是还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。&lt;/p&gt;

    &lt;p&gt;外部碎片是出于任何已分配区域或页面外部的空闲存储块。这些存储块的总和可以满足当前申请的长度要求，但是由于它们的地址不连续或其他原因，使得系统无法满足当前申请。&lt;/p&gt;

    &lt;p&gt;使用伙伴系统算法。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;王道操作系统P144 连续分配管理方式&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;固定分区分配是最简单的一种多道程序存储管理方式，它将用户内存空间划分为若干个固定的区域，每个分区只装入一道作业。当程序小于固定分区大小时，也占用了一个完整的内存分区空间，这样分区内部有空间浪费，这种现象称为内部碎片。&lt;/p&gt;

    &lt;p&gt;动态分区分配不预先将内存划分，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。动态分区在开始分配时是很好的，但是之后会导致内存中出现许多小的内存块。随着时间的推移，内存中会产生越来越多的碎片，这些小的内存碎片称为外部碎片。克服外部碎片可以通过紧凑技术来解决。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;什么是页式存储？&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;王道操作系统 P147 非连续分配管理方式&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;&lt;strong&gt;页式存储的好处&lt;/strong&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;非连续分配允许一个程序分散地装入到不相邻的内存分区中。在连续分配管理方式中我们发现，即使内存有超过1GB的空虚空间，但如果没有连续的1GB的空间，需要1GB空间的作业仍然是无法运行的；但如果采用非连续分配管理方式，作业所要求的1GB内存空间可以分散地分配在内存的各个区域，当然，这也需要额外的空间去存储它们（分散区域）的索引，使得非连续分配方式的存储密度低于连续存储方式。&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;固定分区会产生内部碎片，动态分区会产生外部碎片，这两种技术对内存的利用率都比较低。我们希望内存的使用能尽量避免碎片的产生，这就引入的分页的思想：把主存空间划分为相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。&lt;/p&gt;

    &lt;p&gt;分页的方法从形式上看，像分区相等的固定技术，分页管理不会产生外部碎片。但它又有本质的不同点：块的大小相对分区要小很多，而且进程也按照块进行划分，进程运行时按块申请主存可用空间并执行。这样，进程只会在为最后一个不完整的块申请一个主存块空间时，才产生主存碎片，所以尽管会产生内部碎片，但是这种碎片相对于进程来说也是很小的，每个进程平均只产生半个块大小的内部碎片（也是页内碎片）。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;基本分页存储管理方式&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;分页存储管理的逻辑地址结构：页号P、页内偏移量W&lt;/p&gt;

    &lt;p&gt;页表项：页号P、块号b&lt;/p&gt;

    &lt;p&gt;页号根据页表查到块号，与页内偏移量拼接，得到物理地址。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;基本分段存储管理方式&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;分段系统中的逻辑地址结构：段号S、段内偏移量W&lt;/p&gt;

    &lt;p&gt;段表项：段号S、段长C、基址b&lt;/p&gt;

    &lt;p&gt;段号根据段表查到基址，加上段内偏移量，得到物理地址。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;段页式管理方式&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;段页式系统的逻辑地址结构：段号S、页号P、页内偏移量W&lt;/p&gt;

    &lt;p&gt;段号根据段表查到页表的起始地址。页号根据页表查到块号，与页内偏移量拼接，得到物理地址。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;缺页中断&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;王道P175 虚拟内存管理&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;&lt;strong&gt;在请求分页系统中，每当所要访问的页面不在内存时，便产生一个缺页中断，请求操作系统将所缺的页调入内存。此时应将缺页的进程阻塞（调页完成唤醒），如果内存中有空闲块，则分配一个块，将要调入的页装入该块，并修改页表中相应页项，若此时内存中没有空闲块，则要淘汰某页（若被淘汰页在内存期间被修改过，则要将其写回外存）。&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;缺页中断作为中断同样要经历，诸如保护CPU环境、分析中断原因、转入缺页中断处理程序、恢复CPU环境等几个步骤。但与一般的中断相比，它有一下两个明显的区别：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;在指令执行期间产生和处理中断信号，而非一条指令执行完后，属于内部中断。&lt;/li&gt;
      &lt;li&gt;一条指令在执行期间，可能产生多次缺页中断。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;页面置换算法&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;王道操作系统P176 页面置换算法&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;最佳(OPT)置换算法&lt;/p&gt;

        &lt;p&gt;最佳置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;先进先出(FIFO)置换算法&lt;/p&gt;

        &lt;p&gt;优先淘汰最早进入内存的页面，亦即在内存中驻留时间最久的页面。&lt;/p&gt;

        &lt;p&gt;FIFO算法会产生党所分配的物理块数增大而页故障数不增反减的异常现象，称为Belady异常。只有FIFO算法可能出现Belady异常，而LRU和OPT算法永远不会出现Belady异常。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;最近最久未使用(LRU)置换算法&lt;/p&gt;

        &lt;p&gt;它认为过去一段时间内未访问过的页面，在最近的将来可能也不会被访问。该算法未每个页面设置一个访问字段，来记录页面自上次被访问以来所经历的时间，淘汰页面时选择现有页面中值最大的予以淘汰。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;时钟(CLOCK)置换算法&lt;/p&gt;

        &lt;p&gt;又称为最近未用(NRU)算法。给每一帧关联一个附加位，称为使用位。当某一页首次装入主存时，该帧的使用位设置为1；当该页随后再被访问到时，它的使用位也被置为1。当需要替换一页时，操作系统扫描缓冲区，以查找使用位被置为0的一帧。当遇到一个使用位为1的帧时，操作系统就将该位重新置为0。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;进程的通信&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;王道操作系统P32&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;共享存储、消息传递、管道通信&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;进程切换和线程切换&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;王道操作系统P30&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;对于通常的进程，其创建、撤销以及要求由系统设备完成的I/O操作都是利用系统调用而进入内核，再由内核中相应处理程序予以完成的。进程切换同样是在内核的支持下实现的，因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。&lt;/p&gt;

    &lt;p&gt;进程切换是指处理及由一个进程的运行转到另一个进程上运行，这个过程中，进程的运行环境产生了实质性的变化。进程切换的过程如下：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;保存处理机上下文，包括程序计数器和其他寄存器。&lt;/li&gt;
      &lt;li&gt;更新PCB信息。&lt;/li&gt;
      &lt;li&gt;把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。&lt;/li&gt;
      &lt;li&gt;选择另一个进程执行，并更新其PCB。&lt;/li&gt;
      &lt;li&gt;更新内存管理的数据结构。&lt;/li&gt;
      &lt;li&gt;恢复处理机上下文。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如何理解僵尸进程，如何解决僵尸进程&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;http://www.nowamagic.net/librarys/veda/detail/1994&quot;&gt;http://www.nowamagic.net/librarys/veda/detail/1994&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;僵尸进程是指一个已经终止、但是其父进程尚未对其进行善后处理获取终止进程的有关信息的进程，这个进程被称为“僵尸进程”(zombie)。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;kill与kill -9的区别&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/yushouxiang2014/article/details/82876405&quot;&gt;https://blog.csdn.net/yushouxiang2014/article/details/82876405&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;默认参数下，kill 发送SIGTERM（15）信号给进程，告诉进程，你需要被关闭，请自行停止运行并退出。&lt;/p&gt;

    &lt;p&gt;kill -9 发送SIGKILL信号给进程，告诉进程，你被终结了，请立刻退出。&lt;/p&gt;

    &lt;p&gt;TERM(或数字9）表示“无条件终止”；&lt;/p&gt;

    &lt;p&gt;因此 kill - 9 表示强制杀死该进程；与SIGTERM相比，这个信号不能被捕获或忽略，同时接收这个信号的进程在收到这个信号时不能执行任何清理。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 05 Mar 2020 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/03/05/os/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/03/05/os/</guid>
        
        <category>学习</category>
        
        
      </item>
    
      <item>
        <title>网络</title>
        <description>&lt;h4 id=&quot;网络概述&quot;&gt;网络概述&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;TCP协议、IP协议、HTTP协议分别在哪一层？&lt;/p&gt;

    &lt;p&gt;运输层，网络层，应用层。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://uploadfiles.nowcoder.com/images/20190814/980266035_1565787665824_1ABB2DC3D76311944FFDBE9980FBAADD&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;王道网络P15 ISO/OSI参考模型和TCP/IP模型&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;OSI参考模型：&lt;strong&gt;物理层、数据链路层、网络层、运输层、会话层（会话管理）、表示层（数据格式转换）、应用层&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;TCP/IP模型：网络接口层、网际层、传输层、应用层&lt;/p&gt;

    &lt;p&gt;学习计算机网络：物理层、数据链路层、网络层、传输层、应用层&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://snailclimb.gitee.io/javaguide/#/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C&quot;&gt;https://snailclimb.gitee.io/javaguide/#/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;&lt;strong&gt;物理层&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;在物理层上所传送的数据单位是比特。 &lt;strong&gt;物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。&lt;/strong&gt; 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;数据链路层&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;数据链路层(data link layer)通常简称为链路层。&lt;strong&gt;两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。&lt;/strong&gt; 在两个相邻节点之间传送数据时，&lt;strong&gt;数据链路层将网络层交下来的 IP 数据报组装成帧&lt;/strong&gt;，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。&lt;/p&gt;

    &lt;p&gt;在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。 控制信息还使接收端能够检测到所收到的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;网络层&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。&lt;/strong&gt; 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称 数据报。&lt;/p&gt;

    &lt;p&gt;这里要注意：不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。&lt;/p&gt;

    &lt;p&gt;这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称.&lt;/p&gt;

    &lt;p&gt;互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Protocol）和许多路由选择协议，因此互联网的网络层也叫做网际层或IP层。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;运输层&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。&lt;/strong&gt; 应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。&lt;/p&gt;

    &lt;p&gt;运输层主要使用以下两种协议:&lt;/p&gt;

    &lt;p&gt;传输控制协议 TCP（Transmission Control Protocol）–提供面向连接的，可靠的数据传输服务。&lt;/p&gt;

    &lt;p&gt;用户数据协议 UDP（User Datagram Protocol）–提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;应用层&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。&lt;/strong&gt; 应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如&lt;strong&gt;域名系统DNS&lt;/strong&gt;，支持万维网应用的 &lt;strong&gt;HTTP协议&lt;/strong&gt;，支持电子邮件的 &lt;strong&gt;SMTP协议&lt;/strong&gt; 等等。我们把应用层交互的数据单元称为报文。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;网络层&quot;&gt;网络层&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;arp协议和arp攻击&lt;/p&gt;

    &lt;p&gt;地址解析协议。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/wy_bk/article/details/78823573&quot;&gt;https://blog.csdn.net/wy_bk/article/details/78823573&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;&lt;strong&gt;ARP协议&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;ARP协议是一个年代相当“久远”的网络协议。ARP协议制定于1982年11月，英文全称：Address Resolution Protocol，即“地址解析协议”。&lt;/p&gt;

    &lt;p&gt;我们知道，虽然终端设备想要上网必须具有公有IP地址，但是在Internet的TCP/IP协议中，IP地址的作用是标识一台主机或路由器与一条链路的接口，也就是说IP地址指明了数据由一个网络传输到另一个网络的路径，但是我们知道，为了节约IP地址，通常情况下，在一个内部网络中，主机常常使用RFC规定的三种私有IP地址作为局域网中主机的IP地址，而且主机的IP地址是由该网络的路由器动态分配的，如果数据的传输仅仅依赖于IP地址，那么当数据到达一个内部网络中时就可能因为目标主机的IP地址发生改变而将数据传输到了错误的目标主机。但是不同设备的物理地址（MAC）是全网唯一的，而且一般也不会被改变（MAC地址是写入网卡的，固定的），因此使用MAC地址作为信息的标识，定位目标网络设备就可以保证信息能够正确抵达目标主机。而通过目标设备的IP地址查找目标设备的MAC地址就是ARP协议的基本功能。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;ARP协议的工作过程&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;由于内部网络中主机的IP地址往往是动态分配的，因此，在主机中是有ARP缓存的，记录着本网络中IP地址与MAC地址的对应关系。那么，这个ARP缓存是怎么生成的呢？首先，当网络中的主机A需要向主机B发送信息时，会将包含目标IP地址的ARP请求广播到该网络中的所有主机上，网络中的其他主机在收到主机A的ARP请求后可以自主的发送ARP应答报文，应答中包含自己的IP和自己的MAC地址，主机B也会发送这样的应答报文给主机A。这样主机A就知道了主机B的MAC地址与IP地址了。&lt;/p&gt;

    &lt;p&gt;ARP协议的工作是建立在网络中各个主机之间相互信任的基础上的，一台主机在收到其他主机的ARP应答报文时并不会采取措施校验该报文的真实性，而是直接就记录到了自己的ARP缓存中以备下次使用。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;ARP攻击&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;ARP攻击的第一步就是ARP欺骗。由上述“ARP协议的工作过程”我们知道，ARP协议基本没有对网络的安全性做任何思考，当时人们考虑的重点是如何保证网络通信能够正确和快速的完成——ARP协议工作的前提是默认了其所在的网络是一个善良的网络，每台主机在向网络中发送应答信号时都是使用的真实身份。不过后来，人们发现ARP应答中的IP地址和MAC地址中的信息是可以伪造的，并不一定是自己的真实IP地址和MAC地址，由此，ARP欺骗就产生了。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;ARP欺骗&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;ARP的应答报文是可以伪造的。假设一个网络中有3台主机，分别为A、B和C。当主机A向网络中发送了ARP请求时，用于攻击的主机C可以假装是B，然后向主机A发送一个伪造的ARP应答报文，由于A并不会采取措施验证该报文真伪，而是直接存入自己的ARP缓存并在需要时使用（ARP缓存分两种，一种是静态ARP缓存，该类缓存只要主机不关机就一直存在。另一类是动态ARP缓存，该类缓存是有时效限制的，一般ARP动态缓存的最长生命周期是10分钟，如果一个动态缓存项目在2分钟内没有被使用，则删除，如果在两分钟内被使用了，则增加两分钟的生命周期，直到达到10分钟的最长生命周期后进行更新），由此，C就成功的欺骗了A。那么来自主机B的正确的应答报文去哪了？如果A收到了来自B的正确的应答报文，更新了自己的ARP缓存，那么C的ARP欺骗不就失败了吗？确实会发生这种情况，但是如果C不断的向网络中的各台主机大量发送伪造的ARP应答报文，直到同时欺骗了A和B，C就成功的对主机A和B进行了ARP欺骗。接下来C就可以监听A和B之间的流量，伪造A和B的通信内容或者阻止A和B的通信。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;王道网络P149 地址解析协议ARP&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;无论网络层使用什么协议，在实际网络的链路上传送数据帧时，最终必须使用硬件地址。所以需要一种方法来完成IP地址到MAC地址的映射，这就是地址解析协议ARP。每个主机都设有一个ARP高速缓存，存放本局域网上各主机和路由器的IP地址到MAC地址的映射表，称ARP表，使用ARP协议来动态维护此ARP表。&lt;/p&gt;

    &lt;p&gt;ARP工作在网络层，其工作原理：当主机A欲向本局域网上的某个主机B发送IP数据报时，就先在其ARP高速缓存中查看有无主机B的IP地址。如有，就可查出其对应的硬件地址，再将此硬件地址写入MAC帧，然后通过局域网将该MAC帧发往此硬件地址。如果没有，就通过使用目的MAC地址为FF-FF-FF-FF-FF-FF的帧来封装并广播ARP请求分组，可以使同一个局域网里的所有主机收到ARP请求。当主机B收到该ARP请求后，就会向主机A发出响应ARP分组，分组中包含主机B的IP与MAC地址的映射关系，主机A再收到后将此映射写入ARP缓存中，然后按查询到的硬件地址发送MAC帧。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;什么是icmp协议，它的作用是什么？&lt;/p&gt;

    &lt;p&gt;它是TCP/IP协议族的一个子协议，&lt;strong&gt;用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息&lt;/strong&gt;。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;王道网络P151 网络控制报文协议ICMP&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;为了提高IP数据报交付成功的机会，&lt;strong&gt;在网络层使用了网际控制报文协议(ICMP)来允许主机或路由器报告差错和异常情况&lt;/strong&gt;。ICMP协议是IP层协议。ICMP报文的种类有两种，即ICMP差错报告报文（包括源点抑制）和ICMP询问报文。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DHCP协议&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;王道网络P150 动态主机配置协议DHCP&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;动态主机配置协议(DHCP)常用于&lt;strong&gt;给主机动态地分配IP地址&lt;/strong&gt;，它提供了即插即用联网的机制，这种机制允许一台计算机加入新的网络和获取IP地址而不用手工参与。DHCP是应用层协议，它是基于UDP的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;路由器和交换机的区别&lt;/p&gt;

    &lt;p&gt;1、工作层次不同：交换机比路由器更简单，路由器比交换器能获取更多信息&lt;/p&gt;

    &lt;p&gt;交换机工作在数据链路层，而路由器工作在网络层&lt;/p&gt;

    &lt;p&gt;2、数据转发所依据的对象不同&lt;/p&gt;

    &lt;p&gt;交换机的数据转发依据是利用物理地址或者说MAC地址来确定转发数据的目的地址&lt;/p&gt;

    &lt;p&gt;而路由器是依据ip地址进行工作的&lt;/p&gt;

    &lt;p&gt;3、传统的交换机只能分割冲突域，不能分割广播域；而路由器可以分割广播域&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;传输层&quot;&gt;传输层&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;为什么tcp为什么要建立连接？&lt;/p&gt;

    &lt;p&gt;保证可靠传输。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;解释一下TCP为什么可靠一些&lt;/p&gt;

    &lt;p&gt;三次握手，超时重传，滑动窗口，拥塞控制。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;王道网络P218&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;&lt;strong&gt;TCP连接管理&lt;/strong&gt;：三次握手、四次挥手&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;TCP可靠传输&lt;/strong&gt;：累计确认、超时和冗余ACK重传&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;TCP流量控制&lt;/strong&gt;：接收端控制发送端速率（发送窗口的实际大小是接受窗口和拥塞窗口的最小值）&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;TCP拥塞控制&lt;/strong&gt;：慢开始（指数规律增长）、拥塞避免（加法增大）、快恢复（j，乘法减小）&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://snailclimb.gitee.io/javaguide/#/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C&quot;&gt;https://snailclimb.gitee.io/javaguide/#/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;&lt;strong&gt;TCP 协议如何保证可靠传输&lt;/strong&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;应用数据被分割成 TCP 认为最适合发送的数据块。&lt;/li&gt;
      &lt;li&gt;TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。&lt;/li&gt;
      &lt;li&gt;校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。&lt;/li&gt;
      &lt;li&gt;TCP 的接收端会丢弃重复的数据。&lt;/li&gt;
      &lt;li&gt;流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）&lt;/li&gt;
      &lt;li&gt;拥塞控制： 当网络拥塞时，减少数据的发送。&lt;/li&gt;
      &lt;li&gt;ARQ协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。&lt;/li&gt;
      &lt;li&gt;超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;哪种应用场景会使用TCP协议，使用它的意义&lt;/p&gt;

    &lt;p&gt;当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TCP,UDP 协议的区别&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://snailclimb.gitee.io/javaguide/#/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C&quot;&gt;https://snailclimb.gitee.io/javaguide/#/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;&lt;img src=&quot;https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/tcp-vs-udp.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等&lt;/p&gt;

    &lt;p&gt;TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TCP的连接和释放过程&lt;/p&gt;

    &lt;p&gt;三次握手的过程&lt;/p&gt;

    &lt;p&gt;1）主机A向主机B发送TCP连接请求数据包，其中包含主机A的初始序列号seq(A)=x。（其中报文中同步标志位SYN=1，ACK=0，表示这是一个TCP连接请求数据报文；序号seq=x，表明传输数据时的第一个数据字节的序号是x）；&lt;/p&gt;

    &lt;p&gt;2）主机B收到请求后，会发回连接确认数据包。（其中确认报文段中，标识位SYN=1，ACK=1，表示这是一个TCP连接响应数据报文，并含主机B的初始序列号seq(B)=y，以及主机B对主机A初始序列号的确认号ack(B)=seq(A)+1=x+1）&lt;/p&gt;

    &lt;p&gt;3）第三次，主机A收到主机B的确认报文后，还需作出确认，即发送一个序列号seq(A)=x+1；确认号为ack(A)=y+1的报文；&lt;/p&gt;

    &lt;p&gt;四次挥手过程&lt;/p&gt;

    &lt;p&gt;假设主机A为客户端，主机B为服务器，其释放TCP连接的过程如下：
1） 关闭客户端到服务器的连接：首先客户端A发送一个FIN，用来关闭客户到服务器的数据传送，然后等待服务器的确认。其中终止标志位FIN=1，序列号seq=u。
2） 服务器收到这个FIN，它发回一个ACK，确认号ack为收到的序号加1。
3） 关闭服务器到客户端的连接：也是发送一个FIN给客户端。&lt;/p&gt;

    &lt;p&gt;4） 客户段收到FIN后，并发回一个ACK报文确认，并将确认序号seq设置为收到序号加1。 首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;王道网络P213 TCP协议&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;&lt;strong&gt;TCP连接的建立&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://uploadfiles.nowcoder.com/images/20180927/308572_1538027722640_EBFE71FE6E03CBB1AAE38A25DC56AFB2&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;连接的建立经历以下3个步骤，通常称为“三次握手”。&lt;/p&gt;

    &lt;p&gt;第一步：客户机的TCP首先向服务器的TCP发送一个连接请求报文段。这个特殊的报文段重不含应用层数据，起首部中的SYN标志位被置为1。另外，客户机会随机选择一个起始序号seq=x（连接请求报文不携带数据，但要消耗掉一个序号）&lt;/p&gt;

    &lt;p&gt;第二步：服务器的TCP收到连接请求报文段后，如同意连接，就像客户机发回确认，并为该TCP连接分配TCP缓存和变量。在确认报文段中，SYN和ACK位都被置为1，确认号字段的值为x+1，并且服务器随机产生其实序号seq=y（确认报文不携带数据，但也要消耗掉一个序号）。确认报文段同样不包含应用层数据。&lt;/p&gt;

    &lt;p&gt;第三步：当客户机收到确认报文段后，还要向服务器给出确认，并且也要给该连接分配缓存和变量。这个报文段的ACK标志位被置为1，序号字段为x+1，确认号字段ack=y+1。该报文段可以携带数据，如果不携带数据则不消耗序号。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;TCP连接的释放&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://uploadfiles.nowcoder.com/images/20180927/308572_1538027843891_F17231DF387BA79A4CCC2E7CDD1C110E&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;TCP连接释放的过程通常称为“四次挥手”。&lt;/p&gt;

    &lt;p&gt;第一步：客户机打算关闭连接，就向其TCP发送一个连接释放报文段，并停止再发送数据，主动关闭TCP连接，该报文段的FIN标志位被置为1，seq=u，它等于前面已传送过的数据的最后一个字节的序号加1（FIN报文段即使不携带数据，也要消耗一个序号）。TCP是全双工的，即可以想象成是一条TCP连接上有两条数据通路。当发送FIN报文时，发送FIN的一端就不能再发送数据，也就是关闭了其中一条数据通路，但对方好可以发送数据。&lt;/p&gt;

    &lt;p&gt;第二步：服务器收到连接释放报文段后即发出确认，确认号是ack=u+1，而这个报文段自己的序号是v，等于它前面已传送过的数据的最后一个字节的序号加1。此时，从客户机到服务器这个方向的连接就释放了，TCP连接处于半关闭状态。但服务器若发送数据，客户机仍要接收，即从服务器到客户机这个方向的连接并未关闭。&lt;/p&gt;

    &lt;p&gt;第三步：若服务器已经没有要向客户机发送的数据，就通知TCP释放连接，此时它发出FIN=1的连接释放报文段。&lt;/p&gt;

    &lt;p&gt;第四步：客户机收到连接释放报文段后，必须发出确认。在确认报文段中，ACK字段被置为1，确认号ack=w+1，序号seq=u+1。此时TCP连接还没有释放掉，必须经过时间等待计时器设置的时间2MSS后，A才进入到连接关闭状态。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://snailclimb.gitee.io/javaguide/#/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C&quot;&gt;https://snailclimb.gitee.io/javaguide/#/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;&lt;strong&gt;为什么要三次握手&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常&lt;/p&gt;

    &lt;p&gt;第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常&lt;/p&gt;

    &lt;p&gt;第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常&lt;/p&gt;

    &lt;p&gt;所以三次握手就能确认双发收发功能都正常，缺一不可。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;为什么要传回 SYN&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。 ]）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;&lt;strong&gt;传了 SYN,为啥还要传 ACK&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;为什么要四次挥手&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。&lt;/p&gt;

    &lt;p&gt;举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;计算机网络 P225 三次握手&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;&lt;strong&gt;为什么A还要发送一次确认呢？这主要是为了防止已经失效的连接请求报文段突然有传送到了B，因而产生错误。&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;所谓“已失效的连接请求报文段”是这样产生的。考虑一种正常情况，A发出连接请求，但因连接请求报文丢失而未收到确认。于是A再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。A共发送了两个连接请求报文段，其中第一个丢失，第二个到达了B。没有“已失效的连接请求报文段”。&lt;/p&gt;

    &lt;p&gt;现假定一种异常情况，即A发出的第一个连接请求报文段并没有丢失，而是在某些网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达B。本来这是一个早已失效的报文段。但B收到此失效的连接请求报文段后，就误认为是A又发出一次新的连接请求。于是就向A发出确认报文段，同意建立连接。假定不采用三次握手，那么只要B发出确认，新的连接就建立了。&lt;/p&gt;

    &lt;p&gt;由于现在A并没有发出建立连接的请求，因此不会理睬B的确认，也不会向B发送数据。但B却以为新的数据连接已经建立了，并一直等待A发来数据。B的许多资源就这样白白浪费了。&lt;/p&gt;

    &lt;p&gt;采用三次握手的办法可以防止上述现象的发生。例如在刚才的情况下，A不会向B的确认发出确认。B由于收不到确认，就知道A并没有要求建立连接。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;计算机网络 P226 四次挥手&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;&lt;strong&gt;CLOSE-WAIT：发送第二次挥手到发送第三次挥手之间服务端的状态。&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;这是TCP连接处于半关闭状态，即A已经没有数据要发送了，但B若发送数据，A仍要接受。也就是说，从B到A这个方向的连接并未关闭，这个状态可能会持续一些时间。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;TIME-WAIT：发送第四次挥手到关闭之间客户端的状态。&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;时间MSL叫做最长报文段寿命，建议设为2分钟。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;为什么A在TIME-WAIT状态必须等待2MSL的时间呢？&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;第一，为了保证A发送的最后一个ACK报文段能够到达B。&lt;/strong&gt;如果A在TIME-WAIT状态不等待一段时间，而是在发送完ACK报文段后立即释放连接，那么就无法收到B重传的FIN-ACK报文段，因而也不会再发送一次确认报文段。这样，B就无法按照正常步骤进入CLOSED状态。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;第二，防止上一节提到的“已失效的连接请求报文段”出现在本连接中。&lt;/strong&gt;A在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/Shuffle_Ts/article/details/93778635&quot;&gt;https://blog.csdn.net/Shuffle_Ts/article/details/93778635&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;为什么要三次握手&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/Shuffle_Ts/article/details/93909003&quot;&gt;https://blog.csdn.net/Shuffle_Ts/article/details/93909003&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;为什么要四次挥手&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TIME_WAIT和CLOSE_WAIT&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/2eb53fa87219&quot;&gt;https://www.jianshu.com/p/2eb53fa87219&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;为什么需要四次握手&lt;/p&gt;

    &lt;p&gt;因为客户端发送FIN连接请求释放连接后，服务器接受请求后进入CLOSE_WAIT状态，这个状态就是为了让服务段发送还没有发送完的数据，发送完成后再发送FIN信号。&lt;/p&gt;

    &lt;p&gt;TIME_WAIT&lt;/p&gt;

    &lt;p&gt;客户端收到服务的释放连接的请求后，不是立马进入CLOSE状态，而是还要再等待2MSL。理由是：&lt;/p&gt;

    &lt;p&gt;确保最后一个确认报文能够到达。如果没能到达，服务端就会会重发FIN请求释放连接。等待一段时间没有收到重发就说明服务的已经CLOSE了。如果有重发，则客户端再发送一次LAST ack信号&lt;/p&gt;

    &lt;p&gt;等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;滑动窗口的作用&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/32255109&quot;&gt;https://www.zhihu.com/question/32255109&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;滑动窗口实现面向流的可靠性&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;1）最基本的传输可靠性来源于“确认重传”机制。&lt;/p&gt;

    &lt;p&gt;2）TCP的滑动窗口的可靠性也是建立在“确认重传”基础上的。&lt;/p&gt;

    &lt;p&gt;3）发送窗口只有收到对端对于本段发送窗口内字节的ACK确认，m 左边界。&lt;/p&gt;

    &lt;p&gt;4）接收窗口只有在前面所有的段都确认的情况下才会移动左边界。当在前面还有字节未接收但收到后面字节的情况下，窗口不会移动，并不对后续字节确认。以此确保对端会对这些数据重传。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;滑动窗口的流控特性&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;TCP的滑动窗口是动态的，我们可以想象成小学常见的一个数学题，一个水池，体积V，每小时进水量V1，出水量V2。当水池满了就不允许再注入了，如果有个液压系统控制水池大小，那么就可以控制水的注入速率和量。这样的水池就类似TCP的窗口。应用根据自身的处理能力变化，通过本端TCP接收窗口大小控制来对对对端的发送窗口流量限制。&lt;/p&gt;

    &lt;p&gt;应用程序在需要（如内存不足）时，通过API通知TCP协议栈缩小TCP的接收窗口。然后TCP协议栈在下个段发送时包含新的窗口大小通知给对端，对端按通知的窗口来改变发送窗口，以此达到减缓发送速率的目的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;应用层&quot;&gt;应用层&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;SSL四次握手的过程&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;负载均衡 反向代理模式的优点、缺点&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DNS的寻址过程&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;王道网络P242 DNS系统&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;域名系统DNS是因特网使用的命名系统，用来把便于人们记忆的含有特定含义的主机名转换为便于机器处理的IP地址。DNS系统采用客户/服务器模型，其协议运行在UDP之上，使用53号端口。&lt;/p&gt;

    &lt;p&gt;递归查询（比较少用）、迭代查询&lt;/p&gt;

    &lt;p&gt;本地域名服务器分别请求根域名服务器、顶级域名服务器、权限域名服务器&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://snailclimb.gitee.io/javaguide/#/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C&quot;&gt;https://snailclimb.gitee.io/javaguide/#/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在浏览器中输入url地址 -» 显示主页的过程(面试常客)&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/url%E8%BE%93%E5%85%A5%E5%88%B0%E5%B1%95%E7%A4%BA%E5%87%BA%E6%9D%A5%E7%9A%84%E8%BF%87%E7%A8%8B.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;总体来说分为以下几个过程:&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;DNS解析&lt;/li&gt;
      &lt;li&gt;TCP连接&lt;/li&gt;
      &lt;li&gt;发送HTTP请求&lt;/li&gt;
      &lt;li&gt;服务器处理请求并返回HTTP报文&lt;/li&gt;
      &lt;li&gt;浏览器解析渲染页面&lt;/li&gt;
      &lt;li&gt;连接结束&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;各种协议与HTTP协议之间的关系&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AE%E4%B8%8EHTTP%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;状态码&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E7%8A%B6%E6%80%81%E7%A0%81.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP是不保存状态的协议,如何保存用户状态?&lt;/p&gt;

    &lt;p&gt;HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。&lt;/p&gt;

    &lt;p&gt;在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。&lt;/p&gt;

    &lt;p&gt;Cookie 被禁用怎么办?&lt;/p&gt;

    &lt;p&gt;最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Cookie的作用是什么?和Session有什么区别？&lt;/p&gt;

    &lt;p&gt;Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。&lt;/p&gt;

    &lt;p&gt;Cookie 一般用来保存用户信息 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。Session 的主要作用就是通过服务端记录用户的状态。 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。&lt;/p&gt;

    &lt;p&gt;Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。&lt;/p&gt;

    &lt;p&gt;Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;session原理&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/saysmy/p/8535571.html&quot;&gt;https://www.cnblogs.com/saysmy/p/8535571.html&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;为了记录session，在客户端和服务器端都要保存数据，客户端记录一个标记，服务器端不但存储了这个标记同时还存储了这个标记映射的数据。好吧，还是说点白话吧，在客户端记录的其实是一个sessionid，在服务器端记录的是一个key-value形式的数据结构，这里的key肯定是指sessionid了，value就代表session的详细内容。用户在做http请求的时候，总是会把sessionid传递给服务器，然后服务器根据这个sessionid来查询session的内容（也就是上面说到的value）。&lt;/p&gt;

    &lt;p&gt;现在我们重点关注一下sessionid，他是今天问题的关键所在。sessionid在客户端（http的客户端一般就是指浏览器了）是存储在cookie中，当然也有例外（书本上肯定会提到也有保存在url中的，我做程序员这么多年也没有见过这种方式，这难道就是现实和实际的差距吗，好残酷）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;session 生命周期&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/bylhjcsmmd/article/details/53158898&quot;&gt;https://blog.csdn.net/bylhjcsmmd/article/details/53158898&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP长连接,短连接&lt;/p&gt;

    &lt;p&gt;在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。&lt;/p&gt;

    &lt;p&gt;而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：&lt;/p&gt;

    &lt;p&gt;Connection:keep-alive&lt;/p&gt;

    &lt;p&gt;在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。&lt;/p&gt;

    &lt;p&gt;HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP 1.0和HTTP 1.1的主要区别是什么?&lt;/p&gt;

    &lt;p&gt;HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：&lt;/p&gt;

    &lt;p&gt;长连接 : 在HTTP/1.0中，默认使用的是短连接，也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。HTTP 1.1起，默认使用长连接 ,默认开启Connection： keep-alive。 HTTP/1.1的持续连接有非流水线方式和流水线方式 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。&lt;/p&gt;

    &lt;p&gt;错误状态响应码 :在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。&lt;/p&gt;

    &lt;p&gt;缓存处理 :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。&lt;/p&gt;

    &lt;p&gt;带宽优化及网络连接的使用 :HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;URI和URL的区别是什么?&lt;/p&gt;

    &lt;p&gt;URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。&lt;/p&gt;

    &lt;p&gt;URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。&lt;/p&gt;

    &lt;p&gt;URI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP 和 HTTPS 的区别？&lt;/p&gt;

    &lt;p&gt;端口 ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。&lt;/p&gt;

    &lt;p&gt;安全性和资源消耗： HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。&lt;strong&gt;所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。&lt;/strong&gt;所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTTPS原理和流程&lt;/p&gt;

    &lt;p&gt;HTTPS通信过程&lt;/p&gt;

    &lt;p&gt;HTTPS协议 = HTTP协议 + SSL/TLS协议，在HTTPS数据传输的过程中，需要用SSL/TLS对数据进行加密和解密，需要用HTTP对加密后的数据进行传输，由此可以看出HTTPS是由HTTP和SSL/TLS一起合作完成的。&lt;/p&gt;

    &lt;p&gt;SSL的全称是Secure Sockets Layer，即安全套接层协议，是为网络通信提供安全及数据完整性的一种安全协议。SSL协议在1994年被Netscape发明，后来各个浏览器均支持SSL，其最新的版本是3.0&lt;/p&gt;

    &lt;p&gt;TLS的全称是Transport Layer Security，即安全传输层协议，最新版本的TLS（Transport Layer Security，传输层安全协议）是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本。在TLS与SSL3.0之间存在着显著的差别，主要是它们所支持的加密算法不同，所以TLS与SSL3.0不能互操作。虽然TLS与SSL3.0在加密算法上不同，但是在我们理解HTTPS的过程中，我们可以把SSL和TLS看做是同一个协议。&lt;/p&gt;

    &lt;p&gt;HTTPS为了兼顾安全与效率，同时使用了对称加密和非对称加密。数据是被对称加密传输的，对称加密过程需要客户端的一个密钥，为了确保能把该密钥安全传输到服务器端，采用非对称加密对该密钥进行加密传输，总的来说，对数据进行对称加密，对称加密所要使用的密钥通过非对称加密传输。&lt;/p&gt;

    &lt;p&gt;HTTPS在传输的过程中会涉及到三个密钥：&lt;/p&gt;

    &lt;p&gt;服务器端的公钥和私钥，用来进行非对称加密&lt;/p&gt;

    &lt;p&gt;客户端生成的随机密钥，用来进行对称加密&lt;/p&gt;

    &lt;p&gt;一个HTTPS请求实际上包含了两次HTTP传输，可以细分为8步。&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;客户端向服务器发起HTTPS请求&lt;/strong&gt;，连接到服务器的443端口&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;服务器将自己的公钥发送给客户端。&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;客户端收到服务器端的公钥之后，会对公钥进行检查，验证其合法性，如果发现发现公钥有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性，关于客户端如何验证数字证书的合法性，下文会进行说明。如果公钥合格，那么&lt;strong&gt;客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥&lt;/strong&gt;，这样在概念上和服务器端的密钥容易进行区分。&lt;strong&gt;然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了&lt;/strong&gt;，至此，HTTPS中的第一次HTTP请求结束。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密&lt;/strong&gt;，解密之后的明文就是客户端密钥，&lt;strong&gt;然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;然后&lt;strong&gt;服务器将加密后的密文发送给客户端。&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密&lt;/strong&gt;，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;XML和JSON优缺点&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;https://www.cnblogs.com/sanmaospace/p/3139186.html&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;(1).XML的优缺点&lt;/p&gt;

    &lt;p&gt;&amp;lt;1&amp;gt;.XML的优点&lt;/p&gt;

    &lt;p&gt;　　A.格式统一，符合标准；&lt;/p&gt;

    &lt;p&gt;　　B.容易与其他系统进行远程交互，数据共享比较方便。&lt;/p&gt;

    &lt;p&gt;&amp;lt;2&amp;gt;.XML的缺点&lt;/p&gt;

    &lt;p&gt;　　A.XML文件庞大，文件格式复杂，传输占带宽；&lt;/p&gt;

    &lt;p&gt;　　B.服务器端和客户端都需要花费大量代码来解析XML，导致服务器端和客户端代码变得异常复杂且不易维护；&lt;/p&gt;

    &lt;p&gt;　　C.客户端不同浏览器之间解析XML的方式不一致，需要重复编写很多代码；&lt;/p&gt;

    &lt;p&gt;　　D.服务器端和客户端解析XML花费较多的资源和时间。&lt;/p&gt;

    &lt;p&gt;(2).JSON的优缺点&lt;/p&gt;

    &lt;p&gt;&amp;lt;1&amp;gt;.JSON的优点：&lt;/p&gt;

    &lt;p&gt;　　A.数据格式比较简单，易于读写，格式都是压缩的，占用带宽小；&lt;/p&gt;

    &lt;p&gt;　　B.易于解析，客户端JavaScript可以简单的通过eval()进行JSON数据的读取；&lt;/p&gt;

    &lt;p&gt;　　C.支持多种语言，包括ActionScript, C, C#, ColdFusion, Java, JavaScript, Perl, PHP, Python, Ruby等服务器端语言，便于服务器端的解析；&lt;/p&gt;

    &lt;p&gt;　　D.在PHP世界，已经有PHP-JSON和JSON-PHP出现了，偏于PHP序列化后的程序直接调用，PHP服务器端的对象、数组等能直接生成JSON格式，便于客户端的访问提取；&lt;/p&gt;

    &lt;p&gt;　　E.因为JSON格式能直接为服务器端代码使用，大大简化了服务器端和客户端的代码开发量，且完成任务不变，并且易于维护。&lt;/p&gt;

    &lt;p&gt;&amp;lt;2&amp;gt;.JSON的缺点&lt;/p&gt;

    &lt;p&gt;　　A.没有XML格式这么推广的深入人心和喜用广泛，没有XML那么通用性；&lt;/p&gt;

    &lt;p&gt;　　B.JSON格式目前在Web Service中推广还属于初级阶段。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP 2.0&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/heluan/p/8620312.html&quot;&gt;https://www.cnblogs.com/heluan/p/8620312.html&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？&lt;/p&gt;

    &lt;p&gt;HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；&lt;/p&gt;

    &lt;p&gt;HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；&lt;/p&gt;

    &lt;p&gt;HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTTPS和HTTP的区别&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://zhidao.baidu.com/question/2686928.html&quot;&gt;https://zhidao.baidu.com/question/2686928.html&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;http协议和https协议的区别：传输信息安全性不同、连接方式不同、端口不同、证书申请方式不同&lt;/p&gt;

    &lt;p&gt;一、传输信息安全性不同&lt;/p&gt;

    &lt;p&gt;1、http协议：是来超文本传输协议，信息是明文传输。如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息。&lt;/p&gt;

    &lt;p&gt;2、https协议：是自具有安全性的ssl加密传输协议，为浏览器和服务器之间的通信加密，确保数据传输的安全。&lt;/p&gt;

    &lt;p&gt;二、连接方式不同&lt;/p&gt;

    &lt;p&gt;1、http协议：http的连接很简单，是无状态的。&lt;/p&gt;

    &lt;p&gt;2、https协议：是由SSL＋HTTP协议构建的可进行加密传输、身份认证的网络协议。&lt;/p&gt;

    &lt;p&gt;三、端口不同&lt;/p&gt;

    &lt;p&gt;1、http协议：使用的端口是80。&lt;/p&gt;

    &lt;p&gt;2、https协议：使用的端口是443．&lt;/p&gt;

    &lt;p&gt;四、证书申请方式不同&lt;/p&gt;

    &lt;p&gt;1、http协议：免费申请。&lt;/p&gt;

    &lt;p&gt;2、https协议：需要到ca申请证书，一般免费证书很少，需要交费。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP请求/响应报文结构&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/ldq2016/p/9055933.html&quot;&gt;https://www.cnblogs.com/ldq2016/p/9055933.html&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;字符编码集、语言、内容长度、服务器的域名和端口号&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/sdb5858874/article/details/80535348&quot;&gt;https://blog.csdn.net/sdb5858874/article/details/80535348&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;一、请求报文的结构：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;请求行：&lt;strong&gt;请求方法GET/POST&lt;/strong&gt;、&lt;strong&gt;URL&lt;/strong&gt;、&lt;strong&gt;协议版本HTTP1.0/HTTP1.1&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;请求头部&lt;/li&gt;
      &lt;li&gt;请求主体&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;1.请求报文中方法的介绍：
GET  请求获取一个Web页面
POST 主要作用是执行操作，比如向服务器提交一个表单
DELETE  请求删除一个Web界面
MOVE 请求移动某个页面到指定位置
HEAD 与GET方法类似区别在于获取Web页面首部，不获取主体
           也就是说只获得一个页面的Head部分，而不获得BODY主体
PUT 请求向服务器上传指定资源。
TRACE  用于测试，要求服务器返回收到的请求
OPTION请求服务器支持哪些方法&lt;/p&gt;

    &lt;p&gt;2.请求消息头
字段名               说明&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;Host&lt;/strong&gt;         消息头用于指定出现在被访问的完整URL中的主机名称  （被访问的完整URL主机名，也就是目的地址）&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;User-Agent&lt;/strong&gt;   这个消息头用于提供与浏览器或生成请求的客户端软件有关的消息&lt;/p&gt;

    &lt;p&gt;Accept  这个消息头用于告诉服务器客户端接收那些内容，如图片类型，办公文档格式等&lt;/p&gt;

    &lt;p&gt;Accept-Language 用于声明服务器，浏览器支持哪些语言&lt;/p&gt;

    &lt;p&gt;Accept-Encoding 这个消息头用于告诉服务器 客户端接受那些内容编码&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;Referer&lt;/strong&gt;  这个消息头用于指示提出当前请求的原始URL&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;Cookie&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;Connection  通知通信的另一方，是否在完成HTTP传输后关闭TCP连接&lt;/p&gt;

    &lt;p&gt;二、响应报文的结构&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;响应行：&lt;strong&gt;版本&lt;/strong&gt;、&lt;strong&gt;状态码&lt;/strong&gt;、短语&lt;/li&gt;
      &lt;li&gt;响应头部&lt;/li&gt;
      &lt;li&gt;响应主体&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;1.有关状态码的介绍
状态码是响应报文状态行中包含的一个三位数字  指明请求是否被满足，如果没有被满足，原因是什么，状态码可以分为以下五大类&lt;/p&gt;

    &lt;p&gt;状态码         含义                          例子
1XX        表示请求已被接收，继续处理            100：服务器正在处理客户请求
2XX        表示请求已被成功接收，理解，接受          200：请求成功
3XX        客户端被重定向到其他资源                301：表示本网页永久性跳转到另一个地址
                                                                       302：重定向，浏览器自动跳转到新连接
                                                                       304：上次文档已经缓存，还可以继续使用
4XX         请求有语法错误或请求无法实现         400：请求有语法错误
                                                                        403：拒绝提供服务
                                                                        404：请求资源不存在
5XX          服务器执行请求时遇到错误。            500：服务器错误
                                                                        503：服务器不能处理，请稍后再试&lt;/p&gt;

    &lt;p&gt;2.响应头部字段说明
date     响应返回的时间，GMT代表格林威治时间（北京位于东八区，所以北京时间要加8小时）
server   这个消息头提供所使用的Web服务器软件的相关信息
set-Cookie  这个消息头用于向浏览器发布Cookie，浏览器会在随后的请求中将其返回给服务器
Content-type  这个消息头用于规定消息主题的内容类型 例如html文档的类型为：text/html，
Content-Length  这个消息头用于规定消息主体的字节长度
Connection  通知通信的另一方，是否在完成HTTP传输后关闭TCP连接&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;状态码&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;图解HTTP&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/5053660?fr=aladdin&quot;&gt;https://baike.baidu.com/item/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/5053660?fr=aladdin&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;200 OK&lt;/strong&gt;：表示从客户端发来的请求在服务端被正常处理了。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;201 Created&lt;/strong&gt;：请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;202 Accepted&lt;/strong&gt;：服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;204 No Content&lt;/strong&gt;：代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;206 Partial Content&lt;/strong&gt;：表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;301 Moved Permanently：永久性重定向&lt;/strong&gt;。表示请求的资源已被分配了新的URL，以后应使用资源现在所指的URL。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;302 Found：临时性重定向&lt;/strong&gt;。表示请求的资源已被分配了新的URL，希望用户能使用新的URL访问。和301状态码相似，但302状态码代表资源不是被永久移动，只是临时性质的。&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;304 Not Modified：表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;400 Bad Request：表示请求报文中存在语法错误。&lt;/li&gt;
      &lt;li&gt;401 Unauthorized：表示发送的请求需要有通过HTTP认证的认证信息。&lt;/li&gt;
      &lt;li&gt;403 Forbidden：对请求资源的访问被服务器拒绝了。&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;404 Not Found：表明服务器上无法找到请求的资源。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;500 Internal Server Error：表示服务器端在执行请求时发生了错误。&lt;/li&gt;
      &lt;li&gt;503 Service Unavailable：表明服务器暂时处于超负荷或正在进行停机维护，现在无法处理请求。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP/1.1 首部字段一览&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;图解HTTP P80&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;通用首部字段&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Cache-Control：控制缓存的行为&lt;/li&gt;
      &lt;li&gt;Connection：逐跳首部、连接的管理&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;请求首部字段&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Accept：用户代理可处理的媒体类型&lt;/li&gt;
      &lt;li&gt;Accept-Charset：优先的字符集&lt;/li&gt;
      &lt;li&gt;Accept-Encoding：优先的内容编码&lt;/li&gt;
      &lt;li&gt;Accept-Language：优先的语言（自然语言）&lt;/li&gt;
      &lt;li&gt;Host：请求资源所在服务器&lt;/li&gt;
      &lt;li&gt;Range：实体的字节范围请求&lt;/li&gt;
      &lt;li&gt;Referer：对请求中URL的原始获取方&lt;/li&gt;
      &lt;li&gt;User-Agent：HTTP客户端程序的信息&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;响应首部字段&lt;/p&gt;

    &lt;p&gt;实体首部字段&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Content-Encoding：实体主体适用的编码方式&lt;/li&gt;
      &lt;li&gt;Content-Language：实体主体的自然语言&lt;/li&gt;
      &lt;li&gt;Content-Length：实体主体的大小&lt;/li&gt;
      &lt;li&gt;Content-Type：实体主体的媒体类型&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;非HTTP/1.1首部字段&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Cookie&lt;/li&gt;
      &lt;li&gt;Set-Cookie&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为什么tcp三次握手的时候的seq初始化时随机地，而不是从0开始&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/53658729&quot;&gt;https://www.zhihu.com/question/53658729&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;如果TCP在建立连接时每次都选择相同的、固定的初始序号，那么设想以下的情况：&lt;/p&gt;

    &lt;p&gt;(1)假定主机A和B频繁地建立连接，传送一些TCP报文段后，再释放连接，然后又不断地建立新的连接、传送报文段和释放连接。&lt;/p&gt;

    &lt;p&gt;(2)假定每一次建立连接时，主机A都选择相同的、固定的初始序号，例如，选择1。&lt;/p&gt;

    &lt;p&gt;(3)假定主机A发送出的某些TCP报文段在网络中会滞留较长的时间，以致造成主机A超时重传这些TCP报文段。&lt;/p&gt;

    &lt;p&gt;(4)假定有一些在网络中滞留时间较长的TCP报文段最后终于到达了主机B，但这时传送该报文段的那个连接早已释放了．而在到达主机B时的TCP连接是一条新的TCP连接。&lt;/p&gt;

    &lt;p&gt;这样，工作在新的TCP连接下的主机B就有可能会接受在旧的连接传送的、已经没有意义的、过时的TCP报文段(因为这个TCP报文段的序号有可能正好处在现在新的连接所使用的序号范围之中)。结果产生错误。&lt;/p&gt;

    &lt;p&gt;因此，必须使得迟到的TCP报文段的序号不处在新的连接中所使用的序号范围之中。&lt;/p&gt;

    &lt;p&gt;这样，TCP在建立新的连接时所选择的初始序号一定要和前面的一些连接所使用过的序号不一样。因此，不同的TCP连接不能使用相同的初始序号。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;get请求和post请求的区别&lt;/p&gt;

    &lt;p&gt;GET请求把参数包含在URL中，将请求信息放在URL后面，POST请求通过request body传递参数，将请求信息放置在报文体中。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/28586791&quot;&gt;https://www.zhihu.com/question/28586791&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;&lt;strong&gt;GET&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;“读取“一个资源。比如Get到一个html文件。反复读取不应该对访问的数据有副作用。比如”GET一下，用户就下单了，返回订单已受理“，这是不可接受的。没有副作用被称为“幂等“（Idempotent)。&lt;/p&gt;

    &lt;p&gt;因为GET因为是读取，就可以对GET请求的数据做缓存。这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），或者做到server端（用Etag，至少可以减少带宽消耗）&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;POST&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;在页面里&amp;lt;form&amp;gt; 标签会定义一个表单。点击其中的submit元素会发出一个POST请求让服务器做一件事。这件事往往是有副作用的，不幂等的。&lt;/p&gt;

    &lt;p&gt;不幂等也就意味着不能随意多次执行。因此也就不能缓存。比如通过POST下一个单，服务器创建了新的订单，然后返回订单成功的界面。这个页面不能被缓存。试想一下，如果POST请求被浏览器缓存了，那么下单请求就可以不向服务器发请求，而直接返回本地缓存的“下单成功界面”，却又没有真的在服务器下单。那是一件多么滑稽的事情。&lt;/p&gt;

    &lt;p&gt;GET和POST携带数据的格式也有区别。当浏览器发出一个GET请求时，就意味着要么是用户自己在浏览器的地址栏输入，要不就是点击了html里a标签的href中的url。所以其实并不是GET只能用url，而是浏览器直接发出的GET只能由一个url触发。所以没办法，GET上要在url之外带一些参数就只能依靠url上附带querystring。但是HTTP协议本身并没有这个限制。&lt;/p&gt;

    &lt;p&gt;浏览器的POST请求都来自表单提交。每次提交，表单的数据被浏览器用编码到HTTP请求的body里。浏览器发出的POST请求的body主要有有两种格式，一种是application/x-www-form-urlencoded用来传输简单的数据，大概就是”key1=value1&amp;amp;key2=value2”这样的格式。另外一种是传文件，会采用multipart/form-data格式。采用后者是因为application/x-www-form-urlencoded的编码方式对于文件这种二进制的数据非常低效。&lt;/p&gt;

    &lt;p&gt;浏览器在POST一个表单时，url上也可以带参数，只要&amp;lt;form action=&quot;url&quot; &amp;gt;里的url带querystring就行。只不过表单里面的那些用&lt;input /&gt; 等标签经过用户操作产生的数据都在会在body里。&lt;/p&gt;

    &lt;p&gt;因此我们一般会泛泛的说“GET请求没有body，只有url，请求数据放在url的querystring中；POST请求的数据在body中“。但这种情况仅限于浏览器发请求的场景。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP GET、DELETE、PUT、POST四种主要方法的幂等性的理解&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;GET:GET请求是幂等的，多次的GET请求，不应该修改数据状态，只是查询。&lt;/li&gt;
      &lt;li&gt;DELETE：Delete请求也具有幂等性，执行一次请求，删除id=1的记录，多次请求与一次请求的结果应该是一样的，最终的结果都是把id=1的记录删除。&lt;/li&gt;
      &lt;li&gt;PUT：Put意为修改记录，也具有幂等性，执行一次请求，将记录修改为特定状态，多次请求结果也应该是一样的。&lt;/li&gt;
      &lt;li&gt;POST：Post请求不具有幂等性，通常为增加记录。没执行一次请求，都会增加一条记录。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;幂等&lt;/p&gt;

    &lt;p&gt;在一个典型的订单交易系统中，防重和幂等设计是重要而又非常基本的概念。防重是指重复多次提交同样的交易指令或者订单请求到后台，系统必须能够去重，防止重复执行；而幂等，则是在多个同样的交易指令或请求同时或者先后到达后台，即使重复执行，系统也必须始终提供与一致的状态，而不能有其他的副作用。看起来，防重与幂等似乎在说同一件事情，但其实又有不同的概念区分。例如幂等其实可以通过防重设计来达到提供一致的系统状态，而防重却不如幂等那样开放承诺，允许被执行多次而达到一致状态，这其实要求在防重的基础上做出更多的设计工作，特别是在分布式环境中。&lt;/p&gt;

    &lt;p&gt;为了更深入地理解幂等，我们先来看看HTTP/1.1协议中对幂等性的定义：&lt;/p&gt;

    &lt;p&gt;Methods can also have the property of “idempotence” in that (aside from error or expiration issues) the side-effects of N &amp;gt; 0 identical requests is the same as for a single request.&lt;/p&gt;

    &lt;p&gt;这里不讨论学术上如何定义幂等性，而是重点在于如何在分布式环境中提供对外幂等性的接口。对外提供的接口承诺幂等性，其要表达的含义是：只要调用接口成功，外部对接口的多次调用得到的结果是相同的。即执行多次和一次的效果是一样的。&lt;/p&gt;

    &lt;p&gt;方法还具有“幂等性”的特性(除了错误或过期问题)，即N &amp;gt; 0相同请求的副作用与单个请求相同。&lt;/p&gt;

    &lt;p&gt;其实我们也可以从服务端架构分层上来理解，如果幂等设计放在越前端，那么提供的其实是一种防重方案；越往后端，随着业务逻辑的深入，幂等的设计方案也就更加复杂。这其实取决于相关交易系统的业务场景以及部署架构的特点。&lt;/p&gt;

    &lt;p&gt;在实际的生产环境中，我们不时还是会遇到防重或者幂等问题。例如有些老的订单系统，可能因为某个中间节点阻塞超时，触发了重发机制，最终导致多个相同ID的交易请求同时到达系统后台。由于老订单系统只提供了简单的串行防重，并没有充分考虑高并发幂等，结果将同一个用户的交易请求执行了多次，导致该用户的前后端的资产份额不一致，最终不得不人工介入解决。&lt;/p&gt;

    &lt;p&gt;常见的幂等实现方案，有这么几种:&lt;/p&gt;

    &lt;p&gt;1.最简单的，需要通过唯一的业务单号来保证幂等。也就是说相同的业务单号，认为是同一笔业务。使用这个唯一的业务单号来确保，后面多次的相同的业务单号的处理逻辑和执行效果是一致的。以支付为例，在不考虑并发的情况下，实现幂等很简单：①先查询一下订单是否已经支付过，②如果已经支付过，则返回支付成功；如果没有支付，进行支付流程，修改订单状态为‘已支付’。&lt;/p&gt;

    &lt;p&gt;2、上述的保证幂等方案是分成两步的，第②步依赖第①步的查询结果，无法保证原子性的。在高并发下就会出现下面的情况：第二次请求在第一次请求第②步订单状态还没有修改为‘已支付状态’的情况下到来。既然得出了这个结论，余下的问题也就变得简单：把查询和变更状态操作加锁，将并行操作改为串行操作。&lt;/p&gt;

    &lt;p&gt;3、但是，在某些场景，你可能又想提供无锁的高并发幂等，那么你可以选择为业务单号加上唯一的索引或者组合索引，在并发的场景中，只有第一笔插入的交易请求能够成功，后续的请求哪怕是慢1ms或者更短时间，都会触发数据库的唯一索引异常而失败，那么你可以捕获这个异常。&lt;/p&gt;

    &lt;p&gt;4、又或者你想把幂等放在服务的最前端，减少实际服务处理的资源浪费，在请求一到达时就提前去重，不让他有执行的机会，那么你可以考虑引入一个redis或类似的组件，将业务请求单号缓存在这个分布式锁的组件内。那么，每当订单发起交易请求，交易系统会去Redis缓存中查询是否存在该订单号的Key，如果不存在，则向Redis增加Key为订单号。查询订单是否已经执行，如果没有则转发到交易系统，执行完成后删除该订单号的Key。当然，Redis是提供分布式节点下的原子事务操作的。&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/weidagang2046/archive/2011/06/04/idempotence.html&quot;&gt;幂等&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DNS的寻址过程&lt;/p&gt;

    &lt;p&gt;1、在浏览器中输入www.qq.com域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。&lt;/p&gt;

    &lt;p&gt;2、如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。&lt;/p&gt;

    &lt;p&gt;3、如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/ip参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。&lt;/p&gt;

    &lt;p&gt;4、如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。&lt;/p&gt;

    &lt;p&gt;5、如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找qq.com域服务器，重复上面的动作，进行查询，直至找到www.qq.com主机。&lt;/p&gt;

    &lt;p&gt;6、如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。&lt;/p&gt;

    &lt;p&gt;从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/WindSun/p/11489356.html&quot;&gt;https://www.cnblogs.com/WindSun/p/11489356.html&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;DNS解析（域名解析服务器）
a）首先会搜索浏览器自身的DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存）&lt;/p&gt;

    &lt;p&gt;b）如果浏览器自身的缓存里面没有找到，那么浏览器会搜索系统自身的DNS缓存&lt;/p&gt;

    &lt;p&gt;c）如果还没有找到，那么尝试从 hosts文件里面去找&lt;/p&gt;

    &lt;p&gt;d）在前面三个过程都没获取到的情况下，就递归地去域名服务器去查找，具体过程如下&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/6064128/5rxqugj8dh.png&quot; alt=&quot;https://ask.qcloudimg.com/draft/6064128/5rxqugj8dh.png&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;DNS优化两个方面：DNS缓存、DNS负载均衡&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;请你简单讲解一下，负载均衡 反向代理模式的优点、缺点&lt;/p&gt;

    &lt;p&gt;（1）反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。&lt;/p&gt;

    &lt;p&gt;（2）反向代理负载均衡技术是把将来自internet上的连接请求以反向代理的方式动态地转发给内部网络上的多台服务器进行处理，从而达到负载均衡的目的。&lt;/p&gt;

    &lt;p&gt;（3）反向代理负载均衡能以软件方式来实现，如apache mod_proxy、netscape proxy等，也可以在高速缓存器、负载均衡器等硬件设备上实现。反向代理负载均衡可以将优化的负载均衡策略和代理服务器的高速缓存技术结合在一起，提升静态网页的访问速度，提供有益的性能；由于网络外部用户不能直接访问真实的服务器，具备额外的安全性（同理，NAT负载均衡技术也有此优点）。&lt;/p&gt;

    &lt;p&gt;（4）其缺点主要表现在以下两个方面&lt;/p&gt;

    &lt;p&gt;反向代理是处于OSI参考模型第七层应用的，所以就必须为每一种应用服务专门开发一个反向代理服务器，这样就限制了反向代理负载均衡技术的应用范围，现在一般都用于对web服务器的负载均衡。&lt;/p&gt;

    &lt;p&gt;针对每一次代理，代理服务器就必须打开两个连接，一个对外，一个对内，因此在并发连接请求数量非常大的时候，代理服务器的负载也就非常大了，在最后代理服务器本身会成为服务的瓶颈。&lt;/p&gt;

    &lt;p&gt;一般来讲，可以用它来对连接数量不是特别大，但每次连接都需要消耗大量处理资源的站点进行负载均衡，如search等。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;爬虫&quot;&gt;爬虫&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;防爬&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000005840672&quot;&gt;https://segmentfault.com/a/1190000005840672&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;后台对访问进行统计，如果单个IP访问超过阈值，予以封锁。&lt;/li&gt;
      &lt;li&gt;后台对访问进行统计，如果单个session访问超过阈值，予以封锁。&lt;/li&gt;
      &lt;li&gt;后台对访问进行统计，如果单个userAgent访问超过阈值，予以封锁。&lt;/li&gt;
      &lt;li&gt;用JavaScript混淆&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/26221432&quot;&gt;https://www.zhihu.com/question/26221432&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;模拟浏览器提交。&lt;/p&gt;

        &lt;p&gt;简单的，使用 webkit 来提交数据，这个基本可以过大多数浏览源检测的反爬系统了。&lt;/p&gt;

        &lt;p&gt;但是有的反爬系统检测浏览源的时候，会根据大众浏览器的一些特性，比如 IE，Firefox，Chrome 等的私有 js 函数来判定浏览器，这样 webkit ，以及一些封装好的 无界面浏览器 也被当成爬虫了。当然，你也可以利用调用 chromuim 来爬取数据，但是这个资源开销就更大了。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;控制单 ip/账号 频率。&lt;/p&gt;

        &lt;p&gt;挂私有代理来爬的就不说了，大家都会用，但是对于一般人来说，几万 ip 差不多是极限了，所以一个 ip 还是得多次请求，账号同理。而控制了爬取速度，则意味着爬完一圈需要更多时间。时间都是成本。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;控制爬取策略。&lt;/p&gt;

        &lt;p&gt;如果简单的只对目标数据进行爬取，那么如果反爬系统对访问概况和用户行为进行分析，其实很简单就能判定爬虫的那堆 ip : 你除了这堆数据什么都没访问，一看就不是正常用户。&lt;/p&gt;

        &lt;p&gt;当然策略这个东西，就需要更多的博弈了。爬虫要增加迷惑度，需要去访问一些无关的东西，最后是研究正常用户的访问流程，然后模拟一遍。再者，控制速度。毕竟反爬系统的统计区间是肯定有限制的，不可能拿一个月的数据都分析一遍找出爬虫。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 05 Mar 2020 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/03/05/network/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/03/05/network/</guid>
        
        <category>学习</category>
        
        
      </item>
    
      <item>
        <title>JVM</title>
        <description>&lt;h2 id=&quot;jvm&quot;&gt;JVM&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;JVM加载class文件的原理&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/Qian123/p/5707562.html&quot;&gt;https://www.cnblogs.com/Qian123/p/5707562.html&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;Java中的所有类，都需要由类加载器装载到JVM中才能运行。类加载器本身也是一个类，而它的工作就是把class文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。&lt;/p&gt;

    &lt;p&gt;类装载方式，有两种&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中，&lt;/li&gt;
      &lt;li&gt;显式装载， 通过class.forname()等方法，显式加载需要的类&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;隐式加载与显式加载的区别：两者本质是一样?&lt;/p&gt;

    &lt;p&gt;Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到jvm中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。&lt;/p&gt;

    &lt;p&gt;Java的类加载器有三个，对应Java的三种类:（java中的类大致分为三种：   1.系统类   2.扩展类 3.由程序员自定义的类 ）&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-​&quot;&gt;     Bootstrap Loader  // 负责加载**系统类** (指的是内置类，像是String，对应于C#中的System类和C/C++标准库中的类)
​            | 
​          \- - ExtClassLoader   // 负责加载**扩展类**(就是继承类和实现类)
​                          | 
​                      \- - AppClassLoader   // 负责加载**应用类**(程序员自定义的类)
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;三个加载器各自完成自己的工作，但它们是如何协调工作呢？哪一个类该由哪个类加载器完成呢？为了解决这个问题，Java采用了&lt;strong&gt;委托模型机制&lt;/strong&gt;。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;委托模型机制的工作原理很简单：当类加载器需要加载类的时候，先请示其Parent(即上一层加载器)在其搜索路径载入，如果找不到，才在自己的搜索路径搜索该类。这样的顺序其实就是加载器层次上自顶而下的搜索，因为加载器必须保证基础类的加载。&lt;/strong&gt; 之所以是这种机制，还有一个安全上的考虑：如果某人将一个恶意的基础类加载到jvm，委托模型机制会搜索其父类加载器，显然是不可能找到的，自然就不会将该类加载进来。&lt;/p&gt;

    &lt;p&gt;我们可以通过这样的代码来获取类加载器:&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nc&quot;&gt;ClassLoader&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loader&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ClassName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getClassLoader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;ClassLoader&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ParentLoader&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getParent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;注意一个很重要的问题，就是Java在逻辑上并不存在BootstrapLoader的实体！因为它是用C++编写的，所以打印其内容将会得到null。&lt;/p&gt;

    &lt;p&gt;前面是对类加载器的简单介绍，它的原理机制非常简单，就是下面几个步骤:&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;加载&lt;/strong&gt;:查找和导入&lt;strong&gt;class文件&lt;/strong&gt;;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;连接&lt;/strong&gt;:&lt;/p&gt;

        &lt;p&gt;(1)&lt;strong&gt;验证&lt;/strong&gt;:检查&lt;strong&gt;载入的class文件数据的正确性&lt;/strong&gt;;&lt;/p&gt;

        &lt;p&gt;(2)&lt;strong&gt;准备&lt;/strong&gt;:&lt;strong&gt;为类的静态变量分配存储空间&lt;/strong&gt;;&lt;/p&gt;

        &lt;p&gt;(3)&lt;strong&gt;解析&lt;/strong&gt;:&lt;strong&gt;将符号引用转换成直接引用&lt;/strong&gt;(这一步是可选的)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;初始化&lt;/strong&gt;:&lt;strong&gt;初始化静态变量&lt;/strong&gt;，静态代码块。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;这样的过程在程序调用类的静态成员的时候开始执行，所以静态方法main()才会成为一般程序的入口方法。类的构造器也会引发该动作。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://uploadfiles.nowcoder.com/images/20180926/308572_1537962641528_95106A90F455887E4A4B298735A4641B&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;《深入理解JVM》P191 双亲委派模型&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;绝大部分Java程序都会使用到以下三种系统提供的类加载器：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;启动类加载器(Bootstrap ClassLoader): 这个类加载器负责将存放在&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;JAVA_HOME&amp;gt;\lib&lt;/code&gt;目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接使用。&lt;/li&gt;
      &lt;li&gt;扩展类加载器(Extension ClassLoader)：这个加载器由&lt;code class=&quot;highlighter-rouge&quot;&gt;sun.misc.Launcher$ExtClassLoader&lt;/code&gt;实现，它负责加载&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;Java_HOME&amp;gt;\lib\ext&lt;/code&gt;目录中的，或者被&lt;code class=&quot;highlighter-rouge&quot;&gt;java.ext.dirs&lt;/code&gt;系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。&lt;/li&gt;
      &lt;li&gt;应用程序类加载器(Application ClassLoader)：这个类加载器由&lt;code class=&quot;highlighter-rouge&quot;&gt;sun.misc.Launcher$AppClassLoader&lt;/code&gt;来实现。由于这个类加载器是ClassLoader中的&lt;code class=&quot;highlighter-rouge&quot;&gt;getSystemClassLoader()&lt;/code&gt;方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径(ClassPath)上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有定义过自己的类加载器，一般情况下这个就是程序中的默认的类加载器。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;我们的应用程序都是由者三种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;双亲委派模型&lt;/strong&gt;的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委托给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载器请求最终都应该传送到顶层的启动类加载器中，只有当父加载器自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;《深入理解JVM》P194 破坏双亲委派模型&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;双亲委派模型主要出现过三次较大规模的“被破坏”情况。&lt;/p&gt;

    &lt;p&gt;第一次出现在双亲委派模型出现之前————即JDK1.2发布之前。由于双亲委派模型在JDK1.0时代就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java设计者引入双亲委派模型时不得不做出一些妥协。为了向前兼容，JDK1.2之后的java.lang.ClassLoader添加了一个新的protected方法findClass()，在次之前，用户继承&lt;strong&gt;java.lang.ClassLoader的唯一目的就是重写loadClass()方法&lt;/strong&gt;。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;JDK1.2之后已不提倡用户再去覆盖loadClass()方法，而应该把自己的类加载逻辑写到findClass()方法中，在loadClass()方法的逻辑里如果父类加载失败，则会调用自己的findClass()方法来完成加载&lt;/strong&gt;，这样就可以保证新写出来的类加载器时符合双亲委派规则的。&lt;/p&gt;

    &lt;p&gt;第二次是&lt;strong&gt;由这个模型的自身的缺陷所导致&lt;/strong&gt;的，基础类之所以被称为“基础”，是因为它们总是作为被用户代码调用的API，但如果&lt;strong&gt;基础类又要调用回用户的代码&lt;/strong&gt;，那该怎么办？&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;JNDI服务由启动类加载器去加载&lt;/strong&gt;，但启动类加载器不可能“认识”这些代码啊！为了解决这个困境，Java设计团队只好引入了一个不太优雅的设计：&lt;strong&gt;线程上下文类加载器&lt;/strong&gt;。JNDI服务使用这个线程上下文类加载器去加载所需要的SPI代码，也就是&lt;strong&gt;父类加载器请求子类加载器去完成类加载器&lt;/strong&gt;的动作，这种行为实际上就是打通了双亲委派模型的层次结构来你想使用类加载器。&lt;/p&gt;

    &lt;p&gt;第三次是由于&lt;strong&gt;用户对程序动态性的追求&lt;/strong&gt;而导致的，这里所说的“动态性”指的是当前一些非常“热”门的名词：代码热替换、模块热部署等，说白了就是希望应用程序能像我们的电脑外设那样，插上鼠标或U盘，不用重启机器就能立即使用，鼠标有问题或要升级就换个鼠标，不用停机也不用重启。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8&quot;&gt;https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;双亲委派模型的好处&lt;/p&gt;

    &lt;p&gt;双亲委派模型保证了Java程序的稳定运行，&lt;strong&gt;可以避免类的重复加载&lt;/strong&gt;（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），&lt;strong&gt;也保证了 Java 的核心 API 不被篡改&lt;/strong&gt;。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 java.lang.Object 类的话，那么程序运行的时候，系统就会出现多个不同的 Object 类。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;OOM、CPU占用过高排查&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;jps列出正在运行的虚拟机进程&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;jstat统计信息，包括分区占用情况&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;jmap内存映像&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;jstack堆栈跟踪&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;VisualVM：生成浏览堆转储快照、分析CPU、内存性能&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;top ps&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;JVM是如何实现线程的？&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;《深入理解JVM》P333 Java与线程&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_33938256/article/details/52615257&quot;&gt;https://blog.csdn.net/qq_33938256/article/details/52615257&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;并发不一定要依赖多线程（如PHP中很常见的多进程并发），但是在Java里面谈论并发，大多数都与线程脱不开关系。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;线程的实现&lt;/p&gt;

        &lt;p&gt;线程是比进程更轻量级的调度执行单位，线程的引入，可以把一个进程的&lt;strong&gt;资源分配&lt;/strong&gt;和&lt;strong&gt;执行调度&lt;/strong&gt;分开，各个线程既可以共享进程资源（内存地址、文件I/O等），又可以独立调度（线程是CPU调度的最基本单位）。&lt;/p&gt;

        &lt;p&gt;主流的操作系统都提供了线程实现，Java语言则提供了在不同硬件和操作系统平台下对线程操作的同一处理，每个java.lang.Thread类的实例就代表了一个线程。&lt;strong&gt;Thread类的关键方法，都声明为Native&lt;/strong&gt;。这意味着这个方法无法或没有使用平台无关的手段来实现，也可能是为了执行效率。&lt;/p&gt;

        &lt;p&gt;实现线程主要有三种方式：使用内核线程实现，使用用户线程实现，使用用户线程加轻量级进程混合实现。&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;使用内核线程实现&lt;/strong&gt;&lt;/p&gt;

            &lt;p&gt;内核线程就是直接由操作系统内核支持的线程。&lt;/p&gt;

            &lt;ul&gt;
              &lt;li&gt;&lt;strong&gt;由内核来完成线程切换&lt;/strong&gt;&lt;/li&gt;
              &lt;li&gt;内核通过调度器Scheduler调度线程，并将线程的任务映射到各个CPU上&lt;/li&gt;
              &lt;li&gt;程序使用&lt;strong&gt;内核线程的高级接口&lt;/strong&gt;，&lt;strong&gt;轻量级进程&lt;/strong&gt;(Light Weight Process,LWP)–&amp;gt;(!!!名字是进程，实际是线程)&lt;/li&gt;
              &lt;li&gt;&lt;strong&gt;用户态和内核态切换消耗内核资源&lt;/strong&gt;&lt;/li&gt;
              &lt;li&gt;轻量级进程与内核线程之间的1:1关系称为&lt;strong&gt;一对一线程模型&lt;/strong&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;使用用户线程实现&lt;/strong&gt;&lt;/p&gt;

            &lt;ul&gt;
              &lt;li&gt;&lt;strong&gt;系统内核不能感知线程存在的实现&lt;/strong&gt;&lt;/li&gt;
              &lt;li&gt;&lt;strong&gt;用户线程的建立、同步、销毁和调度完全在用户态中完成&lt;/strong&gt;&lt;/li&gt;
              &lt;li&gt;所有线程操作需要用户程序自己处理，复杂度高&lt;/li&gt;
              &lt;li&gt;这种进程与线程之间1:N的关系称为&lt;strong&gt;一对多的线程模型&lt;/strong&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;混合实现&lt;/strong&gt;&lt;/p&gt;

            &lt;ul&gt;
              &lt;li&gt;轻量级进程作为用户线程和内核线程之间的桥梁&lt;/li&gt;
              &lt;li&gt;混合模式中，用户线程与轻量级进程的数量比是不定的，是M:N的关系，称为&lt;strong&gt;多对多关系&lt;/strong&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;Java线程的实现&lt;/p&gt;

            &lt;p&gt;对于Sun JDK来说，它的Windows版与Linux版都是使用一对一的线程模型来实现的，一条Java线程就映射到一条轻量级进程之中，因为Windows和Linux系统系统提供的线程模型就是一对一的。&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Java线程调度&lt;/p&gt;

        &lt;p&gt;线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是协同式线程调度和抢占式线程调度。&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;协同式调度：线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上去。&lt;/p&gt;

            &lt;p&gt;优点：实现简单，而且由于线程要把自己的事情干完后才会进行线程切换，切换操作对线程自己是可知的，所以没有什么线程同步的问题。&lt;/p&gt;

            &lt;p&gt;缺点：线程执行时间不可控制，甚至如果一个线程编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞在那里。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;抢占式调度：每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定。&lt;/p&gt;

            &lt;p&gt;在这种实现线程调度的方式下，线程的执行时间是系统可控的，也不会有一个线程导致整个进程阻塞的问题，Java使用的线程调度方式就是抢占式调度。&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;

        &lt;p&gt;虽然说Java线程调度是系统自动完成的，但是我们还是可以“建议”系统给某些线程多分配一点执行时间，另外的一些线程则可以少分配一点——这项操作可以通过设置线程优先级来完成。Java语言一共设置了10个级别的线程优先级。&lt;/p&gt;

        &lt;p&gt;不过，线程优先级并不是太靠谱，原因是Java的线程是被映射到系统原生线程上来实现的，所以线程调度最终还是有操作系统说了算，虽然现在很多操作系统都提供线程优先级的概念，但是并不见得能与Java线程的优先级一一对应。Windows只有7中优先级，比Java线程优先级少，不得不出现几个优先级相同的情况。还有其他情况让我们不能太依赖优先级：优先级可能会被系统自行改变。例如在Windows系统中存在一个名为“优先级推进器”的功能，它的大致作用就是当系统发现一个线程被执行得特别“勤奋努力”的话，可能会越过线程优先级去为它分配执行时间。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;王道操作系统 P34&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;线程的实现方式&lt;/p&gt;

        &lt;p&gt;线程的实现可以分为两类，&lt;strong&gt;用户级线程&lt;/strong&gt;和&lt;strong&gt;内核级线程&lt;/strong&gt;。&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;在用户级线程中，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。应用程序可以通过使用线程库设计成多线程程序。&lt;/strong&gt;通常，应用程序从单线程起始，在该线程中开始运行，在其运行的任何时刻，可以通过调用线程库中的派生例程创建一个在相同进程中运行的新线程。&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;在内核级线程中，线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只有一个到内核级线程的编程接口。&lt;/strong&gt;内核为进程及其内部的每个线程维护上下文信息，调度也是在内核基于线程架构的基础上完成。&lt;/p&gt;

        &lt;p&gt;在一些系统中，使用&lt;strong&gt;组合方式&lt;/strong&gt;的多线程实现。线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行，一个应用程序中的多个用户级线程被映射到一些内核级线程上。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;多线程模型&lt;/p&gt;

        &lt;p&gt;有的系统同时支持用户线程和内核线程，由此产生了不同的多线程模型。&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;多对一模型&lt;/strong&gt;。&lt;strong&gt;将多个用户级线程映射到一个内核级线程&lt;/strong&gt;，线程管理在用户空间完成。&lt;/p&gt;

            &lt;p&gt;优点：线程管理是在用户空间进行的，因此效率比较高。&lt;/p&gt;

            &lt;p&gt;缺点：当一个线程在使用内核服务被阻塞，那么整个进程都会被阻塞；多个线程不能并行地运行在多处理器上。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;一对一模型&lt;/strong&gt;。将每个用户及线程映射到一个内核级线程。&lt;/p&gt;

            &lt;p&gt;优点：当一个线程被阻塞后允许另一个线程继续执行，所以并发能力较强。&lt;/p&gt;

            &lt;p&gt;缺点：每创建一个用户及线程都需要创建一个内核级线程与其对应，这样创建线程的开销比较大，会影响到应用程序的性能。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;多对多模型&lt;/strong&gt;。将$n$个用户及线程映射到$m$个内核级线程上，要求$m\le n$。&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;什么是Java内存模型？&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;《深入理解JVM》P318&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;&lt;strong&gt;Amdahl定律&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;并发处理的广泛应用是使得Amdahl定律代替摩尔定律称为计算机性能发展源动力的根本原因，也是人类压榨计算机运算能力最有力的武器。（Amdahl定律通过系统中的并行化和串行化的比重来描述多处理器系统能获得的运算加速能力，摩尔定律则用于描述处理器晶体管数量与运算效率之间的发展关系。这两个定律的更替代表了近年来硬件发展从追求处理器频率到追求多核化并行处理的发展过程。）&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;Java内存模型&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;Java虚拟机规范中试图定义一种Java内存模型(JMM)来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果。&lt;/p&gt;

    &lt;p&gt;Java内存模型规定了所有的变量都存储在主内存中。每个线程还有自己的工作内存，线程的工作内存中给保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读取主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;volatile&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;当一个变量被定义成volatile之后，它将具备两种特性，&lt;strong&gt;第一是保证此变量对所有线程的可见性&lt;/strong&gt;，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。&lt;/p&gt;

    &lt;p&gt;volatile变量在各个线程的工作内存中不存在一致性问题，&lt;strong&gt;但是Java里面的运算并非原子操作，导致volatile变量的运算在并发下一样是不安全的&lt;/strong&gt;。（i++的例子）&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;使用volatile变量的第二个语义是禁止指令重排序优化&lt;/strong&gt;，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。（例子：如果定义initialized变量时没有使用volatile修饰，就可能会由于指令重排序的优化，导致位于线程A中最后语句的代码initialized=true被提前执行，这样在线程B中使用配置信息的代码就可能出现错误，而volatile关键字则可以避免此类情况的发生）&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;happens-before&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;先行发生(happens-before)是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。&lt;/p&gt;

    &lt;p&gt;下面是Java内存模型下一些“天然的”先行发生关系，这些先行发生关系无需任何同步器协助就已经存在，可以在编码中直接使用。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。&lt;/li&gt;
      &lt;li&gt;管程锁定规则&lt;/li&gt;
      &lt;li&gt;volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序。&lt;/li&gt;
      &lt;li&gt;线程启动规则&lt;/li&gt;
      &lt;li&gt;线程终止规则&lt;/li&gt;
      &lt;li&gt;线程中断规则&lt;/li&gt;
      &lt;li&gt;对象终结规则&lt;/li&gt;
      &lt;li&gt;传递性&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/suifeng3051/article/details/52611310&quot;&gt;https://blog.csdn.net/suifeng3051/article/details/52611310&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;Java内存模型(简称JMM)。&lt;strong&gt;JMM决定一个线程对共享变量的写入何时对另一个线程可见&lt;/strong&gt;。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：&lt;strong&gt;线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本&lt;/strong&gt;。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20160921182337904&quot; alt=&quot;这里写图片描述&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。&lt;/li&gt;
      &lt;li&gt;然后，线程B到主内存中去读取线程A之前已更新过的共享变量。&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;下面通过示意图来说明这两个步骤：&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20160921182748551&quot; alt=&quot;这里写图片描述&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;如上图所示，本地内存A和B有主内存中共享变量x的副本。假设初始时，这三个内存中的x值都为0。线程A在执行时，把更新后的x值（假设值为1）临时存放在自己的本地内存A中。当线程A和线程B需要通信时，线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变为了1。随后，线程B到主内存中去读取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。&lt;/p&gt;

    &lt;p&gt;从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;JVM运行时数据区域&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F?id=%e5%86%99%e5%9c%a8%e5%89%8d%e9%9d%a2-%e5%b8%b8%e8%a7%81%e9%9d%a2%e8%af%95%e9%a2%98&quot;&gt;https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F?id=%e5%86%99%e5%9c%a8%e5%89%8d%e9%9d%a2-%e5%b8%b8%e8%a7%81%e9%9d%a2%e8%af%95%e9%a2%98&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;&lt;strong&gt;线程私有的：&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;程序计数器&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;虚拟机栈&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;本地方法栈&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;strong&gt;线程共享的：&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;堆&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;方法区&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;直接内存 (非运行时数据区的一部分)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;img src=&quot;https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;《深入理解JVM》P25 运行时数据区域&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;程序计数器&lt;/p&gt;

        &lt;p&gt;程序计数器是一块较小的内存空间，它的作用可以看作是当前线程所执行的字节码的行号指示器。&lt;strong&gt;字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;另外，&lt;strong&gt;为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Java虚拟机栈&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。&lt;/strong&gt; （实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;局部变量表主要存放了编译器可知的各种数据类型&lt;/strong&gt;（boolean、byte、char、short、int、float、long、double）、&lt;strong&gt;对象引用&lt;/strong&gt;（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;Java 虚拟机栈会出现两种错误：StackOverFlowError 和 OutOfMemoryError。&lt;/strong&gt;&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;StackOverFlowError：&lt;/strong&gt; 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;OutOfMemoryError：&lt;/strong&gt; 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError 错误。&lt;/li&gt;
        &lt;/ul&gt;

        &lt;p&gt;Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;本地方法栈&lt;/p&gt;

        &lt;p&gt;和虚拟机栈所发挥的作用非常相似，区别是： &lt;strong&gt;虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。&lt;/strong&gt; 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。&lt;/p&gt;

        &lt;p&gt;本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。&lt;/p&gt;

        &lt;p&gt;方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/wike163/article/details/6635321&quot;&gt;https://blog.csdn.net/wike163/article/details/6635321&lt;/a&gt;&lt;/p&gt;
        &lt;/blockquote&gt;

        &lt;blockquote&gt;
          &lt;p&gt;一个Native Method是这样一个java的方法：该方法的实现由非java语言实现，比如C。&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Java堆&lt;/p&gt;

        &lt;p&gt;Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都是在这里分配内存。&lt;/p&gt;

        &lt;p&gt;Java堆是垃圾收集器管理的主要区域，因此很多时候也被称作“GC堆”。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老生代，再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。&lt;/p&gt;

        &lt;p&gt;根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;方法区&lt;/p&gt;

        &lt;p&gt;方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的&lt;strong&gt;类信息、常量、静态变量&lt;/strong&gt;、即时编译器编译后的代码等数据。虽然 &lt;strong&gt;Java 虚拟机规范把方法区描述为堆的一个逻辑部分&lt;/strong&gt;，但是它却有一个别名叫做 &lt;strong&gt;Non-Heap（非堆）&lt;/strong&gt;，目的应该是与 Java 堆区分开来。&lt;/p&gt;

        &lt;p&gt;《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 &lt;strong&gt;方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。&lt;/strong&gt; 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。&lt;/p&gt;

        &lt;p&gt;根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;运行时常量池&lt;/p&gt;

        &lt;p&gt;运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项时常量池信息，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。&lt;/p&gt;

        &lt;p&gt;既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;直接内存&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;JDK1.4 中新加入的 &lt;strong&gt;NIO(New Input/Output) 类&lt;/strong&gt;，引入了一种基于&lt;strong&gt;通道（Channel）&lt;/strong&gt; 与&lt;strong&gt;缓存区（Buffer）&lt;/strong&gt; 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为&lt;strong&gt;避免了在 Java 堆和 Native 堆之间来回复制数据&lt;/strong&gt;。&lt;/p&gt;

        &lt;p&gt;本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;jdk1.8：&lt;strong&gt;用元数据区替代永久代，实现方法区，并把字符串常量池和类静态变量迁移到堆中存放。&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9FJDK1.8.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

        &lt;p&gt;元数据区直接存放在本地内存中，不在java虚拟机中，因此加载多少类的内存限制由系统实际的可用空间控制。&lt;/p&gt;

        &lt;p&gt;为什么要用元数据区（metadata）代替永久代&lt;/p&gt;

        &lt;p&gt;1、字符串存放在永久代，容易出现性能和内存溢出的问题&lt;/p&gt;

        &lt;p&gt;2、类信息比较难确定其大小，永久代空间分配困难&lt;/p&gt;

        &lt;p&gt;3、永久代为垃圾回收带来了不必要的复杂度，并且回收效率低&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;&lt;strong&gt;整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。&lt;/strong&gt;&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GC中如何判断对象是否需要被回收？&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;《深入理解JVM》P44 对象已死？&lt;/p&gt;

      &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u010126792/article/details/82855265&quot;&gt;https://blog.csdn.net/u010126792/article/details/82855265&lt;/a&gt; 判断一个对象是否可用（存活，可回收），GC回收对象的过程方式，finilized函数了解吗，调用了finilized函数的对象一定会被回收吗，可以主动调用finilized函数吗？&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;判断对象是否需要被回收&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;引用计数算法&lt;/p&gt;

            &lt;p&gt;给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时候计数器都为0的对象就是不可能再被使用的。&lt;/p&gt;

            &lt;p&gt;Java语言中没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间的相互循环引用的问题。但是它们的引用计数可能都不为0，计数引用算法无法通知GC收集器回收它们。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;根搜索算法&lt;/p&gt;

            &lt;p&gt;在主流的商用程序语言中，都是使用&lt;strong&gt;根搜索算法&lt;/strong&gt;判断对象是否存活。这个算法的基本思路就是通过一系列的名为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连（用图论的话来说就是从GC Roots到这个对象不可达）时，则证明此对象时不可用的。&lt;/p&gt;

            &lt;p&gt;在Java语言中，可作为GC Roots的对象包括下面几种：&lt;/p&gt;

            &lt;ol&gt;
              &lt;li&gt;&lt;strong&gt;虚拟机栈&lt;/strong&gt;（栈帧中的本地变量表）中引用的对象&lt;/li&gt;
              &lt;li&gt;&lt;strong&gt;方法区中的类静态变量&lt;/strong&gt;引用的对象&lt;/li&gt;
              &lt;li&gt;&lt;strong&gt;方法区中的常量&lt;/strong&gt;引用的对象&lt;/li&gt;
              &lt;li&gt;&lt;strong&gt;本地方法栈中JNI&lt;/strong&gt;（即一般说的Native方法）的引用的变量&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;finalize()方法&lt;/p&gt;

        &lt;p&gt;在根搜索算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行根搜索后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。&lt;/p&gt;

        &lt;p&gt;如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程区执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，&lt;strong&gt;如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）复制给某个类变量或对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合&lt;/strong&gt;；如果对象这时候还没有逃脱，那它就真的离死不远了。&lt;/p&gt;

        &lt;p&gt;并不鼓励使用finalize()方法来拯救对象，因为它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。finalize()能做的所有工作，使用try-finally或其他方式都可以做得更好。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Eden区和Survivor区的含义以及工作原理？&lt;/p&gt;

    &lt;p&gt;目前主流的虚拟机实现都采用了分代收集的思想，把整个堆区划分为新生代和老年代；新生代又被划分成Eden 空间、 From Survivor 和 To Survivor 三块区域。&lt;/p&gt;

    &lt;p&gt;我们把Eden : From Survivor : To Survivor 空间大小设成 8 : 1 : 1 ，对象总是在 Eden 区出生， From Survivor 保存当前的幸存对象， To Survivor 为空。一次 gc 发生后： 1）Eden 区活着的对象 ＋ From Survivor 存储的对象被复制到 To Survivor ；2) 清空 Eden 和 From Survivor ； 3) 颠倒 From Survivor 和 To Survivor 的逻辑关系： From 变 To ， To 变 From 。可以看出，只有在 Eden 空间快满的时候才会触发 Minor GC 。而 Eden 空间占新生代的绝大部分，所以 Minor GC 的频率得以降低。当然，使用两个 Survivor 这种方式我们也付出了一定的代价，如 10% 的空间浪费、复制对象的开销等。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;《深入理解JVM》P51 垃圾收集算法&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;标记-清除算法&lt;/p&gt;

        &lt;p&gt;算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。&lt;/p&gt;

        &lt;p&gt;它的主要缺点有两个：一个是效率问题，标记和清除过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量布莱纳许的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;复制算法&lt;/p&gt;

        &lt;p&gt;为了解决效率问题，一种称为“复制”的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这块用完了，就将还活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样是的每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价时将内存缩小为原来的一半，未免太高了一点。&lt;/p&gt;

        &lt;p&gt;现在的商业虚拟机都采用这种收集算法来回收新生代，新生代中的对象98%是朝生夕死的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%(80%+10%)，只有10%的内存是会被“浪费”的。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够时，需要依赖其他内存（这里指老年代）进行分配担保。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;标记-整理算法&lt;/p&gt;

        &lt;p&gt;根据老年代的特点，有人提出了另外一种“标记-整理”算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象对象进行清理，而是所有存活的对象都向一端移动，然后直接清理掉段边界以外的内存。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;分代收集算法&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;当前商业虚拟机的垃圾收集都采用“分代收集”算法，这种算法并没有什么新的思想，只是根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少了存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;JVM的回收算法以及它的回收器是什么？CMS采用哪种回收算法？使用CMS怎样解决内存碎片的问题呢？&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;《深入理解JVM》P55 垃圾收集器&lt;/p&gt;

      &lt;p&gt;&lt;a href=&quot;https://crowhawk.github.io/2017/08/15/jvm_3/&quot;&gt;https://crowhawk.github.io/2017/08/15/jvm_3/&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;&lt;strong&gt;如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。&lt;/strong&gt;Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、版本的虚拟机所提供的垃圾收集器都可能会有很大差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。接下来讨论的收集器基于JDK1.7 Update 14 之后的HotSpot虚拟机（在此版本中正式提供了商用的G1收集器，之前G1仍处于实验状态），该虚拟机包含的所有收集器如下图所示：&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://pic.yupoo.com/crowhawk/56a02e55/3b3c42d2.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;上图展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。Hotspot实现了如此多的收集器，正是因为目前并无完美的收集器出现，只是选择对具体应用最适合的收集器。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;相关概念&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;并行和并发&lt;/p&gt;

            &lt;ul&gt;
              &lt;li&gt;&lt;strong&gt;并行（Parallel）&lt;/strong&gt;：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。&lt;/li&gt;
              &lt;li&gt;&lt;strong&gt;并发（Concurrent）&lt;/strong&gt;：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行。而垃圾收集程序运行在另一个CPU上。&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;吞吐量（Throughput）&lt;/p&gt;

            &lt;p&gt;吞吐量就是&lt;strong&gt;CPU用于运行用户代码的时间&lt;/strong&gt;与&lt;strong&gt;CPU总消耗时间&lt;/strong&gt;的比值，即&lt;/p&gt;

            &lt;p&gt;&lt;strong&gt;吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。&lt;/strong&gt;&lt;/p&gt;

            &lt;p&gt;假设虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;Minor GC 和 Full GC&lt;/p&gt;
            &lt;ul&gt;
              &lt;li&gt;&lt;strong&gt;新生代GC（Minor GC）&lt;/strong&gt;：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。具体原理见上一篇文章。&lt;/li&gt;
              &lt;li&gt;&lt;strong&gt;老年代GC（Major GC / Full GC）&lt;/strong&gt;：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;新生代收集器&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;Serial收集器&lt;/p&gt;

            &lt;p&gt;&lt;strong&gt;Serial（串行）&lt;/strong&gt;收集器是最基本、发展历史最悠久的收集器，它是采用&lt;strong&gt;复制算法&lt;/strong&gt;的&lt;strong&gt;新生代收集器&lt;/strong&gt;，曾经（JDK 1.3.1之前）是虚拟机&lt;strong&gt;新生代&lt;/strong&gt;收集的唯一选择。它是一个单线程收集器，只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是&lt;strong&gt;它在进行垃圾收集时，必须暂停其他所有的工作线程，直至Serial收集器收集结束为止（“Stop The World”）&lt;/strong&gt;。这项工作是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说是难以接收的。&lt;/p&gt;

            &lt;p&gt;下图展示了Serial 收集器（老年代采用Serial Old收集器）的运行过程：&lt;/p&gt;

            &lt;p&gt;&lt;img src=&quot;https://pic.yupoo.com/crowhawk/6b90388c/6c281cf0.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

            &lt;p&gt;为了消除或减少工作线程因内存回收而导致的停顿，HotSpot虚拟机开发团队在JDK 1.3之后的Java发展历程中研发出了各种其他的优秀收集器，这些将在稍后介绍。但是这些收集器的诞生并不意味着Serial收集器已经“老而无用”，实际上到现在为止，它依然是&lt;strong&gt;HotSpot虚拟机运行在Client模式下的默认的新生代收集器&lt;/strong&gt;。它也有着优于其他收集器的地方：&lt;strong&gt;简单而高效（与其他收集器的单线程相比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得更高的单线程收集效率。&lt;/strong&gt;&lt;/p&gt;

            &lt;p&gt;在用户的桌面应用场景中，分配给虚拟机管理的内存一般不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本不会再大了），停顿时间完全可以控制在几十毫秒最多一百毫秒以内，只要不频繁发生，这点停顿时间可以接收。所以，Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;ParNew 收集器&lt;/p&gt;

            &lt;p&gt;&lt;strong&gt;ParNew&lt;/strong&gt;收集器就是Serial收集器的多线程版本，它也是一个&lt;strong&gt;新生代收集器&lt;/strong&gt;。除了使用多线程进行垃圾收集外，其余行为包括Serial收集器可用的所有控制参数、收集算法（复制算法）、Stop The World、对象分配规则、回收策略等与Serial收集器完全相同，两者共用了相当多的代码。&lt;/p&gt;

            &lt;p&gt;ParNew收集器的工作过程如下图（老年代采用Serial Old收集器）：&lt;/p&gt;

            &lt;p&gt;&lt;img src=&quot;https://pic.yupoo.com/crowhawk/605f57b5/75122b84.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

            &lt;p&gt;ParNew收集器除了使用多线程收集外，其他与Serial收集器相比并无太多创新之处，但它却是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关的重要原因是，&lt;strong&gt;除了Serial收集器外，目前只有它能和CMS收集器（Concurrent Mark Sweep）配合工作&lt;/strong&gt;，CMS收集器是JDK 1.5推出的一个具有划时代意义的收集器，具体内容将在稍后进行介绍。&lt;/p&gt;

            &lt;p&gt;ParNew 收集器在&lt;strong&gt;单CPU的环境&lt;/strong&gt;中绝对不会有比Serial收集器有更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百地保证可以超越。在&lt;strong&gt;多CPU环境&lt;/strong&gt;下，随着CPU的数量增加，它对于GC时系统资源的有效利用是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多的情况下可使用&lt;strong&gt;-XX:ParallerGCThreads&lt;/strong&gt;参数设置。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;Parallel Scavenge 收集器&lt;/p&gt;

            &lt;p&gt;&lt;strong&gt;Parallel Scavenge&lt;/strong&gt;收集器也是一个&lt;strong&gt;并行&lt;/strong&gt;的&lt;strong&gt;多线程新生代&lt;/strong&gt;收集器，它也使用&lt;strong&gt;复制算法&lt;/strong&gt;。Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标是&lt;strong&gt;达到一个可控制的吞吐量（Throughput）&lt;/strong&gt;。&lt;/p&gt;

            &lt;p&gt;&lt;strong&gt;停顿时间越短就越适合需要与用户交互的程序&lt;/strong&gt;，良好的响应速度能提升用户体验。而&lt;strong&gt;高吞吐量&lt;/strong&gt;则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合&lt;strong&gt;在后台运算而不需要太多交互的任务&lt;/strong&gt;。&lt;/p&gt;

            &lt;p&gt;Parallel Scavenge收集器除了会显而易见地提供可以精确控制吞吐量的参数，还提供了一个参数&lt;strong&gt;-XX:+UseAdaptiveSizePolicy&lt;/strong&gt;，这是一个开关参数，打开参数后，就不需要手工指定新生代的大小（-Xmn）、Eden和Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为&lt;strong&gt;GC自适应的调节策略（GC Ergonomics）&lt;/strong&gt;。自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。&lt;/p&gt;

            &lt;p&gt;另外值得注意的一点是，Parallel Scavenge收集器无法与CMS收集器配合使用，所以在JDK 1.6推出Parallel Old之前，如果新生代选择Parallel Scavenge收集器，老年代只有Serial Old收集器能与之配合使用。&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;老年代收集器&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;Serial Old收集器&lt;/p&gt;

            &lt;p&gt;Serial Old 是 Serial收集器的老年代版本，它同样是一个&lt;strong&gt;单线程收集器&lt;/strong&gt;，使用&lt;strong&gt;“标记-整理”（Mark-Compact）&lt;/strong&gt;算法。&lt;/p&gt;

            &lt;p&gt;此收集器的主要意义也是在于给Client模式下的虚拟机使用。如果在Server模式下，它还有两大用途：&lt;/p&gt;

            &lt;ul&gt;
              &lt;li&gt;在JDK1.5 以及之前版本（Parallel Old诞生以前）中与Parallel Scavenge收集器搭配使用。&lt;/li&gt;
              &lt;li&gt;作为CMS收集器的后备预案，在并发收集发生&lt;strong&gt;Concurrent Mode Failure&lt;/strong&gt;时使用。&lt;/li&gt;
            &lt;/ul&gt;

            &lt;p&gt;它的工作流程与Serial收集器相同，这里再次给出Serial/Serial Old配合使用的工作流程图：&lt;/p&gt;

            &lt;p&gt;&lt;img src=&quot;https://pic.yupoo.com/crowhawk/6b90388c/6c281cf0.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;Parallel Old收集器&lt;/p&gt;

            &lt;p&gt;Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用&lt;strong&gt;多线程&lt;/strong&gt;和&lt;strong&gt;“标记-整理”&lt;/strong&gt;算法。前面已经提到过，这个收集器是在JDK 1.6中才开始提供的，在此之前，如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old以外别无选择，所以在Parallel Old诞生以后，&lt;strong&gt;“吞吐量优先”收集器&lt;/strong&gt;终于有了比较名副其实的应用组合，在&lt;strong&gt;注重吞吐量&lt;/strong&gt;以及&lt;strong&gt;CPU资源敏感&lt;/strong&gt;的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。Parallel Old收集器的工作流程与Parallel Scavenge相同，这里给出Parallel Scavenge/Parallel Old收集器配合使用的流程图：&lt;/p&gt;

            &lt;p&gt;&lt;img src=&quot;https://pic.yupoo.com/crowhawk/9a6b1249/b1800d45.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;CMS收集器&lt;/p&gt;

            &lt;p&gt;&lt;strong&gt;CMS（Concurrent Mark Sweep）&lt;/strong&gt;收集器是一种以&lt;strong&gt;获取最短回收停顿时间&lt;/strong&gt;为目标的收集器，它非常符合那些集中在互联网站或者B/S系统的服务端上的Java应用，这些应用都非常重视服务的响应速度。从名字上（“Mark Sweep”）就可以看出它是基于&lt;strong&gt;“标记-清除”&lt;/strong&gt;算法实现的。&lt;/p&gt;

            &lt;p&gt;CMS收集器工作的整个流程分为以下4个步骤：&lt;/p&gt;

            &lt;ul&gt;
              &lt;li&gt;&lt;strong&gt;初始标记（CMS initial mark）&lt;/strong&gt;：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要“Stop The World”。&lt;/li&gt;
              &lt;li&gt;&lt;strong&gt;并发标记（CMS concurrent mark）&lt;/strong&gt;：进行&lt;strong&gt;GC Roots Tracing&lt;/strong&gt;的过程，在整个过程中耗时最长。&lt;/li&gt;
              &lt;li&gt;&lt;strong&gt;重新标记（CMS remark）&lt;/strong&gt;：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。此阶段也需要“Stop The World”。&lt;/li&gt;
              &lt;li&gt;&lt;strong&gt;并发清除（CMS concurrent sweep）&lt;/strong&gt;&lt;/li&gt;
            &lt;/ul&gt;

            &lt;p&gt;由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。通过下图可以比较清楚地看到CMS收集器的运作步骤中并发和需要停顿的时间：&lt;/p&gt;

            &lt;p&gt;&lt;img src=&quot;https://pic.yupoo.com/crowhawk/fffcf9a2/f60599b2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

            &lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;

            &lt;p&gt;CMS是一款优秀的收集器，它的主要&lt;strong&gt;优点&lt;/strong&gt;在名字上已经体现出来了：&lt;strong&gt;并发收集&lt;/strong&gt;、&lt;strong&gt;低停顿&lt;/strong&gt;，因此CMS收集器也被称为&lt;strong&gt;并发低停顿收集器（Concurrent Low Pause Collector）&lt;/strong&gt;。&lt;/p&gt;

            &lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;

            &lt;ul&gt;
              &lt;li&gt;&lt;strong&gt;对CPU资源非常敏感&lt;/strong&gt; 其实，面向并发设计的程序都对CPU资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。&lt;strong&gt;CMS默认启动的回收线程数是（CPU数量+3）/4&lt;/strong&gt;，也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是&lt;strong&gt;当CPU不足4个时（比如2个），CMS对用户程序的影响就可能变得很大&lt;/strong&gt;，如果本来CPU负载就比较大，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了50%，其实也让人无法接受。&lt;/li&gt;
              &lt;li&gt;&lt;strong&gt;无法处理浮动垃圾（Floating Garbage）&lt;/strong&gt; 可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。&lt;strong&gt;由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生。&lt;/strong&gt;这一部分垃圾出现在标记过程之后，CMS无法再当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就被称为&lt;strong&gt;“浮动垃圾”&lt;/strong&gt;。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。&lt;/li&gt;
              &lt;li&gt;&lt;strong&gt;标记-清除算法导致的空间碎片&lt;/strong&gt; CMS是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次Full GC。为了解决这个问题，CMS收集器提供了一个-XX:+UseCMSCompactAtFullCollection开关参数，用于在“享受”完Full GC服务之后额外免费附送一个碎片整理过程，内存整理的过程是无法并发的。空间碎片问题没有了，但停顿时间不得不变长了。虚拟机设计者还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction，这个参数用于设置在执行多少次不压缩的Full GC后，跟着来一次带压缩的。&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;G1收集器&lt;/p&gt;

            &lt;p&gt;&lt;strong&gt;G1（Garbage-First）&lt;/strong&gt;收集器是当今收集器技术发展最前沿的成果之一，它是一款&lt;strong&gt;面向服务端应用&lt;/strong&gt;的垃圾收集器，HotSpot开发团队赋予它的使命是（在比较长期的）未来可以替换掉JDK 1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点：&lt;/p&gt;

            &lt;ul&gt;
              &lt;li&gt;&lt;strong&gt;并行与并发&lt;/strong&gt; G1 能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短“Stop The World”停顿时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。&lt;/li&gt;
              &lt;li&gt;&lt;strong&gt;分代收集&lt;/strong&gt; 与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同方式去处理新创建的对象和已存活一段时间、熬过多次GC的旧对象来获取更好的收集效果。&lt;/li&gt;
              &lt;li&gt;&lt;strong&gt;空间整合&lt;/strong&gt; G1从整体来看是基于&lt;strong&gt;“标记-整理”&lt;/strong&gt;算法实现的收集器，从局部（两个Region之间）上来看是基于&lt;strong&gt;“复制”&lt;/strong&gt;算法实现的。这意味着G1运行期间不会产生内存空间碎片，收集后能提供规整的可用内存。此特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。&lt;/li&gt;
              &lt;li&gt;&lt;strong&gt;可预测的停顿&lt;/strong&gt; 这是G1相对CMS的一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了降低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在GC上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。&lt;/li&gt;
            &lt;/ul&gt;

            &lt;p&gt;&lt;strong&gt;横跨整个堆内存&lt;/strong&gt;&lt;/p&gt;

            &lt;p&gt;在G1之前的其他收集器进行收集的范围都是整个新生代或者老生代，而G1不再是这样。G1在使用时，Java堆的内存布局与其他收集器有很大区别，它&lt;strong&gt;将整个Java堆划分为多个大小相等的独立区域（Region）&lt;/strong&gt;，虽然还保留新生代和老年代的概念，但&lt;strong&gt;新生代和老年代不再是物理隔离的了，而都是一部分Region（不需要连续）的集合&lt;/strong&gt;。&lt;/p&gt;

            &lt;p&gt;&lt;strong&gt;建立可预测的时间模型&lt;/strong&gt;&lt;/p&gt;

            &lt;p&gt;G1收集器之所以能建立可预测的停顿时间模型，是因为它可以&lt;strong&gt;有计划地避免在整个Java堆中进行全区域的垃圾收集&lt;/strong&gt;。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），&lt;strong&gt;在后台维护一个优先列表&lt;/strong&gt;，每次根据允许的收集时间，&lt;strong&gt;优先回收价值最大的Region（这也就是Garbage-First名称的来由）&lt;/strong&gt;。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。&lt;/p&gt;

            &lt;p&gt;&lt;strong&gt;避免全堆扫描——Remembered Set&lt;/strong&gt;&lt;/p&gt;

            &lt;p&gt;G1把Java堆分为多个Region，就是“化整为零”。但是Region不可能是孤立的，一个对象分配在某个Region中，可以与整个Java堆任意的对象发生引用关系。在做可达性分析确定对象是否存活的时候，需要扫描整个Java堆才能保证准确性，这显然是对GC效率的极大伤害。&lt;/p&gt;

            &lt;p&gt;为了避免全堆扫描的发生，虚拟机&lt;strong&gt;为G1中每个Region维护了一个与之对应的Remembered Set&lt;/strong&gt;。虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过CardTable&lt;strong&gt;把相关引用信息记录到被引用对象所属的Region的Remembered Set之中&lt;/strong&gt;。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;

        &lt;hr /&gt;

        &lt;p&gt;如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为以下几个步骤：&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;初始标记（Initial Marking）&lt;/strong&gt; 仅仅只是标记一下GC Roots 能直接关联到的对象，并且修改&lt;strong&gt;TAMS（Nest Top Mark Start）&lt;/strong&gt;的值，让下一阶段用户程序并发运行时，能在正确可以的Region中创建对象，此阶段需要&lt;strong&gt;停顿线程&lt;/strong&gt;，但耗时很短。&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;并发标记（Concurrent Marking）&lt;/strong&gt; 从GC Root 开始对堆中对象进行&lt;strong&gt;可达性分析&lt;/strong&gt;，找到存活对象，此阶段耗时较长，但&lt;strong&gt;可与用户程序并发执行&lt;/strong&gt;。&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;最终标记（Final Marking）&lt;/strong&gt; 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在&lt;strong&gt;线程的Remembered Set Logs&lt;/strong&gt;里面，最终标记阶段需要&lt;strong&gt;把Remembered Set Logs的数据合并到Remembered Set中&lt;/strong&gt;，这阶段需要&lt;strong&gt;停顿线程&lt;/strong&gt;，但是&lt;strong&gt;可并行执行&lt;/strong&gt;。&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;筛选回收（Live Data Counting and Evacuation）&lt;/strong&gt; 首先对各个Region中的回收价值和成本进行排序，根据用户所期望的GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。&lt;/li&gt;
        &lt;/ul&gt;

        &lt;p&gt;通过下图可以比较清楚地看到G1收集器的运作步骤中并发和需要停顿的阶段（Safepoint处）：&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;https://pic.yupoo.com/crowhawk/53b7a589/0bce1667.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;总结&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;新生代的收集器有Serial、ParNew、Parallel Scavenge。Serial收集器是串行、单线程的收集器，在收集垃圾时需要暂停其他所有的工作，stop the world，使用复制算法。ParNew收集器是Serial的并行、多线程版本，可以配合CMS使用。Parallel Scavenge收集器目标是达到高吞吐量，可以配合Parallel Old使用。&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;老年代的收集器有Serial Old、Parallel Old、CMS、G1算法。Serial Old收集器是Serial收集器的老年代版本，使用标记-整理算法。Parallel Old收集器是Parallel Scavenge的老年代版本，使用多线程和标记-整理算法。&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;CMS收集器的目标是低停顿、高响应速度，基于标记-清除算法，步骤分为初始标记（标记GC Roots能关联到的对象，速度很快，需要stop the world）、并发标记（GC Root Tracing，耗时最长）、重新标记（修复并发标记期间改动的标记，需要stop the world）、并发清除。&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;G1收集器使命是在未来替  uio代CMS。G1将整个Java堆划分为多个大小相等的独立区域（Region），每个Region维护了一个与之对应的Remembered Set，把相关引用信息记录到被引用对象所属的Region的Remembered Set之中。从整体来看基于标记-整理算法，从局部（两个Region之间）来看基于复制算法。步骤分为：初始标记、并发标记、最终标记（将变动合并到Remember Set中）、筛选回收（回收一部分Region）。&lt;/strong&gt;&lt;/p&gt;

        &lt;table&gt;
          &lt;thead&gt;
            &lt;tr&gt;
              &lt;th&gt;收集器&lt;/th&gt;
              &lt;th&gt;串行、并行or并发&lt;/th&gt;
              &lt;th&gt;新生代/老年代&lt;/th&gt;
              &lt;th&gt;算法&lt;/th&gt;
              &lt;th&gt;目标&lt;/th&gt;
              &lt;th&gt;适用场景&lt;/th&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;&lt;strong&gt;Serial&lt;/strong&gt;&lt;/td&gt;
              &lt;td&gt;&lt;strong&gt;串行&lt;/strong&gt;&lt;/td&gt;
              &lt;td&gt;新生代&lt;/td&gt;
              &lt;td&gt;复制算法&lt;/td&gt;
              &lt;td&gt;响应速度优先&lt;/td&gt;
              &lt;td&gt;单CPU环境下的Client模式&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;&lt;strong&gt;ParNew&lt;/strong&gt;&lt;/td&gt;
              &lt;td&gt;&lt;strong&gt;并行&lt;/strong&gt;&lt;/td&gt;
              &lt;td&gt;新生代&lt;/td&gt;
              &lt;td&gt;复制算法&lt;/td&gt;
              &lt;td&gt;响应速度优先&lt;/td&gt;
              &lt;td&gt;多CPU环境时在Server模式下&lt;strong&gt;与CMS配合&lt;/strong&gt;&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;&lt;strong&gt;Parallel Scavenge&lt;/strong&gt;&lt;/td&gt;
              &lt;td&gt;并行&lt;/td&gt;
              &lt;td&gt;新生代&lt;/td&gt;
              &lt;td&gt;复制算法&lt;/td&gt;
              &lt;td&gt;&lt;strong&gt;吞吐量优先&lt;/strong&gt;&lt;/td&gt;
              &lt;td&gt;在后台运算而不需要太多交互的任务&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;&lt;strong&gt;Serial Old&lt;/strong&gt;&lt;/td&gt;
              &lt;td&gt;串行&lt;/td&gt;
              &lt;td&gt;老年代&lt;/td&gt;
              &lt;td&gt;标记-整理&lt;/td&gt;
              &lt;td&gt;响应速度优先&lt;/td&gt;
              &lt;td&gt;单CPU环境下的Client模式、CMS的后备预案&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;&lt;strong&gt;Parallel Old&lt;/strong&gt;&lt;/td&gt;
              &lt;td&gt;并行&lt;/td&gt;
              &lt;td&gt;老年代&lt;/td&gt;
              &lt;td&gt;标记-整理&lt;/td&gt;
              &lt;td&gt;吞吐量优先&lt;/td&gt;
              &lt;td&gt;在后台运算而不需要太多交互的任务&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;&lt;strong&gt;CMS&lt;/strong&gt;&lt;/td&gt;
              &lt;td&gt;&lt;strong&gt;并发&lt;/strong&gt;&lt;/td&gt;
              &lt;td&gt;老年代&lt;/td&gt;
              &lt;td&gt;&lt;strong&gt;标记-清除&lt;/strong&gt;&lt;/td&gt;
              &lt;td&gt;&lt;strong&gt;响应速度优先&lt;/strong&gt;&lt;/td&gt;
              &lt;td&gt;集中在互联网站或B/S系统服务端上的Java应用&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;&lt;strong&gt;G1&lt;/strong&gt;&lt;/td&gt;
              &lt;td&gt;并发&lt;/td&gt;
              &lt;td&gt;both&lt;/td&gt;
              &lt;td&gt;标记-整理+复制算法&lt;/td&gt;
              &lt;td&gt;响应速度优先&lt;/td&gt;
              &lt;td&gt;面向服务端应用，将来替换CMS&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Minor GC和Full GC触发条件&lt;/p&gt;

    &lt;p&gt;Minor GC触发条件：当&lt;strong&gt;Eden区满时&lt;/strong&gt;，触发Minor GC。&lt;/p&gt;

    &lt;p&gt;Full GC触发条件：&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;调用System.gc时，系统建议执行Full GC，但是不必然执行&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;老年代空间不足&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;方法区空间不足&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;通过Minor GC后进入老年代的平均大小大于老年代的可用内存&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;什么时候触发MinorGC?什么时候触发FullGC?&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/williamjie/p/9516367.html&quot;&gt;https://www.cnblogs.com/williamjie/p/9516367.html&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;&lt;strong&gt;触发MinorGC(Young GC)&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;虚拟机在进行minorGC之前会判断老年代最大的可用连续空间是否大于新生代的所有对象总空间&lt;/p&gt;

    &lt;p&gt;1、如果大于的话，直接执行minorGC&lt;/p&gt;

    &lt;p&gt;2、如果小于，判断是否开启HandlerPromotionFailure，没有开启直接FullGC&lt;/p&gt;

    &lt;p&gt;3、如果开启了HanlerPromotionFailure, JVM会判断老年代的最大连续内存空间是否大于历次晋升的大小，如果小于直接执行FullGC&lt;/p&gt;

    &lt;p&gt;4、如果大于的话，执行minorGC&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;触发FullGC&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;老年代空间不足&lt;/p&gt;

        &lt;p&gt;如果创建一个大对象，Eden区域当中放不下这个大对象，会直接保存在老年代当中，如果老年代空间也不足，就会触发Full GC。为了避免这种情况，最好就是不要创建太大的对象。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;持久代空间不足&lt;/p&gt;

        &lt;p&gt;如果有持久代空间的话，系统当中需要加载的类，调用的方法很多，同时持久代当中没有足够的空间，就出触发一次Full GC&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;YGC出现promotion failure&lt;/p&gt;

        &lt;p&gt;promotion failure发生在Young GC, 如果Survivor区当中存活对象的年龄达到了设定值，会就将Survivor区当中的对象拷贝到老年代，如果老年代的空间不足，就会发生promotion failure， 接下去就会发生Full GC.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;统计YGC发生时晋升到老年代的平均总大小大于老年代的空闲空间&lt;/p&gt;

        &lt;p&gt;在发生YGC是会判断，是否安全，这里的安全指的是，当前老年代空间可以容纳YGC晋升的对象的平均大小，如果不安全，就不会执行YGC,转而执行Full GC。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;显示调用System.gc&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;什么原因会导致minor gc运行频繁？同样的，什么原因又会导致minor gc运行很慢？&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/questionTerminal/b3cd86f89d6c4b1ab54252b49a6bff57&quot;&gt;https://www.nowcoder.com/questionTerminal/b3cd86f89d6c4b1ab54252b49a6bff57&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;什么原因会导致minor gc运行频繁？&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;产生了太多朝生夕灭的对象导致需要频繁minor gc&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;新生代空间设置的比较小&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;什么原因会导致minor gc运行很慢？&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;新生代空间设置过大。&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;对象引用链较长，进行可达性分析时间较长。&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;新生代survivor区设置的比较小，清理后剩余的对象不能装进去需要移动到老年代，造成移动开销。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;内存分配担保失败，由minor gc转化为full gc&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;采用的垃圾收集器效率较低，比如新生代使用serial收集器&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;

    &lt;blockquote&gt;
      &lt;p&gt;《深入理解JVM》P65 内存分配与回收策略&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;对象优先在Eden分配&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;大对象直接进入老年代&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;大对象对虚拟机的内存分配来说是个坏消息，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;长期存活的对象将进入老年代&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;虚拟机既然采用了分代收集的思想来管理内存，那内存回收时就必须能识别哪些对象应该放在新生代，哪些对象应该放在老年代。为了做到这点，虚拟机给每个对象定义了一个对象年龄计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁）时，就会被晋升到老年代中。对象今生老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold来设置。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;动态对象年龄判定&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;为了能更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，&lt;strong&gt;如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代&lt;/strong&gt;，无需等到MaxTenuringThreshold中要求的年龄。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;空间分配担保&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;在发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则改为直接进行一次Full GC。如果小于，则查看HandlePromotionFailure设置是否允许担保失败；如果允许，那只会进行Minor GC；如果不允许，则也要改为进行一次Full GC。&lt;/p&gt;

        &lt;p&gt;前面提到过，新生代使用复制收集算法，但为了内存利用率，&lt;strong&gt;只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况时（最极端就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，让Survivor无法容纳的对象直接进入老年代。&lt;/strong&gt;与生活中的贷款担保类似，老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的空间，一共有多少对象会活下来，在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。&lt;/p&gt;

        &lt;p&gt;取平均值进行比较其实仍然是一种动态概率的手段，也就是说如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败。如果出现了HandlePromotionFailure失败，那就只好在失败后重新发起一次Full GC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将HandlePromotionFailure开关打开，避免Full GC过于频繁。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;java.lang.String写个一模一样的可以运行吗，会报错吗&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;《深入理解JVM》P193&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;使用双亲委派模型来组织类和加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如&lt;code class=&quot;highlighter-rouge&quot;&gt;Java.lang.Object&lt;/code&gt;，它存放在&lt;code class=&quot;highlighter-rouge&quot;&gt;rt.jar&lt;/code&gt;之中，无论哪一个类加载器要加载这个类，最终都是委派给启动类加载器进行加载，因此Object类在程序的各种累加器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行区加载的话，如果用户自己写了一个名为&lt;code class=&quot;highlighter-rouge&quot;&gt;Java.lang.Object&lt;/code&gt;的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无从保证，应用程序也将会变得一片混乱。可以尝试区写一个与&lt;code class=&quot;highlighter-rouge&quot;&gt;rt.jar&lt;/code&gt;类库中已有类重名的Java类，将会发现可以正常编译，但永远无法被加载运行。（即使自定义了自己的加载器，强行用defineClass()方法去加载一个以&lt;code class=&quot;highlighter-rouge&quot;&gt;Java.lang&lt;/code&gt;开头的类也不会成功。如果读者尝试这样做的话，将会收到一个由虚拟机自己抛出的&lt;code class=&quot;highlighter-rouge&quot;&gt;java.lang.SecurityException: Prohibited package name: java.lang&lt;/code&gt;异常。）&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/tang9140/article/details/42738433&quot;&gt;https://blog.csdn.net/tang9140/article/details/42738433&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/questionTerminal/a90230b35b5f4a7287f779ecdd88841d&quot;&gt;https://www.nowcoder.com/questionTerminal/a90230b35b5f4a7287f779ecdd88841d&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;java的跨平台不是java源程序的跨平台 ，如果是这样，那么所有语言都是跨平台的， java源程序先经过javac编译器编译成二进制的.class字节码文件（java的跨平台指的就是.class字节码文件的跨平台，.class字节码文件是与平台无关的），.class文件再运行在jvm上，java解释器（jvm的一部分）会将其解释成对应平台的机器码执行，所以java所谓的跨平台就是在不同平台上安装了不同的jvm，而在不同平台上生成的.class文件都是一样的，而.class文件再由对应平台的jvm解释成对应平台的机器码执行。&lt;/p&gt;

    &lt;p&gt;最后解释下机器码和字节码的区别:&lt;/p&gt;

    &lt;p&gt;一，机器码，完全依附硬件而存在～并且不同硬件由于内嵌指令集不同，即使相同的0 1代码 意思也可能是不同的～换句话说，根本不存在跨平台性～比如～不同型号的CPU,你给他个指令10001101，他们可能会解析为不同的结果～&lt;/p&gt;

    &lt;p&gt;二，我们知道JAVA是跨平台的，为什么呢？因为他有一个jvm,不论哪种硬件，只要你装有jvm,那么他就认识这个JAVA字节码～～～～至于底层的机器码，咱不用管，有jvm搞定，他会把字节码再翻译成所在机器认识的机器码～～～&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;JVM最大内存限制多少？&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/lengyuhong/article/details/6044894&quot;&gt;https://blog.csdn.net/lengyuhong/article/details/6044894&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;没想到第一个实验的程序，跑了几个小时，就遇到了Out of Memory Exception了。看看自己的虚拟机设置，我设置的是-Xms512M -Xmx1024M。想都没想，直接改成-Xms512M -Xmx2048M，结果直接就Could not reserve enough space for object heap。程序都起不来了。这才发现原来最大内存还有限制。上网搜了一下，发现很多讨论这个问题的文章。最终在BEA的DEV2DEV论坛发现了最有用的一篇&lt;/p&gt;

    &lt;p&gt;这里的版主YuLimin 做了&lt;a href=&quot;http://softtest.chinaitlab.com/&quot;&gt;测试&lt;/a&gt;，得出结论：&lt;/p&gt;

    &lt;p&gt;　　公司 JVM版本                  最大内存(兆)client    最大内存(兆)server&lt;/p&gt;

    &lt;p&gt;　　SUN 1.5.x                          1492                            1520&lt;/p&gt;

    &lt;p&gt;　　SUN 1.5.5(Linux)             2634                            2660&lt;/p&gt;

    &lt;p&gt;　　SUN 1.4.2                          1564                            1564&lt;/p&gt;

    &lt;p&gt;　　SUN 1.4.2(Linux)             1900                            1260&lt;/p&gt;

    &lt;p&gt;　　IBM 1.4.2(Linux)             2047                             N/A&lt;/p&gt;

    &lt;p&gt;　　BEA JRockit 1.5 (U3)      1909                             1902&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/questionTerminal/855006adab6b45afb9fe98e3c72b90d6&quot;&gt;https://www.nowcoder.com/questionTerminal/855006adab6b45afb9fe98e3c72b90d6&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;首先JVM内存限制于实际的最大物理内存了 假设物理内存无限大的话 JVM内存的最大值跟操作系统有很大的关系 简单的说就32位处理器虽然可控内存空间有4GB,但是具体的操作系统会给一个限制，这个限制一般是2GB-3GB（一般来说Windows系统下为1.5G-2G Linux系统 下为2G-3G） 而64bit以上的处理器就不会有限制了&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;假设一个场景，要求stop the world时间非常短，你会怎么设计垃圾回收机制？&lt;/p&gt;

    &lt;p&gt;ParNew + CMS&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？并且有什么办法可以主动通知虚拟机进行垃圾回收呢？&lt;/p&gt;

    &lt;p&gt;对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在java中会存在内存泄漏吗？&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/m0_37204491/article/details/64500151&quot;&gt;https://blog.csdn.net/m0_37204491/article/details/64500151&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;&lt;strong&gt;内存泄露&lt;/strong&gt;就是指一个不再被程序使用的对象或变量一直被占据在内存中。java中有垃圾回收机制，它可以保证一对象不再被引用的时候，即对象变成了孤儿的时候，对象将自动被垃圾回收器从内存中清除掉。由于Java 使用有向图的方式进行垃圾回收管理，可以消除引用循环的问题，例如有两个对象，相互引用，只要它们和根进程不可达的，那么GC也是可以回收它们的。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;java中的内存泄露的情况&lt;/strong&gt;：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景，通俗地说，就是&lt;strong&gt;程序员可能创建了一个对象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的&lt;/strong&gt;，这就是java中可能出现内存泄露的情况，例如，缓存系统，我们加载了一个对象放在缓存中(例如放在一个全局map对象中)，然后一直不再使用它，这个对象一直被缓存引用，但却不再被使用。&lt;/p&gt;

        &lt;p&gt;检查java中的内存泄露，一定要让程序将各种分支情况都完整执行到程序结束，然后看某个对象是否被使用过，如果没有，则才能判定这个对象属于内存泄露。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持久外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;垃圾回收的优点以及原理&lt;/p&gt;

    &lt;p&gt;Java 语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有”作用域”的概念，只有对象的引用才有”作用域”。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Java中的对象一定在堆上分配吗&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/zhaohong_bo/article/details/89419480&quot;&gt;https://blog.csdn.net/zhaohong_bo/article/details/89419480&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 05 Mar 2020 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/03/05/jvm/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/03/05/jvm/</guid>
        
        <category>学习</category>
        
        
      </item>
    
      <item>
        <title>Java</title>
        <description>&lt;h2 id=&quot;基础&quot;&gt;基础&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Java简单类型&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;byte：8位，最大存储数据量是255，存放的数据范围是-128~127之间。&lt;/li&gt;
      &lt;li&gt;short：16位，最大数据存储量是65536，数据范围是-32768~32767之间。&lt;/li&gt;
      &lt;li&gt;int：32位，最大数据存储容量是2的32次方减1，数据范围是负的2的31次方到正的2的31次方减1。&lt;/li&gt;
      &lt;li&gt;long：64位，最大数据存储容量是2的64次方减1，数据范围为负的2的63次方到正的2的63次方减1。&lt;/li&gt;
      &lt;li&gt;float：32位，数据范围在3.4e-45~1.4e38，直接赋值时必须在数字后加上f或F。&lt;/li&gt;
      &lt;li&gt;double：64位，数据范围在4.9e-324~1.8e308，赋值时可以加d或D也可以不加。&lt;/li&gt;
      &lt;li&gt;boolean：只有true和false两个取值。&lt;/li&gt;
      &lt;li&gt;char：16位，存储Unicode码，用单引号赋值。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Java中的I/O流&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;BIO、NIO、AIO&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;BIO (Blocking I/O):&lt;/strong&gt; 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;NIO (New I/O):&lt;/strong&gt; NIO是一种同步非阻塞的I/O模型。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;AIO (Asynchronous I/O):&lt;/strong&gt; AIO 也就是 NIO 2，是异步非阻塞的IO模型。&lt;/li&gt;
        &lt;/ul&gt;

        &lt;blockquote&gt;
          &lt;p&gt;&lt;a href=&quot;https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/BIO-NIO-AIO.md&quot;&gt;https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/BIO-NIO-AIO.md&lt;/a&gt;&lt;/p&gt;
        &lt;/blockquote&gt;

        &lt;p&gt;&lt;strong&gt;同步与异步&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;同步： 同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回。&lt;/p&gt;

        &lt;p&gt;异步： 异步就是发起一个调用后，立刻得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时我们可以处理其他的请求，被调用者通常依靠事件，回调等机制来通知调用者其返回结果。&lt;/p&gt;

        &lt;p&gt;同步和异步的区别最大在于异步的话调用者不需要等待处理结果，被调用者会通过回调等机制来通知调用者其返回结果。&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;阻塞和非阻塞&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;阻塞： 阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。&lt;/p&gt;

        &lt;p&gt;非阻塞： 非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。&lt;/p&gt;

        &lt;p&gt;举个生活中简单的例子，你妈妈让你烧水，小时候你比较笨啊，在那里傻等着水开（同步阻塞）。等你稍微再长大一点，你知道每次烧水的空隙可以去干点其他事，然后只需要时不时来看看水开了没有（同步非阻塞）。后来，你们家用上了水开了会发出声音的壶，这样你就只需要听到响声后就知道水开了，在这期间你可以随便干自己的事情，你需要去倒水了（异步非阻塞）。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;NIO&lt;/p&gt;

    &lt;p&gt;线程控制选择器，选择不同的通道来读取缓存区。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/362b365e1bcc&quot;&gt;https://www.jianshu.com/p/362b365e1bcc&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;IO和NIO的区别&lt;/p&gt;

    &lt;p&gt;原有的 IO 是面向流的、阻塞的，NIO 则是面向块的、非阻塞的。&lt;/p&gt;

    &lt;p&gt;怎么理解IO是面向流的、阻塞的
java1.4以前的io模型，一连接对一个线程。&lt;/p&gt;

    &lt;p&gt;原始的IO是面向流的，不存在缓存的概念。Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区&lt;/p&gt;

    &lt;p&gt;Java IO的各种流是阻塞的，这意味着当一个线程调用read或 write方法时，该线程被阻塞，直到有一些数据被读取，或数据完全写入，该线程在此期间不能再干任何事情了。&lt;/p&gt;

    &lt;p&gt;怎么理解NIO是面向块的、非阻塞的&lt;/p&gt;

    &lt;p&gt;NIO是面向缓冲区的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性。&lt;/p&gt;

    &lt;p&gt;Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。&lt;/p&gt;

    &lt;p&gt;通俗理解：NIO是可以做到用一个线程来处理多个操作的。假设有10000个请求过来,根据实际情况，可以分配50或者100个线程来处理。不像之前的阻塞IO那样，非得分配10000个。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;linux五种IO模型&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5c725dbe51882575e37ef9ed&quot;&gt;https://juejin.im/post/5c725dbe51882575e37ef9ed&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;Linux下主要有以下五种I/O模型：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;阻塞I/O（blocking IO）&lt;/li&gt;
      &lt;li&gt;非阻塞I/O (nonblocking I/O)&lt;/li&gt;
      &lt;li&gt;I/O 复用 (I/O multiplexing)&lt;/li&gt;
      &lt;li&gt;信号驱动I/O (signal driven I/O (SIGIO))&lt;/li&gt;
      &lt;li&gt;异步I/O (asynchronous I/O)&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;select、poll、eopll的区别&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/anker/p/3265058.html&quot;&gt;https://www.cnblogs.com/anker/p/3265058.html&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000003063859&quot;&gt;https://segmentfault.com/a/1190000003063859&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但&lt;strong&gt;select，poll，epoll本质上都是同步I/O&lt;/strong&gt;，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;select&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;select的几大缺点：&lt;/p&gt;

    &lt;p&gt;（1）每次调用select，&lt;strong&gt;都需要把fd集合从用户态拷贝到内核态&lt;/strong&gt;，这个开销在fd很多时会很大&lt;/p&gt;

    &lt;p&gt;（2）同时每次调用select&lt;strong&gt;都需要在内核遍历传递进来的所有fd&lt;/strong&gt;，这个开销在fd很多时也很大&lt;/p&gt;

    &lt;p&gt;（3）select支持的文件描述符数量太小了，默认是1024&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;poll&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;poll的实现和select非常相似，只是描述fd集合的方式不同，poll使用pollfd结构而不是select的fd_set结构。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;epoll&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;epoll既然是对select和poll的改进，就应该能避免上述的三个缺点。那epoll都是怎么解决的呢？在此之前，我们先看一下epoll和select和poll的调用接口上的不同，select和poll都只提供了一个函数——select或者poll函数。而epoll提供了三个函数，epoll_create,epoll_ctl和epoll_wait，epoll_create是创建一个epoll句柄；epoll_ctl是注册要监听的事件类型；epoll_wait则是等待事件的产生。&lt;/p&gt;

    &lt;p&gt;对于第一个缺点，epoll的解决方案&lt;strong&gt;在epoll_ctl函数中&lt;/strong&gt;。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），&lt;strong&gt;会把所有的fd拷贝进内核&lt;/strong&gt;，而不是在epoll_wait的时候重复拷贝。&lt;strong&gt;epoll保证了每个fd在整个过程中只会拷贝一次。&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，&lt;strong&gt;当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表&lt;/strong&gt;）。&lt;strong&gt;epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd&lt;/strong&gt;（利用schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步是类似的）。&lt;/p&gt;

    &lt;p&gt;对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;（1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。&lt;/p&gt;

    &lt;p&gt;（2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而&lt;strong&gt;epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次&lt;/strong&gt;（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Object类的方法&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://fangjian0423.github.io/2016/03/12/java-Object-method/&quot;&gt;https://fangjian0423.github.io/2016/03/12/java-Object-method/&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;getClass()&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;hashCode()&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;equals()&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;clone()&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;toString()&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;notify()&lt;/strong&gt;: 唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果所有的线程都在此对象上等待，那么只会选择一个线程。&lt;/li&gt;
      &lt;li&gt;notifyAll(): 跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;wait&lt;/strong&gt;(long timeout) throws InterruptedException: wait方法会让当前线程等待直到另外一个线程调用对象的notify或notifyAll方法，或者超过参数设置的timeout超时时间。&lt;/li&gt;
      &lt;li&gt;wait(long timeout, int nanos) throws InterruptedException: 跟wait(long timeout)方法类似，多了一个nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。&lt;/li&gt;
      &lt;li&gt;wait() throws InterruptedException: 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念。&lt;/li&gt;
      &lt;li&gt;finalize()的作用是实例被垃圾回收器回收的时候触发的操作，就好比 “死前的最后一波挣扎”。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;接口&lt;/strong&gt;和&lt;strong&gt;抽象类&lt;/strong&gt;的区别&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;方法在接口中不能有实现&lt;/strong&gt;，而抽象类可以有非抽象方法。&lt;/li&gt;
      &lt;li&gt;接口中除了static、final变量，不能有其他变量。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;一个类可以实现多个接口，但只能实现一个抽象类&lt;/strong&gt;。接口可以通过extends关键字扩展多个接口。&lt;/li&gt;
      &lt;li&gt;接口方法默认是public，抽象方法可以有public、protected、default（不能使用private）。&lt;/li&gt;
      &lt;li&gt;抽象类是对类的抽象，接口是对行为的抽象。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;面对对象语言的特点：&lt;strong&gt;封装&lt;/strong&gt;、&lt;strong&gt;继承&lt;/strong&gt;、&lt;strong&gt;多态&lt;/strong&gt;（指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用））（引用变量指向哪个类的实例对象，引用对象发出的方法调用哪个类中的实现的方法，在程序运行期间才能确定）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;JVM、JDK、JRE&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Java虚拟机(JVM)&lt;/strong&gt;实现&lt;strong&gt;平台无关性&lt;/strong&gt;，是运行&lt;strong&gt;Java字节码&lt;/strong&gt;（.class文件）的虚拟机。&lt;/li&gt;
      &lt;li&gt;.java源代码（通过JDK中的javac编译）.class字节码（通过JVM）机器码。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;JDK包括JRE&lt;/strong&gt;、javac、jdb等，能够创建和&lt;strong&gt;编译程序&lt;/strong&gt;；&lt;strong&gt;JRE&lt;/strong&gt;是&lt;strong&gt;Java运行环境&lt;/strong&gt;，用于运行已编译的Java程序，包括JVM等。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Java与C++的区别&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Java&lt;strong&gt;没有指针来直接访问内存&lt;/strong&gt;，访问内存更安全。&lt;/li&gt;
      &lt;li&gt;有&lt;strong&gt;自动内存管理机制&lt;/strong&gt;，不需要手动释放内存。&lt;/li&gt;
      &lt;li&gt;Java的类是&lt;strong&gt;单继承&lt;/strong&gt;的，接口可以多继承，C++支持多继承。&lt;/li&gt;
      &lt;li&gt;Java字符串没有\0，因为Java里&lt;strong&gt;一切都是对象&lt;/strong&gt;，可以确定长度。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Java的接口和C++的虚类的相同和不同处&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;由于Java不支持多继承，而有可能某个类或对象要使用分别在几个类或对象里面的方法或属性，现有的单继承机制就不能满足要求。&lt;/li&gt;
      &lt;li&gt;与继承相比，接口有更高的灵活性，因为接口中没有任何实现代码。当一个类实现了接口以后，该类要实现接口里面所有的方法和属性。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/chwshuang/article/details/46943711&quot;&gt;https://blog.csdn.net/chwshuang/article/details/46943711&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;C++虚类相当于java中的抽象类，一个子类只能继承一个抽象类（虚类），但能实现多个接口&lt;/li&gt;
      &lt;li&gt;一个抽象类可以有构造方法，接口没有构造方法&lt;/li&gt;
      &lt;li&gt;一个抽象类中的方法不一定是抽象方法，即其中的方法可以有实现（有方法体），接口中的方法都是抽象方法，不能有方法体，只有声明&lt;/li&gt;
      &lt;li&gt;一个抽象类可以是public、private、protected、default，接口只有public&lt;/li&gt;
      &lt;li&gt;一个抽象类中的方法可以是public、private、protected、default，接口中的方法只能是public和default&lt;/li&gt;
      &lt;li&gt;相同之处是：都不能实例化。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;构造器（private方法）&lt;/strong&gt;不能&lt;strong&gt;重写&lt;/strong&gt;（override），但是可以&lt;strong&gt;重载&lt;/strong&gt;（overload），一个类中可以有多个构造器。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;重写&lt;/strong&gt;（override）和&lt;strong&gt;重载&lt;/strong&gt;（overload）的区别&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;方法的重写和重载都是实现多态的方式，区别在于前者实现的是运行的多态性，而后者实现的是编译时的多态性。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，不能比父类被重写方法声明更多的异常（里氏代换原则）&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;重载是否区分返回值类型？重载不根据返回类型进行区分。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Overloaded的方法是否可以改变返回值的类型？&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/singit/article/details/47722047&quot;&gt;https://blog.csdn.net/singit/article/details/47722047&lt;/a&gt;&lt;/p&gt;
        &lt;/blockquote&gt;

        &lt;p&gt;这个题目很模糊。如果几个Overloaded的方法的参数列表不一样，它们的返回者类型当然也可以不一样。但我估计你想问的问题是：如果两个方法的参数列表完全一样，是否可以让它们的返回值不同来实现重载Overload。这是不行的。&lt;/p&gt;

        &lt;p&gt;我们可以用反证法来说明这个问题，因为我们有时候调用一个方法时也可以不定义返回结果变量，即不要关心其返回结果，例如，我们调用map.remove(key)方法时，虽然remove方法有返回值，但是我们通常都不会定义接收返回结果的变量，这时候假设该类中有两个名称和参数列表完全相同的方法，仅仅是返回类型不同，java就无法确定编程者倒底是想调用哪个方法了，因为它无法通过返回结果类型来判断。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;String、Stringbuffer、StringBuilder&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;String&lt;/strong&gt;类中使用&lt;strong&gt;final&lt;/strong&gt;关键字修饰字符数组来保存字符串，对象&lt;strong&gt;不可变&lt;/strong&gt;，&lt;strong&gt;线程安全&lt;/strong&gt;。&lt;/li&gt;
      &lt;li&gt;StringBuffer和StringBuilder构造方法调用父类AbstractStringBuffer实现，是&lt;strong&gt;可变&lt;/strong&gt;的。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;StringBuffer&lt;/strong&gt;对方法加了&lt;strong&gt;同步锁&lt;/strong&gt;，是&lt;strong&gt;线程安全&lt;/strong&gt;的；&lt;strong&gt;StringBuilder&lt;/strong&gt;没有加同步锁，非线程安全。&lt;/li&gt;
      &lt;li&gt;底层实现上的话，StringBuffer其实就是比StringBuilder多了Synchronized修饰符。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;装箱&lt;/strong&gt;：基本类型用对应的引用类型包装起来。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;拆箱&lt;/strong&gt;：包装类型转换为基本数据类型。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;静态方法内不能调用非静态成员，因为静态方法可以不通过对象进行调用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不做事且没有参数的构造方法的作用：子类中没有用super()方法来调用父类特定的构造方法，&lt;strong&gt;会调用父类中没有参数的构造方法&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;成员变量&lt;/strong&gt;和&lt;strong&gt;局部变量&lt;/strong&gt;的区别&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;成员变量属于类，局部变量是在方法中定义的变量或方法的参数；成员变量可以被public、private、static等修饰符修饰，局部变量不能被访问控制符及static所修饰；成员变量和局部变量都能被final修饰。&lt;/li&gt;
      &lt;li&gt;成员变量如果使用static修饰属于类，否则属于实例。对象存在堆中，局部变量存在栈中，&lt;strong&gt;静态变量存在方法区&lt;/strong&gt;。&lt;/li&gt;
      &lt;li&gt;成员变量是对象的一部分，随着对象的创建而存在；局部变量随着方法的调用而自动消失。&lt;/li&gt;
      &lt;li&gt;成员变量如果没有赋初值会自动赋默认值，局部变量不会自动赋值。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;构造方法&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;名字于类名相同。&lt;/li&gt;
      &lt;li&gt;没有返回值，不能用void声明构造函数。&lt;/li&gt;
      &lt;li&gt;生成类的对象时自动执行，无需调用。如果没有声明构造方法，会有默认的不带参数的构造函数。&lt;/li&gt;
      &lt;li&gt;作用时完成堆类对象的初始化工作。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;静态方法&lt;/strong&gt;和&lt;strong&gt;实例方法&lt;/strong&gt;的区别&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;在外部调用静态方法：类名.方法名、对象名.方法名；实例方法：对象名.方法名。&lt;/li&gt;
      &lt;li&gt;静态方法在访问本类成员时，只允许访问静态成员（静态成员变量、静态方法），不允许访问实例成员变量和实例方法。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为什么&lt;strong&gt;Java中只有值传递&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;例1&lt;/p&gt;

        &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
	&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;change&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;change&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// 将数组的第一个元素变为0&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;结果&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;1
0
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;解析：&lt;strong&gt;方法得到的是对象引用的拷贝，对象引用及对象引用的拷贝同时引用同一个对象&lt;/strong&gt;。&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/b7bad9506150c29bb8d7debd3905bd7a71cd6611/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d32372f333832353230342e6a7067&quot; alt=&quot;example 2&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;例2&lt;/p&gt;

        &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Test&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// TODO Auto-generated method stub&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;Student&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Student&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;小张&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;Student&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Student&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;小李&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;Test&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;s1:&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;s2:&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Student&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Student&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;Student&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;x:&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;y:&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;结果&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;x:小李
y:小张
s1:小张
s2:小李
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;解析&lt;/p&gt;

        &lt;p&gt;交换之前：&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/9d6dd0313695d309280675cd3251b47432a28814/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d32372f38383732393831382e6a7067&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

        &lt;p&gt;交换之后：&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/6bea9b0ed65609d699207ab787f631f7ba0a9246/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d32372f33343338343431342e6a7067&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

        &lt;p&gt;方法并没有改变存储在变量s1和s2中的对象引用。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;总结&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;Java中对对象采用的不是引用调用，对象引用是按值传递的&lt;/strong&gt;，因此一个方法不能让对象参数引用一个新的对象。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Java中的异常处理&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;异常类层次结构&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-2/Exception.png&quot; alt=&quot;Java异常类层次结构图&quot; /&gt;&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;Throwable类&lt;/strong&gt;分为两个子类：&lt;strong&gt;Exception（异常）&lt;/strong&gt;和&lt;strong&gt;Error（错误）&lt;/strong&gt;。&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;Error是程序无法处理的错误&lt;/strong&gt;。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;Exception是程序本身可以处理的异常&lt;/strong&gt;。Exception 类有一个重要的子类 &lt;strong&gt;RuntimeException&lt;/strong&gt;。RuntimeException 异常由Java虚拟机抛出。&lt;strong&gt;NullPointerException&lt;/strong&gt;（要访问的变量没有引用任何对象时，抛出该异常）、&lt;strong&gt;ArithmeticException&lt;/strong&gt;（算术运算异常，一个整数除以0时，抛出该异常）和 &lt;strong&gt;ArrayIndexOutOfBoundsException&lt;/strong&gt; （下标越界异常）。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;异常处理总结&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;try 块：&lt;/strong&gt; 用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;catch 块：&lt;/strong&gt; 用于处理try捕获到的异常。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;finally 块：&lt;/strong&gt; 无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return 语句时，finally语句块将在方法返回之前被执行。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 当try语句和finally语句中都有return语句时，在方法返回之前，finally语句的内容将被执行，并且finally语句的返回值将会覆盖原始的返回值。以下代码如果调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;f(2)&lt;/code&gt;，返回值将是0，因为finally语句的返回值覆盖了try语句块的返回值。&lt;/p&gt;

            &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;请说明JAVA语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;throw：用来明确地抛出一个“异常”。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;throws：标明一个成员函数可能抛出的各种“异常”。&lt;/li&gt;
          &lt;li&gt;可以在try里手动抛出异常，不过比较少见；也可以在try里嵌套try。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;transient关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复。transient只能修饰变量，不能修饰类和方法。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;获取用键盘输入的方法&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;通过 Scanner&lt;/p&gt;

        &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nc&quot;&gt;Scanner&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Scanner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;nextLine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;通过 BufferedReader&lt;/p&gt;

        &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nc&quot;&gt;BufferedReader&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BufferedReader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;InputStreamReader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt; 
&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;readLine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;static、final&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;final&lt;/strong&gt;关键字
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;对于一个final变量，如果是基本数据类型的变量，其数值在初始化后不能更改；如果是引用类型的变量，在对其初始化之后不能再让它指向另一个对象。&lt;/strong&gt;&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;用final修饰一个类时，表示这个类不能被继承。final类的所有成员方法都会被隐式指定final方法。&lt;/strong&gt;&lt;/li&gt;
          &lt;li&gt;使用final方法有两个原因。
            &lt;ul&gt;
              &lt;li&gt;把方法锁定，以防任何继承类修改它的含义。&lt;/li&gt;
              &lt;li&gt;效率。在早期的Java实现版本中，会将final方法转为内嵌调用。类中的所有private方法都隐式地指定为final。&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;static&lt;/strong&gt;关键字
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;修饰成员变量和成员方法:&lt;/strong&gt; 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，&lt;strong&gt;静态变量 存放在 Java 内存区域的方法区&lt;/strong&gt;。调用格式：&lt;code class=&quot;highlighter-rouge&quot;&gt;类名.静态变量名&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;类名.静态方法名()&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;静态代码块:&lt;/strong&gt; 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&amp;gt;非静态代码块—&amp;gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次.&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;静态内部类（static修饰类的话只能修饰内部类）：&lt;/strong&gt; 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;静态导包(用来导入类中的静态资源，1.5之后的新特性):&lt;/strong&gt; 格式为：&lt;code class=&quot;highlighter-rouge&quot;&gt;import static&lt;/code&gt; 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;深拷贝、浅拷贝&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;浅拷贝&lt;/strong&gt;：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;深拷贝&lt;/strong&gt;：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Java和PHP/JavaScript、Python的区别&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/20377398&quot;&gt;https://www.zhihu.com/question/20377398&lt;/a&gt;&lt;/p&gt;

      &lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/19913979&quot;&gt;https://www.zhihu.com/question/19913979&lt;/a&gt;&lt;/p&gt;

      &lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/19918532&quot;&gt;https://www.zhihu.com/question/19918532&lt;/a&gt;&lt;/p&gt;

      &lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/20491745&quot;&gt;https://www.zhihu.com/question/20491745&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Java 属于&lt;strong&gt;强类型&lt;/strong&gt;（所有程序都是well behaved），是&lt;strong&gt;静态类型&lt;/strong&gt;语言（在编译时拒绝ill behaved）。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;PHP/JavaScript属于弱类型（不需要定义变量的类型），是动态类型语言（在运行时拒绝ill behaved）。&lt;/li&gt;
      &lt;li&gt;PHP/JavaScript数组的功能强大，可以当作map和list来用。&lt;/li&gt;
      &lt;li&gt;PHP主要用于服务器端，JavaScript主要用于网页端。&lt;/li&gt;
      &lt;li&gt;Java和Python的区别是静态类型和动态类型，&lt;strong&gt;静态类型必须先声明再使用，动态则不需要声明&lt;/strong&gt;。&lt;/li&gt;
      &lt;li&gt;Python也是强类型。&lt;strong&gt;强弱类型不是指是否需要定义，而是是一旦类型决定了，是否能随便转换。&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如何跳出多重循环&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;loop and a half&lt;/li&gt;
      &lt;li&gt;break&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;内部类可以引用他包含类的成员吗，如果可以，有没有什么限制吗？&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;一个内部类对象可以访问创建它的外部类对象的内容。内部类如果不是static的，那么它可以访问创建它的外部类对象的所有属性内部类；如果是satic的，即为nested class，那么它只可以访问创建它的外部类对象的所有static属性&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;完全可以。如果不是静态内部类，那没有什么限制！
如果你把静态嵌套类当作内部类的一种特例，那在这种情况下不可以访问外部类的普通成员变量，而只能访问外部类中的静态成员。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Static Nested Class 和 Inner Class的不同&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/zzy7075/article/details/50378366&quot;&gt;https://blog.csdn.net/zzy7075/article/details/50378366&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;final, finally, finalize的区别&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。&lt;/li&gt;
      &lt;li&gt;finally是异常处理语句结构的一部分，表示总是执行。&lt;/li&gt;
      &lt;li&gt;finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;extends 和super 泛型限定符&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_40395278/article/details/88603655&quot;&gt;https://blog.csdn.net/qq_40395278/article/details/88603655&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;在java泛型中，&lt;strong&gt;？ 表示通配符，代表未知类型，&amp;lt; ? extends Object&amp;gt;表示上边界限定通配符，&amp;lt; ? super Object&amp;gt;表示下边界限定通配符。&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;通配符 与 T 的区别&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;T：作用于模板上，用于将数据类型进行参数化&lt;/strong&gt;，不能用于实例化对象。&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;?：在实例化对象的时候，不确定泛型参数的具体类型时，可以使用通配符进行对象定义。&lt;/strong&gt;&lt;/li&gt;
          &lt;li&gt;&amp;lt; T &amp;gt; 等同于 &amp;lt; T extends Object&amp;gt;&lt;/li&gt;
          &lt;li&gt;&amp;lt; ? &amp;gt; 等同于 &amp;lt; ? extends Object&amp;gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;例一：&lt;strong&gt;定义泛型类&lt;/strong&gt;，将key，value的数据类型进行&amp;lt; K, V &amp;gt;参数化，而不可以使用通配符。&lt;/p&gt;

        &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;K&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;例二：&lt;strong&gt;实例化泛型对象&lt;/strong&gt;，我们不能够确定eList存储的数据类型是Integer还是Long，因此我们使用List&amp;lt;? extends Number&amp;gt;定义变量的类型。&lt;/p&gt;

        &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;eList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;eList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;上界类型通配符（? extends）&lt;/p&gt;

        &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;eList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;();&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Number&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//语句1，正确&lt;/span&gt;
     
&lt;span class=&quot;c1&quot;&gt;//Type mismatch: cannot convert from capture#3-of ? extends Number to Integer&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;intObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//语句2，错误&lt;/span&gt;
     
&lt;span class=&quot;c1&quot;&gt;//The method add(capture#3-of ? extends Number) in the type List&amp;lt;capture#3-of ? extends Number&amp;gt; is not applicable for the arguments (Integer)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;eList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//语句3，错误&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;泛型&lt;/p&gt;

    &lt;p&gt;泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Query接口的list方法和iterate方法有什么区别？&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/questionTerminal/e0f929dfaf6e46e4900b538b9c2134ea?orderByHotValue=1&amp;amp;page=1&amp;amp;onlyReference=false&quot;&gt;https://www.nowcoder.com/questionTerminal/e0f929dfaf6e46e4900b538b9c2134ea?orderByHotValue=1&amp;amp;page=1&amp;amp;onlyReference=false&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;返回的类型不一样，list返回List，iterate返回iterator&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;查询策略不同。获取数据的方式不一样，list会直接查询数据库，iterate会先到数据库中把id取出来，然后真正要遍历某个对象的时候先到缓存中找，如果找不到，以id为条件再发一条sql到数据库，这样如果缓存中没有数据，则查询数据库的次数为n+1&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;iterate会查询2级缓存，list只会缓存，但不会使用缓存（除非结合查询缓存）。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;list中返回的list中每个对象都是原本的对象，iterate中返回的对象中仅包含了主键值&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;汉字能用char类型来表示吗，一个汉字占多少字节？&lt;/p&gt;

    &lt;p&gt;char固定占用2个字节，用来储存Unicode字符。范围在065536。unicode编码字符集中包含了汉字，所以，char型变量中可以存储汉字。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/kingcat/archive/2012/10/16/2726334.html&quot;&gt;https://www.cnblogs.com/kingcat/archive/2012/10/16/2726334.html&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;UTF-8 与UTF-16的区别&lt;/p&gt;

    &lt;p&gt;UTF-16比较好理解,就是任何字符对应的数字都用两个字节来保存.我们通常对Unicode的误解就是把Unicode与UTF-16等同了.但是很显然如果都是英文字母这做有点浪费.明明用一个字节能表示一个字符为啥整两个啊.&lt;/p&gt;

    &lt;p&gt;于是又有个UTF-8,这里的8非常容易误导人,8不是指一个字节,难道一个字节表示一个字符?实际上不是.当用UTF-8时表示一个字符是可变的,有可能是用一个字节表示一个字符,也可能是两个,三个.当然最多不能超过3个字节了.反正是根据字符对应的数字大小来确定.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一个方法被private和static修饰，能被override吗？为什么&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/orz024572/article/details/86027412&quot;&gt;https://blog.csdn.net/orz024572/article/details/86027412&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;不可以，&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;override：子类重写父类的方法（返回值，方法名，参数都相同）以实现多态。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;private只能够被自身类访问，子类不能访问private修饰的成员，所有不能override一个private方法&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;static方法是与类绑定的与任何实例都无关，随着类的加载而加载， static是编译时静态绑定的，override是运行时动态绑定的。形式上static可以override，但是实际上并不能被override。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;容器&quot;&gt;容器&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;List、Set、Map的区别&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;List：有序的多个对象。
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;Arraylist：&lt;/strong&gt; Object数组&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;Vector：&lt;/strong&gt; Object数组&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;LinkedList：&lt;/strong&gt; 双向链表&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Set：不允许重复的集合。
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;HashSet（无序，唯一）:&lt;/strong&gt; 基于 HashMap 实现的，底层采用 HashMap 来保存元素&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;LinkedHashSet：&lt;/strong&gt; LinkedHashSet 继承于 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 HashMap 实现一样，不过还是有一点点区别的&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;TreeSet（有序，唯一）：&lt;/strong&gt; 红黑树(自平衡的排序二叉树)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Map：使用键值对存储。&lt;/li&gt;
      &lt;li&gt;Set和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Array和ArrayList的区别&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。&lt;/li&gt;
      &lt;li&gt;Array大小是固定的，ArrayList的大小是动态变化的。&lt;/li&gt;
      &lt;li&gt;ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ArrayList和LinkedList的区别&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;都不保证线程安全。&lt;/li&gt;
      &lt;li&gt;底层数据结构：&lt;strong&gt;ArrayList底层使用的Object数组，LinkedList底层使用的是双向链表结构。&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;时间复杂度：ArrayList插入删除元素的时间复杂度为&lt;strong&gt;O(n)&lt;/strong&gt;，取第 i 元素的时间复杂度为&lt;strong&gt;O(1)&lt;/strong&gt;；LinkedList插入和删除的时间复杂度为&lt;strong&gt;O(1)&lt;/strong&gt;，如果是要在指定位置i插入和删除元素的话，时间复杂度近似为&lt;strong&gt;O(n)&lt;/strong&gt;因为需要先移动到指定位置再插入。&lt;/li&gt;
      &lt;li&gt;是否支持快速随机访问：LinkedList不支持高效的随机元素访问，而 ArrayList 支持。&lt;/li&gt;
      &lt;li&gt;内存空间占用： ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ArrayList和Vector的区别&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。&lt;/li&gt;
      &lt;li&gt;Arraylist不是同步的，所以在不需要保证线程安全时建议使用Arraylist。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Map的分类&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Map有4个实现类，HashMap、HashTable、LinkedHashMap、TreeMap。&lt;/li&gt;
      &lt;li&gt;Hashmap 是一个最常用的Map，它根据键的HashCode值存储数据,根据键可以直接获取它的值，具有&lt;strong&gt;很快的访问速度&lt;/strong&gt;，遍历时，取得数据的顺序是完全随机的。 &lt;strong&gt;HashMap最多只允许一条记录的键为Null；允许多条记录的值为 Null；HashMap不支持线程的同步&lt;/strong&gt;，即任一时刻可以有多个线程同时写HashMap；可能会导致数据的不一致。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Hashtable&lt;/strong&gt;与 HashMap类似，它继承自Dictionary类，不同的是：&lt;strong&gt;它不允许记录的键或者值为空；它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了 Hashtable在写入时会比较慢。&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;LinkedHashMap 是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排序。&lt;/li&gt;
      &lt;li&gt;TreeMap实现SortMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。&lt;/li&gt;
      &lt;li&gt;一般情况下，我们用的最多的是HashJDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）Map，在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按&lt;strong&gt;自然顺序&lt;/strong&gt;或自定义顺序遍历键，那么&lt;strong&gt;TreeMap&lt;/strong&gt;会更好。如果需要&lt;strong&gt;输出的顺序和输入的相同&lt;/strong&gt;，那么用&lt;strong&gt;LinkedHashMap&lt;/strong&gt;可以实现,它还可以按读取顺序来排列.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HashMap源码学习&lt;/p&gt;

    &lt;p&gt;JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间。&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;putVal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;putVal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;K&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;onlyIfAbsent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                  &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;evict&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// table未初始化或者长度为0，进行扩容&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// (n - 1) &amp;amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 桶中已经存在元素&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;K&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))))&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// 将第一个元素赋值给e，用e来记录&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// hash值不相等，即key不相等；为红黑树结点&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 放入树中&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;putTreeVal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 为链表结点&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 在链表最末插入结点&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;binCount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;binCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// 到达链表的尾部&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;// 在尾部插入新结点&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;// 结点数量达到阈值，转化为红黑树&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;binCount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;TREEIFY_THRESHOLD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// -1 for 1st&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;treeifyBin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;// 跳出循环&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// 判断链表中结点的key值与插入的元素的key值是否相等&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))))&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;// 相等，跳出循环&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 表示在桶中找到key值、hash值与插入元素相等的结点&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
            &lt;span class=&quot;c1&quot;&gt;// 记录e的value&lt;/span&gt;
            &lt;span class=&quot;no&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// onlyIfAbsent为false或者旧值为null&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onlyIfAbsent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;//用新值替换旧值&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 访问后回调&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;afterNodeAccess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 返回旧值&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 结构性修改&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;modCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 实际大小大于阈值则扩容&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threshold&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;resize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 插入后回调&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;afterNodeInsertion&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;evict&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;K&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 数组元素相等&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// always check first node&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))))&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 桶中不止一个节点&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 在树中get&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getTreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 在链表中get&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))))&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;[]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;resize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldTab&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldCap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;oldTab&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldTab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldThr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threshold&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newCap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newThr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;oldCap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 超过最大值就不再扩充了，就只好随你碰撞去吧&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;oldCap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;MAXIMUM_CAPACITY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;threshold&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;MAX_VALUE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldTab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 没超过最大值，就扩充为原来的2倍&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newCap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldCap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;MAXIMUM_CAPACITY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldCap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;DEFAULT_INITIAL_CAPACITY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;newThr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldThr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// double threshold&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;oldThr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// initial capacity was placed in threshold&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;newCap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldThr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
        &lt;span class=&quot;c1&quot;&gt;// signifies using defaults&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;newCap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;DEFAULT_INITIAL_CAPACITY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;newThr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;DEFAULT_LOAD_FACTOR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;DEFAULT_INITIAL_CAPACITY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 计算新的resize上限&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newThr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ft&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newCap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loadFactor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;newThr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newCap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;MAXIMUM_CAPACITY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ft&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;MAXIMUM_CAPACITY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ft&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;MAX_VALUE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;threshold&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newThr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@SuppressWarnings&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;rawtypes&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;unchecked&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;})&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newTab&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;[])&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newCap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newTab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;oldTab&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 把每个bucket都移动到新的buckets中&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldCap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldTab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;oldTab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;newTab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newCap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newTab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldCap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
                    &lt;span class=&quot;nc&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loHead&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loTail&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;nc&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hiHead&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hiTail&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;nc&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                        &lt;span class=&quot;c1&quot;&gt;// 原索引&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldCap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loTail&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                                &lt;span class=&quot;n&quot;&gt;loHead&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                            &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
                                &lt;span class=&quot;n&quot;&gt;loTail&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                            &lt;span class=&quot;n&quot;&gt;loTail&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                        &lt;span class=&quot;c1&quot;&gt;// 原索引+oldCap&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hiTail&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                                &lt;span class=&quot;n&quot;&gt;hiHead&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                            &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
                                &lt;span class=&quot;n&quot;&gt;hiTail&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                            &lt;span class=&quot;n&quot;&gt;hiTail&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;// 原索引放到bucket里&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loTail&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;loTail&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;newTab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loHead&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;// 原索引+oldCap放到bucket里&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hiTail&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;hiTail&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;newTab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldCap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hiHead&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newTab&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HashMap的容量为什么是2的n次幂？&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/sybnfkn040601/article/details/73194613&quot;&gt;https://blog.csdn.net/sybnfkn040601/article/details/73194613&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;用&lt;code class=&quot;highlighter-rouge&quot;&gt;h &amp;amp; (length - 1)&lt;/code&gt;取代&lt;code class=&quot;highlighter-rouge&quot;&gt; h % length&lt;/code&gt;，位运算取低位速度快。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;hashmap hash算法的具体实现，巧妙之处&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;hashmap规定长度必定为2的n次方、如果指定的capacity不为2的n次方，会将其转换为&amp;gt;capacity的最小的2的次方数&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;hash算法 hash = h ^ (h »&amp;gt; 16)，保证了capacity较小时，能够将高16位和低16位的变化都反应到低位上，在计算下标时，高位和地位同时参与，使hash更加均匀分散，降低hash碰撞的概率&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;put的时候会put到table[(n-1)&amp;amp;hash]，因为n为2的n次方，所以n-1导致低位全是1，便可以保证hash与上n-1得到的数组下标一定在0~n-1之间&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;get的时候依然是直接用table[(n-1)&amp;amp;hash]&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// key.hashCode()：返回散列值也就是hashcode&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ^ ：按位异或&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// &amp;gt;&amp;gt;&amp;gt;:无符号右移，忽略符号位，空位都以0补齐&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hashCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;hashmap扩容resize怎么实现&lt;/p&gt;

    &lt;p&gt;1、首先建立新数组newTable、为原数组的两倍&lt;/p&gt;

    &lt;p&gt;2、将原数组hash到新数组中，hash &amp;amp; (newLength-1) ，&lt;/p&gt;

    &lt;p&gt;3、如果原数组节点只有一个头节点，则hash到新数组直接放入&lt;/p&gt;

    &lt;p&gt;4、如果原数组e是树节点，则将其split（保持顺序分裂成两个树节点TreeNode list、list过长则转化成树，不然则彻底转成node list）&lt;/p&gt;

    &lt;p&gt;5、如果是链表，则保持原数组中链表的顺序，hash到新数组中&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000015812438?utm_source=tag-newest&quot;&gt;https://segmentfault.com/a/1190000015812438?utm_source=tag-newest&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;hashmap扩容时每个entry需要再计算一次hash吗？&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_27093465/article/details/52270519&quot;&gt;https://blog.csdn.net/qq_27093465/article/details/52270519&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;还是原来的hash，&lt;code class=&quot;highlighter-rouge&quot;&gt;hash &amp;amp; oldCap&lt;/code&gt;如果是0的话就是原索引，否则是原索引+oldCap&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;jdk1.8之前并发操作hashmap时为什么会有死循环的问题&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5a66a08d5188253dc3321da0&quot;&gt;https://juejin.im/post/5a66a08d5188253dc3321da0&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;在并发的情况，发生扩容时，可能会产生循环链表，在执行get的时候，会触发死循环，引起CPU的100%问题，所以一定要避免在并发环境下使用HashMap。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/wthfeng/article/details/88972137&quot;&gt;https://blog.csdn.net/wthfeng/article/details/88972137&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;Java 8虽然修复了死循环的BUG，但是HashMap 还是非线程安全类，仍然会产生数据丢失等问题。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;hashmap一个写，多个读并发会有线程安全问题吗，引申出fail-fast和iterator&lt;/p&gt;

    &lt;p&gt;1、会导致数据读写不一致的问题、因为JMM(java内存模型)里线程只能先与自己的工作内存交互，之后才能与共享内存交互&lt;/p&gt;

    &lt;p&gt;2、会导致fail-fast问题（这是java集合的一个错误检测机制）&lt;/p&gt;

    &lt;p&gt;fail-fast：如果在集合迭代的过程中，iterator（迭代器）不知道集合发生了修改（add/remove）操作，就会报错&lt;/p&gt;

    &lt;p&gt;如何实现遍历集合的同时进行修改：让iterator知道，即用iterator自带的remove方法：iterator.remove();&lt;/p&gt;

    &lt;p&gt;modCount是集合通用的属性，只要集合发生了修改操作，modCount就会++，在获取迭代器的时候会将modCount赋值给ExpectedModCount，此时两者肯定相等，但是如果执行了修改操作，modCound就会++，两者不等，就会报错。&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;场景1：写线程唯一、读线程不确定，没有迭代操作。使用hashmap不会存在程序不安全，最多就是发生数据不一致性的问题。&lt;/li&gt;
      &lt;li&gt;场景2：写线程唯一、读线程不确定，有迭代操作，此时不能使用hashmap，会存在fastfail问题&lt;/li&gt;
      &lt;li&gt;场景3: 读写线程是同一个，且唯一，有迭代操作，此时注意不能通过集合方法remove或者add更改，只能通过iterator内方法来更新。不然会存在fastfail问题。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;==&lt;/strong&gt;和&lt;strong&gt;equals()&lt;/strong&gt;的区别&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;==：判断两个对象的地址是不是相等。&lt;/li&gt;
      &lt;li&gt;equals()
        &lt;ul&gt;
          &lt;li&gt;情况1：类没有覆盖equals()方法时，等价于==。&lt;/li&gt;
          &lt;li&gt;情况2：覆盖类equals()方法，来比较两个对象的内容是否相等。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;hashCode()&lt;/strong&gt;和&lt;strong&gt;equals()&lt;/strong&gt;的区别&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;hashCode()的作用：获取散列码，实际上是一个int整数。&lt;/li&gt;
      &lt;li&gt;为什么要有散列码？以“HashSet”如何检查重复为例：&lt;strong&gt;当把对象加入HashSet时，HashSet会先计算散列码，如果没有相符的散列码，HashSet会假设对象没有重复出现，如果发现有相同散列码的对象，会调用equals()方法来检查对象是否真的相同。如果两者相同，HashSet就不会让它加入，否则就会重新散列到其他位置。这样就大大减少equals()的次数，提高执行速度。&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;相关规定
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;如果两个对象相等，则散列码相同。&lt;/strong&gt;&lt;/li&gt;
          &lt;li&gt;如果两个对象相等，则两个对象分别调用equals()方法都返回true。&lt;/li&gt;
          &lt;li&gt;两个对象有相同的散列码，它们也不一定是相等的。&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;equals()方法被覆盖过，则hashCode()方法也必须被覆盖&lt;/strong&gt;。&lt;/li&gt;
          &lt;li&gt;hashCode()的默认行为是对堆上的对象产生独特值，如果没有重写hashcode()，则同一个类的两个对象无论如何不会相等。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重写equals()是否需要重写hashcode()，不重写会有什么后果&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/xyh269/article/details/69171545&quot;&gt;https://blog.csdn.net/xyh269/article/details/69171545&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;需要，不重写有可能两个对象相等但是hashcode不相等，HashMap中存在重复的键。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HashMap的key可以是可变的对象吗&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/0201zcr/p/4810813.html&quot;&gt;https://www.cnblogs.com/0201zcr/p/4810813.html&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;运行时可能会出现找不到key的问题。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果hashMap的key是一个自定义的类，怎么办？&lt;/p&gt;

    &lt;p&gt;使用HashMap，如果key是自定义的类，就必须重写hashcode()和equals()。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;覆盖equals时请遵守通用约定&lt;/p&gt;

    &lt;p&gt;实现高质量equals方法的诀窍：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;使用==操作符检查“参数是否为这个对象的引用”&lt;/li&gt;
      &lt;li&gt;使用instanceof操作符检查“参数是否为正确的类型”&lt;/li&gt;
      &lt;li&gt;把参数转换成正确的类型&lt;/li&gt;
      &lt;li&gt;对于该类中的每个“关键”域，检查参数中的域是否域该对象中对应的域相匹配（域的比较顺序可能会影响到equals方法的性能。为了获得最佳的性能，应该先比较最优可能不一致的域，或者是开销最低的域）&lt;/li&gt;
      &lt;li&gt;当你完成了equals方法之后，应该问自己三个问题：它是否是对称的、传递的、一致的？（&lt;strong&gt;自反性、对称性、传递性、一致性、非空性&lt;/strong&gt;）&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;告诫：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;覆盖equals时总要覆盖hashCode&lt;/li&gt;
      &lt;li&gt;不要将equals声明中的Object对象替换为其他的类型&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;覆盖equals时总要覆盖hashCode&lt;/p&gt;

    &lt;p&gt;如果equals时不覆盖hashCode：equals时hashCode不同，散列到不同的散列桶中找不到key&lt;/p&gt;

    &lt;p&gt;简单的解决方法：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;把某个非零的常数值，比如17，保存在一个名为result的int类型的变量中。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;对于对象中每个关键域f（指equals方法中涉及的每个域），完成以下步骤：&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;a. 为该域计算int类型的散列码c：&lt;/p&gt;

    &lt;p&gt;i.boolean类型: &lt;code class=&quot;highlighter-rouge&quot;&gt;f?1:0&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;ii.byte, char, short, int: &lt;code class=&quot;highlighter-rouge&quot;&gt;(int)f&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;iii. long: &lt;code class=&quot;highlighter-rouge&quot;&gt;(int)(f^(f&amp;gt;&amp;gt;&amp;gt;32))&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;iv. float: &lt;code class=&quot;highlighter-rouge&quot;&gt;Float.floatToIntBits(f)&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;v. double: &lt;code class=&quot;highlighter-rouge&quot;&gt;Double.doubleToLongBits(f)&lt;/code&gt;，然后按照步骤2.a.iii为得到的long类型值计算散列值&lt;/p&gt;

    &lt;p&gt;vi. 对象引用：递归调用hashCode&lt;/p&gt;

    &lt;p&gt;vii. 数组：把每一个元素当作单独的域来处理&lt;/p&gt;

    &lt;p&gt;b. 按照公式把步骤2.a中计算得到的散列码c合并到result中：&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;result=31*result+c&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;注意：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;如果一个类是不可变的，并且计算散列码的开销也比较大，就应该开率把散列码缓存在对象内部。&lt;/li&gt;
      &lt;li&gt;不要试图从散列码计算中排除掉一个对象的关键部分来提高性能。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TreeMap的底层实现&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;TreeMap 的实现就是红黑树数据结构，也就说是一棵自平衡的排序二叉树，这样就可以保证当需要快速检索指定节点。&lt;/p&gt;

        &lt;p&gt;红黑树的插入、删除、遍历时间复杂度都为O(lgN)，所以性能上低于哈希表。但是哈希表无法提供键值对的有序输出，红黑树因为是排序插入的，可以按照键的值的大小有序输出。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;红黑树性质：&lt;/p&gt;

        &lt;p&gt;性质1：每个节点要么是红色，要么是黑色。&lt;/p&gt;

        &lt;p&gt;性质2：根节点永远是黑色的。&lt;/p&gt;

        &lt;p&gt;性质3：所有的叶节点都是空节点（即 null），并且是黑色的。&lt;/p&gt;

        &lt;p&gt;性质4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点）&lt;/p&gt;

        &lt;p&gt;性质5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;红黑树和平衡二叉树的区别、java中哪种数据结构实现了红黑树&lt;/p&gt;

    &lt;p&gt;BST：二叉搜索树、不确保平衡、性能无法确保&lt;/p&gt;

    &lt;p&gt;AVL：平衡二叉树，&lt;strong&gt;严格平衡（每个节点的左右子树的高度差不超过1）&lt;/strong&gt;，搜索性能可以一直确保最佳，但是一旦有插入删除操作，就必须
要进行旋转，来维持树的严格平衡，而旋转操作是非常耗时的。所以AVL使用于搜索操作多，而插入删除操作少的场景&lt;/p&gt;

    &lt;p&gt;RBT：红黑树，&lt;strong&gt;弱平衡（红黑树确保没有一条路径会比其他路径长出两倍）&lt;/strong&gt;，这样子的话一旦有插入删除操作，用于维持RBT规则的旋转操作次数就会很少。用非严格的平衡来换取增删节点时候旋转次数的降低。所以RBT适用于插入删除操作多的场景&lt;/p&gt;

    &lt;p&gt;所以简单说，搜索的次数远远大于插入和删除，那么选择AVL树，如果搜索，插入删除次数几乎差不多，应该选择RB树&lt;/p&gt;

    &lt;p&gt;java的TreeMap实现了红黑树&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ArrayList如何扩容和缩容&lt;/p&gt;

    &lt;p&gt;1、扩容：直接是采用底层的System.copyOf()，创建一个新的大数组，将原来的数组内容copy到新数组中，然后返回新数组的引用&lt;/p&gt;

    &lt;p&gt;2、缩容：trimToSize()。如果实际size&amp;lt;数组长度，在内存紧张的情况下，会将数组缩小，采用的依然是System.copyOf()&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如何用LinkedHashMap实现LRU？&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/d76a78086c3a&quot;&gt;https://www.jianshu.com/p/d76a78086c3a&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;LinkedHashMap重写removeEldestEntry()方法，当前size()大于了cacheSize便删掉头部的元素&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如何用TreeMap实现一致性hash？&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;什么是一致性hash&lt;/p&gt;

      &lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34985026&quot;&gt;https://zhuanlan.zhihu.com/p/34985026&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;p&gt;自己实现一个一致性 Hash 算法&lt;/p&gt;

      &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5abf8f3851882555731c42d1&quot;&gt;https://juejin.im/post/5abf8f3851882555731c42d1&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;内部没有使用数组，而是使用了有序 Map。&lt;/li&gt;
      &lt;li&gt;put 方法中，对象如果没有落到缓存节点上，就找比他小的节点且离他最近的。这里我们使用了 TreeMap 的 tailMap 方法，具体 API 可以看文档。&lt;/li&gt;
      &lt;li&gt;get 方法中，和 put 步骤相同，否则是取不到对象的。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HashMap和HashSet的区别&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;HashSet 底层就是基于 HashMap 实现的。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;thead&gt;
            &lt;tr&gt;
              &lt;th&gt;HashMap&lt;/th&gt;
              &lt;th&gt;HashSet&lt;/th&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;实现了Map接口&lt;/td&gt;
              &lt;td&gt;实现Set接口&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;存储键值对&lt;/td&gt;
              &lt;td&gt;仅存储对象&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;put()&lt;/code&gt;向map中添加元素&lt;/td&gt;
              &lt;td&gt;调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;add()&lt;/code&gt;方法向Set中添加元素&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;HashMap使用键（Key）计算Hashcode&lt;/td&gt;
              &lt;td&gt;HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;java8&quot;&gt;Java8&lt;/h2&gt;

&lt;p&gt;lambda表达式、方法引用、stream、optional、接口中的默认方法、函数式接口&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://snailclimb.gitee.io/javaguide/#/docs/java/What's%20New%20in%20JDK8/Java8Tutorial&quot;&gt;https://snailclimb.gitee.io/javaguide/#/docs/java/What’s%20New%20in%20JDK8/Java8Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://github.com/wizardforcel/modern-java-zh&quot;&gt;https://github.com/wizardforcel/modern-java-zh&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Lambda 表达式：Lambda允许把函数作为一个方法的参数&lt;/li&gt;
  &lt;li&gt;方法和构造函数引用&lt;/li&gt;
  &lt;li&gt;接口的默认方法&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;函数式接口，内置函数式接口（Predicate, Function, Supplier, Consumer, Comparator）&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Stream&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://www.runoob.com/java/java8-new-features.html&quot;&gt;https://www.runoob.com/java/java8-new-features.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Java8 新增了非常多的特性，我们主要讨论以下几个：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Lambda 表达式 − Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方法引用 − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;默认方法 − 默认方法就是一个在接口里面有了一个实现的方法。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;新工具 − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Stream API −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Date Time API − 加强对日期与时间的处理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。&lt;/p&gt;
</description>
        <pubDate>Thu, 05 Mar 2020 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/03/05/java/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/03/05/java/</guid>
        
        <category>学习</category>
        
        
      </item>
    
      <item>
        <title>面试</title>
        <description>&lt;h4 id=&quot;项目介绍&quot;&gt;项目介绍&lt;/h4&gt;

&lt;p&gt;我负责智能执法平台里用户授权的工作，从用户查询到他所拥有的权限，开发接口管理用户角色、角色、权限的增删改查，和它们之间的多对多关系的增删改查。另外我还负责法规的检索和推荐的工作。&lt;/p&gt;

&lt;h4 id=&quot;项目的问题&quot;&gt;项目的问题&lt;/h4&gt;

&lt;p&gt;解决检索项目在服务器不能正常运行的问题&lt;/p&gt;

&lt;p&gt;(1) 页面的搜索结果不能正常显示，但是后台并没有报错。&lt;/p&gt;

&lt;p&gt;(2) 直接运行flask项目中的入口python文件没有问题，用uwsgi将配置文件中的3行多线程相关的内容注释掉也可以正常运行。&lt;/p&gt;

&lt;p&gt;(3) 定位发现是调用HanLP的函数过程中线程会卡住。原因是利用python的jpype调用Hanlp的java源代码时，不能为新开启的线程分配JVM。解决方法是在每个API的开头添加两行代码，判断并为线程分配JVM。&lt;/p&gt;

&lt;h4 id=&quot;项目怎么优化&quot;&gt;项目怎么优化&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://tieba.baidu.com/p/6239499571?red_tag=0442800574&amp;amp;traceid=&quot;&gt;https://tieba.baidu.com/p/6239499571?red_tag=0442800574&amp;amp;traceid=&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;redis缓存，异步，接口调优，SQL调优，调用超时&lt;/p&gt;

&lt;p&gt;可以说一下分布式方面的改进吧，什么集群，数据库主从分离等等&lt;/p&gt;

&lt;h4 id=&quot;反问&quot;&gt;反问&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/19640623?isn=1&quot;&gt;https://www.zhihu.com/question/19640623?isn=1&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;您详细能告诉我我如果被录用了，我会负责一些工作么？&lt;/li&gt;
  &lt;li&gt;我会接受什么样的培训呢？&lt;/li&gt;
  &lt;li&gt;您觉得胜任这个职位的人什么品质最重要？&lt;/li&gt;
  &lt;li&gt;您觉得贵公司未来五年的发展方向是什么？&lt;/li&gt;
  &lt;li&gt;您能告诉我您为什么喜欢在这工作么？&lt;/li&gt;
  &lt;li&gt;您能形容一下这里的工作氛围么？&lt;/li&gt;
  &lt;li&gt;能告诉我现在公司/所处部门面临最大机遇(或挑战)是什么吗？&lt;/li&gt;
  &lt;li&gt;这个职位的发展路径一般是怎么样的呢？&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;面经&quot;&gt;面经&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;牛客&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/discuss/356120&quot;&gt;https://www.nowcoder.com/discuss/356120&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;&lt;strong&gt;集合&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;ArrayList与LinkedList的实现和区别&lt;/li&gt;
      &lt;li&gt;HashMap：了解其数据结构、hash冲突如何解决（链表和红黑树）、扩容时机、扩容时避免rehash的优化&lt;/li&gt;
      &lt;li&gt;LinkedHashMap：了解基本原理、哪两种有序、如何用它实现LRU&lt;/li&gt;
      &lt;li&gt;TreeMap：了解数据结构、了解其key对象为什么必须要实现Compare接口、如何用它实现一致性哈希&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;常见问题&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;hashmap如何解决hash冲突，为什么hashmap中的链表需要转成红黑树？&lt;/li&gt;
      &lt;li&gt;hashmap什么时候会触发扩容？&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;jdk1.8之前并发操作hashmap时为什么会有死循环的问题？&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;hashmap扩容时每个entry需要再计算一次hash吗？&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;hashmap的数组长度为什么要保证是2的幂？&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;如何用LinkedHashMap实现LRU？&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;如何用TreeMap实现一致性hash？&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;strong&gt;线程安全的集合&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Collections.synchronized：了解其实现原理&lt;/li&gt;
      &lt;li&gt;CopyOnWriteArrayList：了解写时复制机制、了解其适用场景、思考为什么没有ConcurrentArrayList&lt;/li&gt;
      &lt;li&gt;ConcurrentHashMap：了解实现原理、扩容时做的优化、与HashTable对比。&lt;/li&gt;
      &lt;li&gt;BlockingQueue：了解LinkedBlockingQueue、ArrayBlockingQueue、DelayQueue、SynchronousQueue&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;常见问题&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;ConcurrentHashMap是如何在保证并发安全的同时提高性能？&lt;/li&gt;
      &lt;li&gt;ConcurrentHashMap是如何让多线程同时参与扩容？&lt;/li&gt;
      &lt;li&gt;LinkedBlockingQueue、DelayQueue是如何实现的？&lt;/li&gt;
      &lt;li&gt;CopyOnWriteArrayList是如何保证线程安全的？&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;strong&gt;I/O&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;了解BIO和NIO的区别、了解多路复用机制&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;常见问题&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;同步阻塞、同步非阻塞、异步的区别？&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;select、poll、eopll的区别？&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;java NIO与BIO的区别？&lt;/li&gt;
      &lt;li&gt;reactor线程模型是什么?&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;strong&gt;并发&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;synchronized：了解偏向锁、轻量级锁、重量级锁的概念以及升级机制、以及和ReentrantLock的区别&lt;/li&gt;
      &lt;li&gt;CAS：了解AtomicInteger实现原理、CAS适用场景、如何实现乐观锁&lt;/li&gt;
      &lt;li&gt;AQS：了解AQS内部实现、及依靠AQS的同步类比如ReentrantLock、Semaphore、CountDownLatch、CyclicBarrier等的实现&lt;/li&gt;
      &lt;li&gt;ThreadLocal：了解ThreadLocal使用场景和内部实现&lt;/li&gt;
      &lt;li&gt;ThreadPoolExecutor：了解线程池的工作原理以及几个重要参数的设置&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;常见问题&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;synchronized与ReentrantLock的区别？&lt;/li&gt;
      &lt;li&gt;乐观锁和悲观锁的区别？&lt;/li&gt;
      &lt;li&gt;如何实现一个乐观锁？&lt;/li&gt;
      &lt;li&gt;AQS是如何唤醒下一个线程的？&lt;/li&gt;
      &lt;li&gt;ReentrantLock如何实现公平和非公平锁是如何实现？&lt;/li&gt;
      &lt;li&gt;CountDownLatch和CyclicBarrier的区别？各自适用于什么场景？&lt;/li&gt;
      &lt;li&gt;适用ThreadLocal时要注意什么？比如说内存泄漏?&lt;/li&gt;
      &lt;li&gt;说一说往线程池里提交一个任务会发生什么？&lt;/li&gt;
      &lt;li&gt;线程池的几个参数如何设置？&lt;/li&gt;
      &lt;li&gt;线程池的非核心线程什么时候会被释放？&lt;/li&gt;
      &lt;li&gt;如何排查死锁？&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;strong&gt;JVM&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;GC：垃圾回收基本原理、几种常见的垃圾回收器的特性、重点了解CMS（或G1）以及一些重要的参数&lt;/li&gt;
      &lt;li&gt;内存区域：能说清jvm的内存划分&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;常见问题&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;CMS GC回收分为哪几个阶段？分别做了什么事情？&lt;/li&gt;
      &lt;li&gt;CMS有哪些重要参数？&lt;/li&gt;
      &lt;li&gt;Concurrent Model Failure和ParNew promotion failed什么情况下会发生？&lt;/li&gt;
      &lt;li&gt;CMS的优缺点？&lt;/li&gt;
      &lt;li&gt;有做过哪些GC调优？&lt;/li&gt;
      &lt;li&gt;为什么要划分成年轻代和老年代？&lt;/li&gt;
      &lt;li&gt;年轻代为什么被划分成eden、survivor区域？&lt;/li&gt;
      &lt;li&gt;年轻代为什么采用的是复制算法？&lt;/li&gt;
      &lt;li&gt;老年代为什么采用的是标记清除、标记整理算法&lt;/li&gt;
      &lt;li&gt;什么情况下使用堆外内存？要注意些什么？&lt;/li&gt;
      &lt;li&gt;堆外内存如何被回收？&lt;/li&gt;
      &lt;li&gt;jvm内存区域划分是怎样的？&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;strong&gt;Mysql&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;事务隔离级别、锁、索引的数据结构、聚簇索引和非聚簇索引、最左匹配原则、查询优化（explain等命令）&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;常见问题&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Mysql(innondb 下同) 有哪几种事务隔离级别？&lt;/li&gt;
      &lt;li&gt;不同事务隔离级别分别会加哪些锁？&lt;/li&gt;
      &lt;li&gt;mysql的行锁、表锁、间隙锁、意向锁分别是做什么的？&lt;/li&gt;
      &lt;li&gt;说说什么是最左匹配？&lt;/li&gt;
      &lt;li&gt;如何优化慢查询？&lt;/li&gt;
      &lt;li&gt;mysql索引为什么用的是b+ tree而不是b tree、红黑树&lt;/li&gt;
      &lt;li&gt;分库分表如何选择分表键&lt;/li&gt;
      &lt;li&gt;分库分表的情况下，查询时一般是如何做排序的？&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;strong&gt;Redis（或其他缓存系统）&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;redis工作模型、redis持久化、redis过期淘汰机制、redis分布式集群的常见形式、分布式锁、缓存击穿、缓存雪崩、缓存一致性问题&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;常见问题&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;redis性能为什么高?&lt;/li&gt;
      &lt;li&gt;单线程的redis如何利用多核cpu机器？&lt;/li&gt;
      &lt;li&gt;redis的缓存淘汰策略？&lt;/li&gt;
      &lt;li&gt;redis如何持久化数据？&lt;/li&gt;
      &lt;li&gt;redis有哪几种数据结构？&lt;/li&gt;
      &lt;li&gt;redis集群有哪几种形式？&lt;/li&gt;
      &lt;li&gt;有海量key和value都比较小的数据，在redis中如何存储才更省内存？&lt;/li&gt;
      &lt;li&gt;如何保证redis和DB中的数据一致性？&lt;/li&gt;
      &lt;li&gt;如何解决缓存穿透和缓存雪崩？&lt;/li&gt;
      &lt;li&gt;如何用redis实现分布式锁？&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;strong&gt;中间件、存储、以及其他框架&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Spring：bean的生命周期、循环依赖问题、spring cloud（如项目中有用过）、AOP的实现、spring事务传播&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;java动态&lt;strong&gt;&lt;em&gt;和cglib动态&lt;/em&gt;&lt;/strong&gt;的区别（经常结合spring一起问所以就放这里了）&lt;/li&gt;
      &lt;li&gt;spring中bean的生命周期是怎样的？&lt;/li&gt;
      &lt;li&gt;属性注入和构造器注入哪种会有循环依赖的问题？&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/discuss/368408?type=2&amp;amp;order=4&amp;amp;pos=5&amp;amp;page=1&quot;&gt;https://www.nowcoder.com/discuss/368408?type=2&amp;amp;order=4&amp;amp;pos=5&amp;amp;page=1&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;&lt;strong&gt;ZooKeeper&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;CAP定理&lt;/li&gt;
      &lt;li&gt;ZAB协议&lt;/li&gt;
      &lt;li&gt;leader选举算法和流程&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;strong&gt;Redis&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Redis的应用场景&lt;/li&gt;
      &lt;li&gt;Redis支持的数据类型（必考）&lt;/li&gt;
      &lt;li&gt;zset跳表的数据结构（必考）&lt;/li&gt;
      &lt;li&gt;Redis的数据过期策略（必考）&lt;/li&gt;
      &lt;li&gt;Redis的LRU过期策略的具体实现&lt;/li&gt;
      &lt;li&gt;如何解决Redis缓存雪崩，缓存穿透问题&lt;/li&gt;
      &lt;li&gt;Redis的持久化机制（必考）&lt;/li&gt;
      &lt;li&gt;Redis的管道pipeline&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;strong&gt;Mysql&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;事务的基本要素&lt;/li&gt;
      &lt;li&gt;事务隔离级别（必考）&lt;/li&gt;
      &lt;li&gt;如何解决事务的并发问题(脏读，幻读)（必考）&lt;/li&gt;
      &lt;li&gt;MVCC多版本并发控制（必考）&lt;/li&gt;
      &lt;li&gt;binlog,redolog,undolog都是什么，起什么作用&lt;/li&gt;
      &lt;li&gt;InnoDB的行锁/表锁&lt;/li&gt;
      &lt;li&gt;myisam和innodb的区别，什么时候选择myisam&lt;/li&gt;
      &lt;li&gt;为什么选择B+树作为索引结构（必考）&lt;/li&gt;
      &lt;li&gt;索引B+树的叶子节点都可以存哪些东西（必考）&lt;/li&gt;
      &lt;li&gt;查询在什么时候不走（预期中的）索引（必考）&lt;/li&gt;
      &lt;li&gt;sql如何优化&lt;/li&gt;
      &lt;li&gt;explain是如何解析sql的&lt;/li&gt;
      &lt;li&gt;order by原理&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;strong&gt;JVM&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;运行时数据区域（内存模型）（必考）&lt;/li&gt;
      &lt;li&gt;垃圾回收机制（必考）&lt;/li&gt;
      &lt;li&gt;垃圾回收算法（必考）&lt;/li&gt;
      &lt;li&gt;Minor GC和Full GC触发条件&lt;/li&gt;
      &lt;li&gt;GC中Stop the world（STW）&lt;/li&gt;
      &lt;li&gt;各垃圾回收器的特点及区别&lt;/li&gt;
      &lt;li&gt;双亲委派模型&lt;/li&gt;
      &lt;li&gt;JDBC和双亲委派模型关系&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;strong&gt;Java基础&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;HashMap和ConcurrentHashMap区别（必考）&lt;/li&gt;
      &lt;li&gt;ConcurrentHashMap的数据结构（必考）&lt;/li&gt;
      &lt;li&gt;高并发HashMap的环是如何产生的&lt;/li&gt;
      &lt;li&gt;volatile作用（必考）&lt;/li&gt;
      &lt;li&gt;Atomic类如何保证原子性（CAS操作）（必考）&lt;/li&gt;
      &lt;li&gt;synchronized和Lock的区别（必考）&lt;/li&gt;
      &lt;li&gt;为什么要使用线程池（必考）&lt;/li&gt;
      &lt;li&gt;核心线程池ThreadPoolExecutor的参数（必考）&lt;/li&gt;
      &lt;li&gt;ThreadPoolExecutor的工作流程（必考）&lt;/li&gt;
      &lt;li&gt;如何控制线程池线程的优先级&lt;/li&gt;
      &lt;li&gt;线程之间如何通信&lt;/li&gt;
      &lt;li&gt;Boolean占几个字节&lt;/li&gt;
      &lt;li&gt;jdk1.8/jdk1.7都分别新增了哪些特性&lt;/li&gt;
      &lt;li&gt;Exception和Error&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;strong&gt;Spring&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Spring的IOC/AOP的实现（必考）&lt;/li&gt;
      &lt;li&gt;动态代理的实现方式（必考）&lt;/li&gt;
      &lt;li&gt;Spring如何解决循环依赖（三级缓存）（必考）&lt;/li&gt;
      &lt;li&gt;Spring的后置处理器&lt;/li&gt;
      &lt;li&gt;Spring的@Transactional如何实现的（必考）&lt;/li&gt;
      &lt;li&gt;Spring的事务传播级别&lt;/li&gt;
      &lt;li&gt;BeanFactory和ApplicationContext的联系和区别&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;strong&gt;其他&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;高并发系统的限流如何实现&lt;/li&gt;
      &lt;li&gt;高并发秒杀系统的设计&lt;/li&gt;
      &lt;li&gt;负载均衡如何设计&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;strong&gt;补充&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;另外还会考一些计算机网络，操作系统啊之类的。像消息队列，RPC框架这种考的比较少。计算机网络就是分层啊，tcp/udp啊，三次握手之类的。操作系统就是进程与线程啊，进程的数据结构以及如何通信之类的。数据结构的排序算法也比较常考，考的话一定会让你手写个快排。剩下的算法题就靠LeetCode的积累了。其实非算法岗考的算法题都蛮简单的，很多题完全就是考察你智力是否正常，稍微难点的涉及到一些算法思想的按照LeetCode题目类型的分类，每种题做一两道基本就能完全应付面试了。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/discuss/342084?type=2&amp;amp;order=4&amp;amp;pos=2&amp;amp;page=1&quot;&gt;https://www.nowcoder.com/discuss/342084?type=2&amp;amp;order=4&amp;amp;pos=2&amp;amp;page=1&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;重写equals()是否需要重写hashcode()，不重写会有什么后果&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;自旋锁和阻塞锁的区别&lt;/li&gt;
      &lt;li&gt;公平锁和非公平锁的区别&lt;/li&gt;
      &lt;li&gt;jdk中哪种数据结构或工具可以实现当多个线程到达某个状态时执行一段代码&lt;/li&gt;
      &lt;li&gt;栅栏和闭锁的区别&lt;/li&gt;
      &lt;li&gt;如何使用信号量实现上述情况&lt;/li&gt;
      &lt;li&gt;新生代和年老代的GC算法分别是什么&lt;/li&gt;
      &lt;li&gt;标记清除和标记整理的区别&lt;/li&gt;
      &lt;li&gt;了解过CMS收集器吗&lt;/li&gt;
      &lt;li&gt;解释HTTPs，HTTPs为什么要用对称加密+非对称加密，相对于只使用非对称加密有什么好处&lt;/li&gt;
      &lt;li&gt;给定一个表，其中有三列（员工名称，工资，部门号），找出每个部门工资最高的员工&lt;/li&gt;
      &lt;li&gt;LeetCode 863 二叉树中所有距离为K的结点&lt;/li&gt;
      &lt;li&gt;用过哪些Java开源框架&lt;/li&gt;
      &lt;li&gt;讲一讲对Spring的理解&lt;/li&gt;
      &lt;li&gt;看过IOC和AOP的源码吗&lt;/li&gt;
      &lt;li&gt;它们底层是如何实现的&lt;/li&gt;
      &lt;li&gt;用过其他什么框架&lt;/li&gt;
      &lt;li&gt;了解过分布式或者微服务的开源框架吗&lt;/li&gt;
      &lt;li&gt;讲一讲对分布式系统模型的理解&lt;/li&gt;
      &lt;li&gt;分布式系统中有一个节点宕机怎么办&lt;/li&gt;
      &lt;li&gt;分布式系统如何实现负载均衡&lt;/li&gt;
      &lt;li&gt;MySQL和Oracle数据库有哪些不同&lt;/li&gt;
      &lt;li&gt;数据库有哪些锁&lt;/li&gt;
      &lt;li&gt;表锁和行锁的区别&lt;/li&gt;
      &lt;li&gt;哪些场景需要加表锁&lt;/li&gt;
      &lt;li&gt;插入一条数据需要加什么锁&lt;/li&gt;
      &lt;li&gt;分布式数据库如何保证数据可靠性&lt;/li&gt;
      &lt;li&gt;了解过MySQL的主从复制吗&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/discuss/372983&quot;&gt;https://www.nowcoder.com/discuss/372983&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;如何实现延时任务&lt;/li&gt;
      &lt;li&gt;如何实现限流&lt;/li&gt;
      &lt;li&gt;线程池的参数&lt;/li&gt;
      &lt;li&gt;epoll和poll的区别&lt;/li&gt;
      &lt;li&gt;如何自己实现内存分配和管理？不太懂，然后说了jvm的垃圾回收机制&lt;/li&gt;
      &lt;li&gt;Redis的key过期策略&lt;/li&gt;
      &lt;li&gt;缓存穿透和缓存雪崩&lt;/li&gt;
      &lt;li&gt;分布式锁&lt;/li&gt;
      &lt;li&gt;如何实现全局的id生成策略&lt;/li&gt;
      &lt;li&gt;悲观锁和乐观锁&lt;/li&gt;
      &lt;li&gt;写个producer-consumer&lt;/li&gt;
      &lt;li&gt;两线程交替打印&lt;/li&gt;
      &lt;li&gt;线程模拟100分钱随机分给20个人，每个人最少分配到2分钱&lt;/li&gt;
      &lt;li&gt;MVCC&lt;/li&gt;
      &lt;li&gt;HTTPS&lt;/li&gt;
      &lt;li&gt;ElasticSearch的查询过程&lt;/li&gt;
      &lt;li&gt;Kafka如何保证高可用&lt;/li&gt;
      &lt;li&gt;Reids的集群和选主&lt;/li&gt;
      &lt;li&gt;分布式一致性算法&lt;/li&gt;
      &lt;li&gt;如何实现定时关单&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/discuss/382503&quot;&gt;https://www.nowcoder.com/discuss/382503&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;数据库的三大范式和约束类型&lt;/li&gt;
      &lt;li&gt;线程生命周期&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/discuss/382603&quot;&gt;https://www.nowcoder.com/discuss/382603&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;知道MySQL插入和查询分别用的是什么锁吗？&lt;/li&gt;
      &lt;li&gt;引用计数法与GC Root可达性分析法区别&lt;/li&gt;
      &lt;li&gt;CAS机制会出现什么问题&lt;/li&gt;
      &lt;li&gt;RabbitMQ了解吗？丢失消息，重复消费问题怎么处理？&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/discuss/382329&quot;&gt;https://www.nowcoder.com/discuss/382329&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;如何衡量一个哈希算法的好坏&lt;/li&gt;
      &lt;li&gt;哈希解决冲突的4种方法&lt;/li&gt;
      &lt;li&gt;cookie和session的生命周期&lt;/li&gt;
      &lt;li&gt;集群中的session会遇到什么问题，有什么解决方案呢&lt;/li&gt;
      &lt;li&gt;常量过多会导致什么问题&lt;/li&gt;
      &lt;li&gt;JDK8用了哪种回收器，内存空间管理和以前相比有哪些提升（Parallel Scavenge + Parallel Old）&lt;/li&gt;
      &lt;li&gt;构造函数的加载顺序，多个构造函数先加载哪一个&lt;/li&gt;
      &lt;li&gt;group by中使用的having是用来干啥的&lt;/li&gt;
      &lt;li&gt;服务治理介绍一下&lt;/li&gt;
      &lt;li&gt;远程调用需要从注册中心代理吗&lt;/li&gt;
      &lt;li&gt;如果注册中心代理的话并发量太大不会承受不了，怎么解决&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/discuss/382110&quot;&gt;https://www.nowcoder.com/discuss/382110&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;bio. nio&lt;/li&gt;
      &lt;li&gt;linux五种io模型&lt;/li&gt;
      &lt;li&gt;poll 和 epoll 的区别&lt;/li&gt;
      &lt;li&gt;synchronized底层原理&lt;/li&gt;
      &lt;li&gt;AQS&lt;/li&gt;
      &lt;li&gt;聚簇索引非聚簇索引&lt;/li&gt;
      &lt;li&gt;timewait和closewait状态含义&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/discuss/381858&quot;&gt;https://www.nowcoder.com/discuss/381858&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;synchronized用在静态和非静态方法的区别&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/discuss/381849&quot;&gt;https://www.nowcoder.com/discuss/381849&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;jre和jdk的区别&lt;/li&gt;
      &lt;li&gt;如何理解僵尸进程，如何解决僵尸进程&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/discuss/381726&quot;&gt;https://www.nowcoder.com/discuss/381726&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;结合数据库三大范式聊聊，项目的表设计&lt;/li&gt;
      &lt;li&gt;redis为什么快？在多核cpu下redis单线程浪费？&lt;/li&gt;
      &lt;li&gt;redis击穿&lt;/li&gt;
      &lt;li&gt;redis与mysql数据同步&lt;/li&gt;
      &lt;li&gt;redis集群&lt;/li&gt;
      &lt;li&gt;redis分布式锁的实现(https://www.cnblogs.com/williamjie/p/9395659.html)&lt;/li&gt;
      &lt;li&gt;海量数据，找重复数量前几的数据&lt;/li&gt;
      &lt;li&gt;写个死锁&lt;/li&gt;
      &lt;li&gt;处理日志，获取error的日志，去重，排序（本意是让用shell写的，但我不会，就用Java写了）&lt;/li&gt;
      &lt;li&gt;写个LRU&lt;/li&gt;
      &lt;li&gt;泛型、通配符区别&lt;/li&gt;
      &lt;li&gt;红黑树为什么插入效率高&lt;/li&gt;
      &lt;li&gt;MySQL执行SQL的流程&lt;/li&gt;
      &lt;li&gt;选择排序原理，时间、空间复杂度&lt;/li&gt;
      &lt;li&gt;访问量太大redis支撑不住怎么办&lt;/li&gt;
      &lt;li&gt;爬虫用的是什么？有用框架吗？有用多线程爬虫吗？&lt;/li&gt;
      &lt;li&gt;用过哪些SpringCloud组件&lt;/li&gt;
      &lt;li&gt;redis数据结构&lt;/li&gt;
      &lt;li&gt;redis zset set区别&lt;/li&gt;
      &lt;li&gt;redis在增删改查时为什么单线程 还那么快？io模型？&lt;/li&gt;
      &lt;li&gt;MYSQL日志种类 undolog redolog分别是做什么的？(https://www.jianshu.com/p/57c510f4ec28)&lt;/li&gt;
      &lt;li&gt;MYSQL如何实现MVCC(https://blog.csdn.net/nmjhehe/article/details/98470570)&lt;/li&gt;
      &lt;li&gt;MYSQL优化，Explain 有哪些信息&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/discuss/380853&quot;&gt;https://www.nowcoder.com/discuss/380853&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;线程安全的单例模式&lt;/li&gt;
      &lt;li&gt;类加载时机&lt;/li&gt;
      &lt;li&gt;虚拟内存，内存爆了怎么办&lt;/li&gt;
      &lt;li&gt;https能讲一下吗(https://www.jianshu.com/p/14cd2c9d2cd2)&lt;/li&gt;
      &lt;li&gt;数据库聚集索引和非聚集索引能讲一下吗&lt;/li&gt;
      &lt;li&gt;read commited隔离级别解决什么问题，通过什么实现(https://blog.csdn.net/fxkcsdn/article/details/82694357)&lt;/li&gt;
      &lt;li&gt;数据库行锁是互斥锁还是其他还是什么类型的锁呢，读操作会阻塞吗(https://blog.csdn.net/arkblue/article/details/53895150)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/discuss/164967&quot;&gt;https://www.nowcoder.com/discuss/164967&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;如何判断一颗二叉树是另一颗二叉树的子树&lt;/li&gt;
      &lt;li&gt;tcp如果在发送数据的时候服务器宕机了会怎么样，服务器又好了又会怎么样呢&lt;/li&gt;
      &lt;li&gt;用过缓存，Redis吗，用过分布式吗，比如kafka或者dubbo&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/discuss/219099&quot;&gt;https://www.nowcoder.com/discuss/219099&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;大量用户产生很多消息，消息队列怎么处理&lt;/li&gt;
      &lt;li&gt;消费者消费不完怎么处理&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/discuss/362693&quot;&gt;https://www.nowcoder.com/discuss/362693&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;线程池（具体参数，拒绝策略，减少线程的机制，具体实现类及对应的阻塞队列，阻塞队列有什么特点，为什么用这个阻塞队列，线程复用的原理）(https://blog.csdn.net/testcs_dn/article/details/78083966)&lt;/li&gt;
      &lt;li&gt;JVM（对象是否可回收的判断条件，怎么判断，回收算法，垃圾回收器的类别及特点，担保机制）&lt;/li&gt;
      &lt;li&gt;JAVA内存模型&lt;/li&gt;
      &lt;li&gt;线程之间的通信方式，通过volatile，synchronized，Lock的实现类那些，结合内存模型去讲。&lt;/li&gt;
      &lt;li&gt;MyBatis、spring、springboot相关（面试题较常见）&lt;/li&gt;
      &lt;li&gt;Linux常用命令&lt;/li&gt;
      &lt;li&gt;redis的数据结构那些，讲了skiplist、ziplist、sds等，结合使用场景说了下(https://blog.csdn.net/chenssy/article/details/89599232)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/discuss/370072&quot;&gt;https://www.nowcoder.com/discuss/370072&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;transient关键字的作用&lt;/li&gt;
      &lt;li&gt;synchronized关键字加的地方，有什么区别，底层实现&lt;/li&gt;
      &lt;li&gt;算法：两个数值原地交换值，不能使用第三个变量(https://blog.csdn.net/qq_39411607/article/details/80989996)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/discuss/198399&quot;&gt;https://www.nowcoder.com/discuss/198399&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;事务传播&lt;/li&gt;
      &lt;li&gt;变量的初始化顺序(https://www.zhihu.com/question/49196023)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/discuss/370435&quot;&gt;https://www.nowcoder.com/discuss/370435&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;写题：由于记账错误，给定的一个正整数序列里面，有两个数字重复了，同时缺少了一个数字。 要求写一个函数，找出序列中重复的数字和缺少的数字。（set、异或） 例如： 输入：[1, 5, 2, 2, 3] 输出：[2, 4] 附加： 如果题目为缺少x个数字，并且输入序列可能有不匹配的重复和缺少项&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;进程线程协程(https://blog.csdn.net/fadbgfnbxb/article/details/88787361)&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/discuss/192690&quot;&gt;https://www.nowcoder.com/discuss/192690&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;逻辑题，25匹赛马🐎，5条赛道，求前三快的马(https://www.nowcoder.com/questionTerminal/e07d8e0df93b4f6b93a3fadbe72f2c7c)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/discuss/98120&quot;&gt;https://www.nowcoder.com/discuss/98120&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;了解过其他AOP包：ASPECTJ么&lt;/li&gt;
      &lt;li&gt;start之后线程就会马上调用吗&lt;/li&gt;
      &lt;li&gt;了解过乐观锁和悲观锁么，如何自己实现一个乐观锁&lt;/li&gt;
      &lt;li&gt;hashMap高并发下的缺陷？链表为什么会成环？(https://blog.csdn.net/wthfeng/article/details/88972137)&lt;/li&gt;
      &lt;li&gt;类隔离&lt;/li&gt;
      &lt;li&gt;包冲突&lt;/li&gt;
      &lt;li&gt;有了解过RPC么&lt;/li&gt;
      &lt;li&gt;了解过一致性Hash么？&lt;/li&gt;
      &lt;li&gt;Java1.8做了什么优化，新特性&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/discuss/238370&quot;&gt;https://www.nowcoder.com/discuss/238370&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;反射的作用，反射相关的类(https://snailclimb.gitee.io/javaguide/#/docs/java/basic/reflection)&lt;/li&gt;
      &lt;li&gt;假设一个场景，支付系统和订单系统，支付失败后订单系统怎么知道失败（感觉是分布式事务的一致性，我开始问他是两个系统吗？是分布式吗？他也不回答我，后面复述一遍问题我又问了一遍分布式事务的一致性，他才说是的）(https://www.cnblogs.com/luxiaoxun/p/8832915.html)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/discuss/258249&quot;&gt;https://www.nowcoder.com/discuss/258249&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;反射的原理及应用&lt;/li&gt;
      &lt;li&gt;spring四种事务的实现方式(https://blog.csdn.net/chinacr07/article/details/78817449)&lt;/li&gt;
      &lt;li&gt;cap和base&lt;/li&gt;
      &lt;li&gt;问了几个设计模式 工厂 策略 *** 观察者 适配器 桥接等，jdk里面用到了哪些说说&lt;/li&gt;
      &lt;li&gt;分布式秒杀如果不用mq怎么做？我说直接去掉mq用异步➕分布式事务，大佬说不好，还有吗？&lt;/li&gt;
      &lt;li&gt;统计用户url访问次数，我说用拦截器存redis，大佬问java有没有提供这种系统或者工具直接用？我说令牌桶也行，大佬没说话&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/discuss/89956&quot;&gt;https://www.nowcoder.com/discuss/89956&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;字符串连接的几种方法和区别(https://www.cnblogs.com/lujiahua/p/11408689.html)&lt;/li&gt;
      &lt;li&gt;自己实现线程池如何实现&lt;/li&gt;
      &lt;li&gt;如何防止重复买&lt;/li&gt;
      &lt;li&gt;String类为什么要设计为final(https://www.zhihu.com/question/31345592)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/discuss/381334&quot;&gt;https://www.nowcoder.com/discuss/381334&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;JDBC&lt;/li&gt;
      &lt;li&gt;synchronized和lock底层实现，区别&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/discuss/87868&quot;&gt;https://www.nowcoder.com/discuss/87868&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;Java的线程池说一下，各个参数的作用，如何进行的。&lt;/li&gt;
      &lt;li&gt;Redis讲一下&lt;/li&gt;
      &lt;li&gt;分布式系统的全局id如何实现。用zookeeper如何实现的呢，机器号+时间戳即可。&lt;/li&gt;
      &lt;li&gt;分布式锁的方案，redis和zookeeper那个好，如果是集群部署，高并发情况下哪个性能更好。&lt;/li&gt;
      &lt;li&gt;kafka了解么，了解哪些消息队列。&lt;/li&gt;
      &lt;li&gt;反射的作用是什么&lt;/li&gt;
      &lt;li&gt;了解哪些中间件，dubbo，rocketmq，mycat等。&lt;/li&gt;
      &lt;li&gt;dubbo中的rpc如何实现。&lt;/li&gt;
      &lt;li&gt;自己实现rpc应该怎么做&lt;/li&gt;
      &lt;li&gt;dubbo的服务注册与发现。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/discuss/244392&quot;&gt;https://www.nowcoder.com/discuss/244392&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;Mybatis是如何做到动态sql解析&lt;/li&gt;
      &lt;li&gt;Mybatis是如何实现xml文件与实体类的映射&lt;/li&gt;
      &lt;li&gt;java中反射获取到的属性和方法是存储在什么地方(字节码、方法区)&lt;/li&gt;
      &lt;li&gt;反射如何获取方法上的注解(https://www.cnblogs.com/a591378955/p/8350499.html)&lt;/li&gt;
      &lt;li&gt;注解和接口的区别(https://www.cnblogs.com/linshenghui/p/11213867.html)&lt;/li&gt;
      &lt;li&gt;Redis中的命令(https://www.runoob.com/redis/redis-keys.html)(https://www.php.cn/faq/417108.html)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://bbs.byr.cn/#!article/ParttimeJob/856659&quot;&gt;https://bbs.byr.cn/#!article/ParttimeJob/856659&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;p&gt;JAVA研发工程师&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;希望你是2021年应届毕业生（校招）&lt;/li&gt;
      &lt;li&gt;扎实的java编程基础（java语法原理，java容器原理，jvm原理（jvm调优加分），java并发（越深越好）），熟悉java开发体系，如果能有一定的项目开发经验那就更好了。&lt;/li&gt;
      &lt;li&gt;表达问题思路清晰，良好的沟通能力与技术学习能力 （后面项我列举了最好了解一下的知识）&lt;/li&gt;
      &lt;li&gt;有过用mysql等数据库使用经验&lt;/li&gt;
      &lt;li&gt;了解http，操作系统，计网等基础知识(我另一篇推荐知识的博客有这些，大概简单的勉强够用)&lt;/li&gt;
      &lt;li&gt;了解一些简单的设计模式（常见的那些最好看过一些源码，实现过一些，项目中用到过并有自己的理解）&lt;/li&gt;
      &lt;li&gt;了解SSM，SpringBoot 等框架加分（建议初学以spring，spring boot，mybatis框架开始，这是现在很多公司的主流架构）&lt;/li&gt;
      &lt;li&gt;了解WEB开发相关技术，如HTML，CSS，JavaScript，ajax 等加分（优先度不高，安心安心）&lt;/li&gt;
      &lt;li&gt;了解分布式架构加分（缓存建议学一下redis，消息队列可以学一下kafka，rocketmq，分布式事务了解一些，分布式锁可以学一下zookeeper，rpc可以看dubbo）&lt;/li&gt;
      &lt;li&gt;了解高可用架构加分(比如看看Hystrix，优先级不高~ )&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;了解微服务加分（公司项目现在设计的很轻量级，一般都是微服务架构的，了解一下有好处，这是未来所有公司架构的升级方向）&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;热点数据请求太多，redis负载均衡全都hash到一个节点上，如何处理(https://www.cnblogs.com/rjzheng/p/10874537.html)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/discuss/181259&quot;&gt;https://www.nowcoder.com/discuss/181259&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;学习历程&lt;/p&gt;

    &lt;p&gt;18/10月: 那时候学长发布了一些日常实习的内容，这时候我才发现自己什么都不会。开始慢慢准备找实习的事。我当时很纠结，不知道自己应该从事什么样的方向。学校实验室的项目是C++，但是最后还是放弃了，因为我发现岗位太少了。于是转而走向了Java后台的路线，当时我只有一点点语法的基础。&lt;/p&gt;

    &lt;p&gt;18/11月：开始补Java语法的基础，说实话我没有去啃《Think in Java》这类厚的书，我看的第一本是《Effective Java》,不出意料，看的第一遍并不懂，不过几个月后再看一遍是真的收获很大。学校网络原理开的晚，我便把网络原理自学了一下，看了《自顶向下》这本书，把最常考的应用层、传输层、网络层看了一遍。&lt;/p&gt;

    &lt;p&gt;18/12月：我开始发觉缺少实践了，于是开始走了Web后台的方向，当然也走了不少弯路。建议路线是servlet规范了解后，直接上Spring Boot，然后慢慢了解Spring MVC的原理，IOC/AOP的原理，以及掌握一门ORM框架。也开始看Java的并发，《艺术》看了两遍，《实战》看了一半。《Java虚拟机》看了一遍。&lt;/p&gt;

    &lt;p&gt;19/1月：我开始系统地学习MySQL与Redis，《MySQL技术内幕》和《高性能MySQL》各看了一小部门。重点看事务、InnoDB存储引擎、索引、热备、主从以及分片。Redis建议实践最重要，做分布式锁、做缓存，自己要试着去敲代码，然后慢慢就熟练了。当时《Redis设计与实现》也看了四分之三。然后也开始复习了HTTP的内容，《图解HTTP》看了一遍。&lt;/p&gt;

    &lt;p&gt;19/2月：我开始跟着视频做项目。自己改编了，换了技术栈做了原创的web项目。项目需要有亮点才能打动面试官，我推荐把《大型网站技术架构》看一遍，这本书很好，一点都不难懂，就像看小说一样。将里面的部分内容复现一遍，你的项目也有闪光点了。买了极客时间的虚拟机课，看了一部分，补充下JVM的知识。&lt;/p&gt;

    &lt;p&gt;19/3月：我开始细读源码，Java的容器、JUC的部分源码、Spring的部分实现，看别人的博客对照着读会收获很多。这时候也开始陆陆续续面试了，最重要的就是复盘，了解自己的不足，并且弥补。之前准备的过程中也再陆陆续续写博客。到3月底时，一共写了51篇。操作系统、分布式等知识我有一直对照着CyC大佬的Github以及其他大佬的博客看，收获很大。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/discuss/238131&quot;&gt;https://www.nowcoder.com/discuss/238131&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;面的是阿里口碑，总共38分钟，小哥哥人很好，但是我感觉我好菜&lt;/p&gt;

    &lt;p&gt;1.我看你是大数据与网络安全实验室，我们不招安全呀。
2.Java基础，实现多线程的方法，线程池有哪些，怎么扩容。
3.三次握手，四次挥手
4.设计模式（我说只熟悉单例和工厂，他说那算了）
5.Mysql索引讲一讲
6.redis介绍一下
7.缓存击穿，穿透，雪崩怎么处理，怎么预防
8.mysql和redis怎么保证数据一致
9.kafka怎么保证消息不丢失
10.springmvc流程讲一下
11.redis锁机制，怎么处理并发（我说这个不太熟，mysql的锁机制比较熟，小哥哥说那你讲一下）
12.让你设计一个高性能的购物网站，你怎么设计，从前端到后台，到数据库
13.你有什么想问我的&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/discuss/240122&quot;&gt;https://www.nowcoder.com/discuss/240122&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;前言
8.29投的内推，8.31面我了，还是个周六，果然是福报，我太难了。
不过面完我再去官网看，我的简历还是在评估中，不知道怎么进的流程吧，我笔试也一个没做（没通知我），真是奇了怪了。
口碑部门Java岗。
抱着玩一玩的心态投的简历，看了这里那么多大佬都被刷了，我就没抱希望，本着查漏补缺，啊不，本着女娲补天的补知识的心态去面试的。
面试时间28分钟，发挥得不好。
概述
主要问了以下几个方面
1、自我介绍
2、Java反射
3、类加载器
4、HashMap
5、数组链表
6、锁
7、数据库
8、算法
正文
〇 Java反射
上手就问你了解反射么，讲讲吧？我真不知道从哪里讲起。
然后问反射的private的访问，关于是否能访问私有成员变量
那private还有什么用
反射的优缺点
反射的使用场景
反射怎么使用
〇 类加载器
讲讲类加载器吧。我，，，我真不知道从哪里讲，就把几个类加载器说了一下
〇 HashMap
HashMap的数据结构怎么样的，我就说了一下 数组和链表这种，不知道是不是他的意思
key可否null，为什么
是否线程安全，否则会发生什么情况
〇 数组链表
ArrayList的优缺点
数组和链表的区别
〇 锁
类锁和对象锁的不同
〇 数据库
MySQL索引的机制，我说的是B+，不知道是不是他的意思
为什么要用索引，好处是？坏处是？
简单介绍一下MySQL的事务。这里我又好难了，又不知道回答的方向是什么。于是就说了事务的隔离，MySQL的引擎
数据库回滚的原理，这个我还真不怎么会
〇 算法
无环链表是否相交
劝退算法：梯度下降算法给我讲讲，我：？？？？？？？？？？？？？？
后记
全程体验不太好，有时候有点尬聊，问题之间双方经常有沉默，我get不到他想的方面，所以没有半小时就over了，也没问我你有什么要问的，说了句，谢谢你就到此结束了。我：？？？？
不管了不管了，体验不是很好，也没想着进二面，就当做复习和预习吧。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;面试&quot;&gt;面试&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;阿里&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;红黑树&lt;/li&gt;
      &lt;li&gt;ARP协议&lt;/li&gt;
      &lt;li&gt;java如何实现多态：虚函数子类重写，然后让父类对象指针指向子类，这是调用虚函数&lt;/li&gt;
      &lt;li&gt;leetcode751：给你一个cidr网络段，算出所有合理的ip，比如1.2.3.4/24，输出1.2.3.1~1.2.3.254&lt;/li&gt;
      &lt;li&gt;leetcode 1143：求两个字符串的最长公共子串&lt;/li&gt;
      &lt;li&gt;如何解决hashmap线程不安全，concurrenthashmap的原理，扩容为什么是2的幂&lt;/li&gt;
      &lt;li&gt;SpringBoot实现的原理、AOP的原理、注解的原理（xml配置加注入）&lt;/li&gt;
      &lt;li&gt;线程池&lt;/li&gt;
      &lt;li&gt;最大的优点，AOP的原理&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;java1.8类加载是在哪里发生的（方法区移到元空间，在直接内存里）&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;项目：增量添加（时间戳），查询依赖字段，实习中的难点、负责的工作&lt;/li&gt;
      &lt;li&gt;like能否使用索引&lt;/li&gt;
      &lt;li&gt;CPU过高怎么应对&lt;/li&gt;
      &lt;li&gt;三次握手，为什么要有第三次&lt;/li&gt;
      &lt;li&gt;往一个网页输入URL发生了什么&lt;/li&gt;
      &lt;li&gt;用过的linux命令&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;docker对项目的部署&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;项目介绍&lt;/li&gt;
      &lt;li&gt;SpringBoot和Spring的区别&lt;/li&gt;
      &lt;li&gt;AOP原理&lt;/li&gt;
      &lt;li&gt;MySQL如何导入Solr及如何增量导入&lt;/li&gt;
      &lt;li&gt;Bean的生命周期&lt;/li&gt;
      &lt;li&gt;hashMap扩容&lt;/li&gt;
      &lt;li&gt;JVM的结构、收集算法、G1和CMS的不同（stop the world发生时间）&lt;/li&gt;
      &lt;li&gt;session和cookie介绍&lt;/li&gt;
      &lt;li&gt;mysql acid和事务隔离级别&lt;/li&gt;
      &lt;li&gt;mysql索引的数据结构及介绍（b+树）&lt;/li&gt;
      &lt;li&gt;两个队列实现一个栈&lt;/li&gt;
      &lt;li&gt;依赖注入的方式&lt;/li&gt;
      &lt;li&gt;A依赖于B，B依赖于A，spring如何解决&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;多个服务器的情况，session会不会串（我回答nginx，他说可以解决，答案是redis?）&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;自我介绍，主要说项目&lt;/li&gt;
      &lt;li&gt;围绕项目，挑一个说了项目的架构，为什么用SpringCloud，和dubbo对比&lt;/li&gt;
      &lt;li&gt;微服务时怎么拆分的，微服务和传统单体式相比的优缺点&lt;/li&gt;
      &lt;li&gt;项目中的难点&lt;/li&gt;
      &lt;li&gt;五层网络模型说一下，HTTP属于哪一层，下面又用到那些层&lt;/li&gt;
      &lt;li&gt;TCP协议的特点说一说&lt;/li&gt;
      &lt;li&gt;拥塞避免算法说一说&lt;/li&gt;
      &lt;li&gt;HTTP2.0了解吗&lt;/li&gt;
      &lt;li&gt;HTTPS的过程说一说&lt;/li&gt;
      &lt;li&gt;非对称加密算法了解吗&lt;/li&gt;
      &lt;li&gt;从输入URL到得到响应，中间的过程说一说&lt;/li&gt;
      &lt;li&gt;操作系统进程、线程、协程说一说&lt;/li&gt;
      &lt;li&gt;进程之间是怎么通信的&lt;/li&gt;
      &lt;li&gt;求最短路径的算法说一说&lt;/li&gt;
      &lt;li&gt;排序算法，快排的时间复杂度，为什么是不稳定的&lt;/li&gt;
      &lt;li&gt;TOPK问题（用大顶堆或者小顶堆），时间复杂度&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;用1G的数据，但是只有128M的内存，要排序怎么排&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;JVM的内存划分，解释各个区域的作用，JVM为什么要这么分区&lt;/li&gt;
      &lt;li&gt;分布式：paxos协议的leader选举&lt;/li&gt;
      &lt;li&gt;两个字符数组求交集&lt;/li&gt;
      &lt;li&gt;jvm分区&lt;/li&gt;
      &lt;li&gt;redis介绍&lt;/li&gt;
      &lt;li&gt;tcpip协议介绍&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;索引优化有哪些&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;单链表序列化反序列化，结点中存字符串怎么办，类比网络中组包分包&lt;/li&gt;
      &lt;li&gt;数据库表怎么设计，用户登录怎么保证安全性，数据库建索引了吗，为什么要把这些列作为索引， 索引建立顺序怎么确定&lt;/li&gt;
      &lt;li&gt;shiro中的token保存在什么地方&lt;/li&gt;
      &lt;li&gt;concurrenthashmap的场景：抢票&lt;/li&gt;
      &lt;li&gt;hibernate多对多是怎么查询的，hibernate多对多模型介绍下，数据库表索引设计顺序设计，为啥选择shiro&lt;/li&gt;
      &lt;li&gt;session怎么分布式存储（cookie，redis）&lt;/li&gt;
      &lt;li&gt;并发打印foobar&lt;/li&gt;
      &lt;li&gt;三个瓶身可以换一瓶酒，七个瓶盖可以换一瓶酒，初始x瓶酒，一共可以喝几瓶酒（考虑借瓶子、瓶盖再还回去）&lt;/li&gt;
      &lt;li&gt;atomiclong atomicadder&lt;/li&gt;
      &lt;li&gt;随机生成1到一亿的数，怎么保证不重复（布隆过滤器），误报怎么办&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;hashmap concurrenthashmap(1.7 1.8 多线程扩容死循环 put的位置是NULL就用CAS插入，如果是forward就参与扩容，最后加syn锁)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;Hashmap底层结构（1.7 1.8）concurrenthashmap怎么保证高效地操作(https://blog.csdn.net/qq_36520235/article/details/82417949)&lt;/li&gt;
      &lt;li&gt;线程池优点、线程池的参数在什么场景下应该怎么配置、IO密集型线程跟CPU密集型线程的线程池参数怎么配置&lt;/li&gt;
      &lt;li&gt;如何自定义一个注解(https://blog.csdn.net/xsp_happyboy/article/details/80987484)&lt;/li&gt;
      &lt;li&gt;有没有接触过什么新技术(Docker)(https://zhuanlan.zhihu.com/p/62653543)(https://zhuanlan.zhihu.com/p/62653543)(https://www.cnblogs.com/linguoguo/p/10754756.html)&lt;/li&gt;
      &lt;li&gt;有没有知道其他的数据库、非关系型数据库、分布式数据库(Redis)&lt;/li&gt;
      &lt;li&gt;Redis的使用场景，按你的理解如何设计一个秒杀系统(https://www.jianshu.com/p/d789ea15d060)
        &lt;blockquote&gt;
          &lt;ol&gt;
            &lt;li&gt;后台使用redis分布式数据库来保存秒杀的物品的信息，整体的服务架构可以使用 集群模式+主从模式，每个服务器分担一定的请求，并在主服务器出现故障后由哨兵节点及时切换到从服务器。&lt;/li&gt;
            &lt;li&gt;在此期间，不要将缓存中的数据与数据库进行同步，等时间过后再进行同步。&lt;/li&gt;
            &lt;li&gt;在数据持久化过程中，使用AOF方式，并可以把AOF持久化的时间间隔调整稍微长一点，减少持久化操作的次数。&lt;/li&gt;
            &lt;li&gt;在redis缓存中，设置要秒杀的物品的信息永不过期，防止出现缓存雪崩的问题，并使用布隆过滤器来过滤掉来自客户端的一些无效恶意请求&lt;/li&gt;
            &lt;li&gt;服务器处理请求时，使用消息队列，减轻服务器并发操作的压力&lt;/li&gt;
            &lt;li&gt;当整体某些下游服务出现故障时，对故障服务进行熔断，防止影响整体服务的性能； 当整体服务的负载过高时，可以适当对某些服务进行降级，减低整体服务的负载&lt;/li&gt;
          &lt;/ol&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;在低并发的场景下，如何保证redis与数据库的数据一致性&lt;/li&gt;
      &lt;li&gt;Session的持久化问题&lt;/li&gt;
      &lt;li&gt;登录人数的统计问题&lt;/li&gt;
      &lt;li&gt;用户关闭了网页，服务器知道，并让用户登出&lt;/li&gt;
      &lt;li&gt;如果有了用户违反了一些操作，怎么禁用这些用户的任何操作和登录（禁止token）&lt;/li&gt;
      &lt;li&gt;AomicLong跟LongAdder的区别&lt;/li&gt;
      &lt;li&gt;使用Random生成 1~1亿的数字到文件中，如何保证不重复、单线程和多线程环境下&lt;/li&gt;
      &lt;li&gt;Java1.8 1.9 1.10的区别 jdk源码中用到了哪些设计模式&lt;/li&gt;
      &lt;li&gt;Shiro的过程，如果这个人的角色权限信息修改了，session中这个人的信息应该怎么办&lt;/li&gt;
      &lt;li&gt;用户登陆的过程（实质上就是一次浏览器请求页面的过程）&lt;/li&gt;
      &lt;li&gt;如果项目的qps很高的话项目怎么设计（分布式）&lt;/li&gt;
      &lt;li&gt;Servlet知不知道 他的生命周期&lt;/li&gt;
      &lt;li&gt;线程池的使用，应该注意哪些问题，原生的线程池有哪些隐患&lt;/li&gt;
      &lt;li&gt;Springboot为啥能提供服务（因为有tomcat） tomcat你知道有啥东西吗，或者能配置什么东西 项目怎么配置运行过程中的jvm一些信息&lt;/li&gt;
      &lt;li&gt;Cpu怎么排查，怎么查看进程的信息，有没有导出过dump文件，你能看到什么东西&lt;/li&gt;
      &lt;li&gt;服务集群了解过没&lt;/li&gt;
      &lt;li&gt;Rpc是什么，java原生的rpc知不知道 rmi知不知道&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;头条&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;100瓶药水，其中只有一瓶有毒。给你一些老鼠，老鼠吃了之后24小时内会死亡。请问这24小时内，你需要最少多少只老鼠，可以把那瓶毒药试出来？&lt;/li&gt;
      &lt;li&gt;交替打印ABC&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;领英&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;链表排序：自顶向上的归并排序&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;腾讯&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;一个长度一亿的数组，大量有序，少量无序，把数组改成链表怎么做&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;猿辅导&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;二叉树后序遍历&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;美团&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;自我介绍&lt;/li&gt;
      &lt;li&gt;项目介绍&lt;/li&gt;
      &lt;li&gt;项目中的难点&lt;/li&gt;
      &lt;li&gt;java基础：java的特性，&lt;strong&gt;构造方法能不能被重写&lt;/strong&gt;，hashmap、hashtable、concurrenthashmap对比，string和stringbuffer对比&lt;/li&gt;
      &lt;li&gt;JVM垃圾回收算法&lt;/li&gt;
      &lt;li&gt;有没有用过mysql、redis和消息中间件&lt;/li&gt;
      &lt;li&gt;怎么用的消息中间件&lt;/li&gt;
      &lt;li&gt;TCP/IP的流量控制实现&lt;/li&gt;
      &lt;li&gt;平时怎么学习的&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;算法题：TOP K，无序数组找最小的K个&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;项目，技术难点，怎么攻克的&lt;/li&gt;
      &lt;li&gt;微服务怎么划分的，微服务之间怎么通信的&lt;/li&gt;
      &lt;li&gt;为什么不用dubbo，为什么dubbo比springcloud速度快&lt;/li&gt;
      &lt;li&gt;消息序列化用的什么版本&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;编写sql时需要注意什么&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;stu表，有id、name、score字段，写sql找到成绩第二的&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;where a=x,b&amp;gt;y,c=z会不会走联合索引c,b,a&lt;/strong&gt;(https://blog.csdn.net/weixin_42935902/article/details/96887763)&lt;/li&gt;
      &lt;li&gt;怎么判断一个sql会不会走某个索引，explain的字段都有哪些&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;mysql优化器的策略&lt;/strong&gt;(https://blog.csdn.net/hsd2012/article/details/51526733)&lt;/li&gt;
      &lt;li&gt;怎么衡量一个系统设计得成不成功，负载、TPS都是什么意思&lt;/li&gt;
      &lt;li&gt;平时线上服务出了问题，怎么排查&lt;/li&gt;
      &lt;li&gt;平时都是用什么工具排查JVM问题&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;编程：斜对角线打印二维数组&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;虚拟内存解决了什么问题（说了半天，面试官都觉得没达到点子上）&lt;/li&gt;
      &lt;li&gt;请求分页方式为什么以页未单位，这样的好处&lt;/li&gt;
      &lt;li&gt;进程和线程区别&lt;/li&gt;
      &lt;li&gt;Java中的线程和操作系统怎么对应的&lt;/li&gt;
      &lt;li&gt;CPU为什么要进行进程上下文切换&lt;/li&gt;
      &lt;li&gt;CPU和内存存在速度差异，那么程序执行时怎么解决这个问题（以加法指令为例）&lt;/li&gt;
      &lt;li&gt;CPU负载高有哪些原因，为什么FullGC的时候负载就高，CPU负载高本质是什么导致的&lt;/li&gt;
      &lt;li&gt;Servlet了解吗，它的生命周期是什么&lt;/li&gt;
      &lt;li&gt;SpringMVC比以往使用Servlet开发优势再哪里，什么是MVC，Model具体指什么，为什么需要Model&lt;/li&gt;
      &lt;li&gt;Dubbo原理，把你知道的说下&lt;/li&gt;
      &lt;li&gt;最近在看什么书&lt;/li&gt;
      &lt;li&gt;你技术和性格上的优缺点有哪些&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;1.jvm分区 
2.redis如何处理重复请求（比如你淘宝下单，你按了很多下，你是不是收到了重复请求，但是你单只有一个，所以怎么处理呢，我说redis里有set，每个订单下单都是唯一值，查看是否存在，然后就问我redis如何设定唯一值的命令，我这个不记得了，我查了下好像最好用上redis的锁…）（我觉得是set (key value nx ex)然后value保证唯一）
3.elasticsearch（这个是我自己简历的，你们没有就不用管）
4.mysql锁的概念，以及Mysql什么时候出现死锁，如何解决。
5.描述下二分查询。
6.算法题，删除字符串中出现字符出现最少的字符。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;spring组件，mvcc，es，solr的索引表结构&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Zoom&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/community/comment/detail/1051?action=0&amp;amp;notEmpty=false&amp;amp;page=1&quot;&gt;https://www.nowcoder.com/community/comment/detail/1051?action=0&amp;amp;notEmpty=false&amp;amp;page=1&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;进公司后，HR 拿来一道笔试题，主要是线程安全方面的知识，简单的如 StringBuffer 和 StringBuilder 的区别，一般的有死锁怎么形成的，怎么解决死锁，HashMap,ConcurrentHashMap,LinkedHashMap的区别，SpringMVC的运行原理，难的有分布式锁怎么实现，BIO 和 NIO区别，除了难的题超出了我的范围其他的对我来说都比较easy了。只要JVM，多线程方面的知识准备充分，笔试面试都没问题。下面讲讲面试情况： 技术官进来，先自我介绍，问 new 一个对象，JVM 里面都干了啥，先是加载，验证，准备，解析，初始化啥的。后面问 volatile 关键字，从原子性，可见性，指令重排三个方面说了，又问 Synchronized 关键字在 1.6 做了哪些优化，从锁消除，锁粗化，偏向锁，轻量级锁，重量级锁解锁了一遍。 再问 ReentrantLock 和 Synchronized 的区别，从可中断，是否公平锁，条件锁方面阐述，延伸到 AQS，CAS 等。后面打算问我 IO 和 MySQL 方面的知识，我没经验，就说不知道，面试官也就直接跳过了。除了这两个，我几乎百分百答完了，基本达到甚至超过了面试官的知识准备。 后面是技术经理吧，进来就说刚才的反馈，是你不熟悉 MySQL，那么你平时用什么DB，答Oracle，然后就问你在公司从事什么角色，我是技术组长，那他说你举几个例子吧，我就举了两个，他也没深问，后面就锁，问了 AQS 的原理。再就没怎么问了。然后问我面什么职位，怎么投的简历。问我有什么问题，我当时尿急，直接说要先上下厕所，囧。回来后随便聊了下他们职位的工作内容，问了他们系统的 QPS，也没怎么仔细地说，再问项目都用了哪些技术，讲了些常规的技术。 总体感觉下来，里面的技术实力都不太强，也就一般互联网公司的技术实力，不过也算是中上了，不是什么公司都有独特的环境，获取到大流量，大数据量操练。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;流程的话，从学校投的简历，之后做了一个在线笔试。笔试比较考察基础吧，编程题就一题，也不是很难，刷刷算法题应该都做出来。 没有电面，去公司直接面的，公司环境很好，整体体验很好。下午去早了，前台小姐姐带我去的会议室（很nice的小姐姐还给我一杯水缓解压力），说面试官还在睡觉呢，以为要等很久。结果马上就来了，还打印了我的简历（包里彩打的简历表示毫无用处）之后就是正常面试流程，主要根据简历，考了数据结构，网络协议，数据库，设计模式等。大概50分钟，hr先来聊了一下公司现状岗位情况以及人生理想。然后说主管可以再面一下，然后就被问了GC，类加载，spring源码，算法源码，hash，网络和加密算法什么的，回答了大概，spring源码还没准备过。。。但是主管人也很好，一直鼓励你。让我在凉凉边缘多次拯救。 进公司就不用多说了，导师很牛，培训很多，制度也很完善，没有加班，人文关怀也特别优秀，节假日会有礼物，日常还有零食，来zoom不吃亏！（在职舔狗，性感评价）&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/discuss/158738&quot;&gt;https://www.nowcoder.com/discuss/158738&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;一面&lt;/p&gt;

    &lt;p&gt;大概面了30分钟，面试官估计是以后的同事&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;自我介绍&lt;/li&gt;
      &lt;li&gt;问了问读了什么书&lt;/li&gt;
      &lt;li&gt;围绕项目问了一些实现的问题&lt;/li&gt;
      &lt;li&gt;Redis场景题：
        &lt;ul&gt;
          &lt;li&gt;如果有一个for循环，不停地进行SET操作，且每次SET的key不一样，可能会循环上万次。这样的话应该怎么优化（redis管道流执行命令，不会返回每次执行的结果，主要用于批量执行命令）(https://www.jianshu.com/p/84b655a55bf5)&lt;/li&gt;
          &lt;li&gt;用Redis做缓存的时候，说说详细流程，怎么防脏读&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Spring的AOP&lt;/li&gt;
      &lt;li&gt;Spring怎么实现事务，事务有哪些隔离级别&lt;/li&gt;
      &lt;li&gt;Java基本类型的封包拆包&lt;/li&gt;
      &lt;li&gt;举个线程不安全的例子&lt;/li&gt;
      &lt;li&gt;关于线程的使用的场景题&lt;/li&gt;
      &lt;li&gt;CAS的具体实现&lt;/li&gt;
      &lt;li&gt;MySQL有哪些索引，有什么区别&lt;/li&gt;
      &lt;li&gt;SQL语句调优会吗，有哪些调优方式&lt;/li&gt;
      &lt;li&gt;关于我们公司，有什么想问我的吗&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;二面&lt;/p&gt;

    &lt;p&gt;面试官开会去了，等了大概20分钟，面了50分钟左右&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;自我介绍&lt;/li&gt;
      &lt;li&gt;继续聊项目&lt;/li&gt;
      &lt;li&gt;说了项目的表结构&lt;/li&gt;
      &lt;li&gt;项目部分功能的具体实现&lt;/li&gt;
      &lt;li&gt;提了一些项目上可能会遇到的问题，问我怎么解决&lt;/li&gt;
      &lt;li&gt;感觉收获很大，很多自己以前没有考虑&lt;/li&gt;
      &lt;li&gt;Java8有什么新的特性&lt;/li&gt;
      &lt;li&gt;Java怎么具体实现的ThreadLocal&lt;/li&gt;
      &lt;li&gt;线程有哪些状态&lt;/li&gt;
      &lt;li&gt;讲讲线程池，都有哪些参数&lt;/li&gt;
      &lt;li&gt;说说常用的线程同步的方法&lt;/li&gt;
      &lt;li&gt;浏览器请求URL到返回页面的详细过程(如果是localhost呢)&lt;/li&gt;
      &lt;li&gt;三次握手、四次挥手的详细过程&lt;/li&gt;
      &lt;li&gt;讲讲Java都有哪些锁，他们有什么区别&lt;/li&gt;
      &lt;li&gt;说说你会什么容器，然后挑了HashMap和TreeMap问&lt;/li&gt;
      &lt;li&gt;说说你会什么并发容器，挑了ConcurrentHashMap的具体实现问&lt;/li&gt;
      &lt;li&gt;Web后台一些功能实现的场景题&lt;/li&gt;
      &lt;li&gt;项目用了Spring Boot，问了问内嵌的服务器还有做了哪些配置&lt;/li&gt;
      &lt;li&gt;AOP有什么用？有些名词你知道吗？&lt;/li&gt;
      &lt;li&gt;说说jdk动态***和CGLIB有什么区别&lt;/li&gt;
      &lt;li&gt;对什么设计模式比较熟？挑了适配器、装饰器和***模式问&lt;/li&gt;
      &lt;li&gt;用过Spring Cloud吗(不会，但谈了谈Dubbo和ZooKeeper)&lt;/li&gt;
      &lt;li&gt;会前端吗，有了解过什么&lt;/li&gt;
      &lt;li&gt;打算做后台什么方向&lt;/li&gt;
      &lt;li&gt;关于我们公司有什么想问我的吗&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;三面(HR)&lt;/p&gt;

    &lt;p&gt;后来才发现，来的是人力资源的经理(哦豁)&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;哪里人&lt;/li&gt;
      &lt;li&gt;对工资有什么要求吗&lt;/li&gt;
      &lt;li&gt;打算读研吗&lt;/li&gt;
      &lt;li&gt;有没有女朋友&lt;/li&gt;
      &lt;li&gt;每周可以保证来几天&lt;/li&gt;
      &lt;li&gt;什么时候可以来上班&lt;/li&gt;
      &lt;li&gt;聊完后，去和Boss打了招呼后，就送我离开公司了&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 05 Mar 2020 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/03/05/interview/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/03/05/interview/</guid>
        
        <category>学习</category>
        
        
      </item>
    
  </channel>
</rss>
