I"<h4 id="架构">架构</h4>

<blockquote>
  <p>大型网站技术架构</p>
</blockquote>

<blockquote>
  <p><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/website-architecture/8%20%E5%BC%A0%E5%9B%BE%E8%AF%BB%E6%87%82%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84">https://snailclimb.gitee.io/javaguide/#/docs/system-design/website-architecture/8%20%E5%BC%A0%E5%9B%BE%E8%AF%BB%E6%87%82%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84</a></p>
</blockquote>

<ul>
  <li>
    <p>分层：应用层、服务层、数据层</p>
  </li>
  <li>分布式集群：均衡负载</li>
  <li>数据库读写分离</li>
  <li>缓存：CDN、反向代理、分布式缓存的一致性Hash算法</li>
  <li>异步：提高系统可用性，加快网站响应速度，消除并发访问高峰</li>
  <li>代码优化：多线程（IO阻塞与多CPU）</li>
  <li>
    <p>应用服务器的session管理：session复制、session绑定、利用cookie记录session、session服务器</p>
  </li>
  <li>性能：TPS、HPS、QPS。系统吞吐量显示逐渐增加，达到一个极限后，随着并发数的增加反而下降，达到系统崩溃点后，系统资源耗尽，吞吐量为零。响应时间则是现保持小幅上升，到达吞吐量极限后，快速上升，到达系统崩溃点后，系统失去响应。</li>
  <li>CAP原理：数据一致性（数据强一致、数据用户一致、数据最终一致）、数据可用性、分区耐受性（系统具有跨网络分区的伸缩性）</li>
</ul>

<p>网络安全</p>

<ul>
  <li>
    <p><strong>XSS攻击：跨站点脚本攻击(Cross Site Script)</strong>，指黑客通过篡改网页，<strong>注入恶意HTML脚本</strong>，在用户浏览网页时，控制用户浏览器进行恶意操作的一种攻击方式。</p>

    <p>手段：消毒、HTTPOnly</p>
  </li>
  <li>
    <p>注入攻击：<strong>SQL注入攻击，攻击者在HTTP请求中注入恶意SQL命令(drop table users;)</strong>，服务器用请求参数构造数据库SQL命令时，恶意SQL被一起构造，并在数据库中执行。</p>

    <p>手段：关闭错误回显、消毒、参数绑定</p>
  </li>
  <li>
    <p><strong>CSRF攻击</strong>（Cross Site Request Forgery，跨站点请求伪造）：<strong>攻击者通过跨站请求，以合法的用户身份进行非法操作</strong>。</p>

    <p>手段：表单Token、验证码、Referer check</p>
  </li>
</ul>

<p>信息加密技术可以分为三类：单项散列加密、对称加密和非对称加密</p>

<ul>
  <li>
    <p>单项散列加密</p>

    <p>单向散列加密是指通过对不同输入长度的信息进行散列计算，得到固定长度的输出，这个散列计算过程是单向的，即不能对固定长度的输出进行计算从而获得输入信息。</p>

    <p>利用单向散列加密的这个特性，可以进行密码加密保存，即用户注册时输入的密码不直接保存到数据库，而是对密码进行单向散列加密，将密文存入数据库，用户登录时，进行密码验证。同样计算得到输入密码的密文，并和数据库中的密文比较，如果一致，则密码验证成功。</p>

    <p>这样保存在数据库中的是用户输入的密码的密文，而且不可逆地计算得到密码的明文，因此即使数据库被“拖库”，也不会泄露用户的密码信息。</p>

    <p>虽然不能通过算法将单向散列密文反算得到密文，但是由于人们设置密码具有一定的模式，因此通过彩虹表（人们常用密码和对应的密文关系表）等手段可以进行猜测式破解。</p>

    <p>为了加强单项散列计算的安全性，还会给散列算法加点盐，盐相当于加密的密钥，增加破解难度。</p>

    <p>常用的单项散列算法有MD5、SHA等。单项散列算法还有一个特点就是输入的任何微小变化都会导致输出的完全不同，这个特性有时也会被用来生成摘要信息、计算具有高离散程度的随机数等用途。</p>
  </li>
  <li>
    <p>对称加密</p>

    <p>对称加密是指加密和解密使用的密钥是同一个密钥（或者可以互相推算）。</p>

    <p>对称加密通常用在信息需要安全交换或存储的场合，如Cookie加密、通信加密等。</p>

    <p>对称加密的优点市算法简单，加解密效率高，系统开销小，适合对大量数据加密。缺点市加解密使用同一个密钥，远程通信的情况下如何安全地交换密钥是个难题，如果密钥丢失，那么所有的加密信息也就没有秘密可言了。</p>

    <p>常用的对称加密算法有DES算法、RC算法等。对称加密是一种传统加密手段，也是最常用的加密手段，适合于绝大多数需要加密的场合。</p>
  </li>
  <li>
    <p>非对称加密</p>

    <p>不同于对称加密，非对称加密和解密使用的密钥不是同一密钥，其中一个对外界公开，被称作公钥，另一个只有所有者知道，被称为私钥。用公钥加密的信息必须用私钥才能解开，反之，用私钥加密的信息只有用公钥才能解开。</p>

    <p>非对称加密技术通常用在信息安全传输，数字签名等场合。</p>

    <p>信息发送者A通过公开渠道获得信息接受者B的公钥，对提交信息进行加密，然后通过非安全传输通道将密文信息发送给B，B得到密文信息后，用自己的私钥对信息进行解密，获得原始的明文信息。即使密文信息在传输过程中遭到窃取，窃取者没有解密密钥也无法还原明文。</p>

    <p>数字签名的过程则相反，签名者用自己的私钥对信息进行加密，然后发送给对方，接收方用签名者的公钥对信息进行解密，获得原始明文信息，由于私钥只有签名者拥有，因此该信息是不可抵赖的，具有签名性质。</p>

    <p>在实际应用中，常常会混合使用对称加密和非对称加密。先使用对称加密技术对对称密钥进行安全传输，然后使用对称加密技术进行信息加解密与交换。而有时，对同一个数据两次使用非对称加密，可同时实现信息安全传输与数字签名的目的。</p>

    <p>非对称加密的常用算法有RSA算法等。HTTPS传输中浏览器使用的数字证书实质上是经过权威机构认证的非对称加密的公钥。</p>
  </li>
</ul>

<blockquote>
  <p><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/website-architecture/%E5%85%B3%E4%BA%8E%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E4%BD%A0%E4%B8%8D%E5%BE%97%E4%B8%8D%E6%87%82%E7%9A%8410%E4%B8%AA%E9%97%AE%E9%A2%98?id=4-%e8%b0%88%e8%b0%88%e4%bd%a0%e5%af%b9%e5%be%ae%e6%9c%8d%e5%8a%a1%e9%a2%86%e5%9f%9f%e7%9a%84%e4%ba%86%e8%a7%a3%e5%92%8c%e8%ae%a4%e8%af%86">https://snailclimb.gitee.io/javaguide/#/docs/system-design/website-architecture/%E5%85%B3%E4%BA%8E%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E4%BD%A0%E4%B8%8D%E5%BE%97%E4%B8%8D%E6%87%82%E7%9A%8410%E4%B8%AA%E9%97%AE%E9%A2%98?id=4-%e8%b0%88%e8%b0%88%e4%bd%a0%e5%af%b9%e5%be%ae%e6%9c%8d%e5%8a%a1%e9%a2%86%e5%9f%9f%e7%9a%84%e4%ba%86%e8%a7%a3%e5%92%8c%e8%ae%a4%e8%af%86</a></p>
</blockquote>

<h3 id="1-你使用过哪些组件或者方法来提升网站性能可用性以及并发量">1. 你使用过哪些组件或者方法来提升网站性能,可用性以及并发量</h3>

<ol>
  <li><strong>提高硬件能力、增加系统服务器</strong>。（当服务器增加到某个程度的时候系统所能提供的并发访问量几乎不变，所以不能根本解决问题）</li>
  <li><strong>使用缓存</strong>（本地缓存：本地可以使用JDK自带的 Map、Guava Cache.分布式缓存：Redis、Memcache.本地缓存不适用于提高系统并发量，一般是用处用在程序中。比如Spring是如何实现单例的呢？大家如果看过源码的话，应该知道，Spring把已经初始过的变量放在一个Map中，下次再要使用这个变量的时候，先判断Map中有没有，这也就是系统中常见的单例模式的实现。）</li>
  <li><strong>消息队列</strong> （解耦+削峰+异步）</li>
  <li><strong>采用分布式开发</strong> （不同的服务部署在不同的机器节点上，并且一个服务也可以部署在多台机器上，然后利用 Nginx 负载均衡访问。这样就解决了单点部署(All In)的缺点，大大提高的系统并发量）</li>
  <li><strong>数据库分库（读写分离）、分表（水平分表、垂直分表）</strong></li>
  <li><strong>采用集群</strong> （多台机器提供相同的服务）</li>
  <li><strong>CDN 加速</strong> (将一些静态资源比如图片、视频等等缓存到离用户最近的网络节点)</li>
  <li><strong>浏览器缓存</strong></li>
  <li><strong>使用合适的连接池</strong>（数据库连接池、线程池等等）</li>
  <li><strong>适当使用多线程进行开发。</strong></li>
</ol>

<h3 id="2-设计高可用系统的常用手段">2. 设计高可用系统的常用手段</h3>

<ol>
  <li><strong>降级：</strong> 服务降级是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。降级往往会指定不同的级别，面临不同的异常等级执行不同的处理。根据服务方式：可以拒接服务，可以延迟服务，也有时候可以随机服务。根据服务范围：可以砍掉某个功能，也可以砍掉某些模块。总之服务降级需要根据不同的业务需求采用不同的降级策略。主要的目的就是服务虽然有损但是总比没有好；</li>
  <li><strong>限流：</strong> 防止恶意请求流量、恶意攻击，或者防止流量超出系统峰值；</li>
  <li><strong>缓存：</strong> 避免大量请求直接落到数据库，将数据库击垮；</li>
  <li><strong>超时和重试机制：</strong> 避免请求堆积造成雪崩；</li>
  <li><strong>回滚机制：</strong> 快速修复错误版本。</li>
</ol>

<h3 id="3-现代互联网应用系统通常具有哪些特点">3. 现代互联网应用系统通常具有哪些特点?</h3>

<ol>
  <li>高并发，大流量；</li>
  <li>高可用：系统7×24小时不间断服务；</li>
  <li>海量数据：需要存储、管理海量数据，需要使用大量服务器；</li>
  <li>用户分布广泛，网络情况复杂：许多大型互联网都是为全球用户提供服务的，用户分布范围广，各地网络情况千差万别；</li>
  <li>安全环境恶劣：由于互联网的开放性，使得互联网更容易受到攻击，大型网站几乎每天都会被黑客攻击；</li>
  <li>需求快速变更，发布频繁：和传统软件的版本发布频率不同，互联网产品为快速适应市场，满足用户需求，其产品发布频率是极高的；</li>
  <li>渐进式发展：与传统软件产品或企业应用系统一开始就规划好全部的功能和非功能需求不同，几乎所有的大型互联网网站都是从一个小网站开始，渐进地发展起来。</li>
</ol>

<h3 id="4-谈谈你对微服务领域的了解和认识">4. 谈谈你对微服务领域的了解和认识</h3>

<p>现在大公司都在用并且未来的趋势都是 Spring Cloud，而阿里开源的 Spring Cloud Alibaba 也是 Spring Cloud 规范的实现 。</p>

<p>我们通常把 Spring Cloud 理解为一系列开源组件的集合，但是 Spring Cloud并不是等同于 Spring Cloud Netflix 的 Ribbon、Feign、Eureka（停止更新）、Hystrix 这一套组件，而是抽象了一套通用的开发模式。它的目的是通过抽象出这套通用的模式，让开发者更快更好地开发业务。但是这套开发模式运行时的实际载体，还是依赖于 RPC、网关、服务发现、配置管理、限流熔断、分布式链路跟踪等组件的具体实现。</p>

<p>Spring Cloud Alibaba 是官方认证的新一套 Spring Cloud 规范的实现,Spring Cloud Alibaba 是一套国产开源产品集合，后续还会有中文 reference 和一些原理分析文章，所以，这对于国内的开发者是非常棒的一件事。阿里的这一举动势必会推动国内微服务技术的发展，因为在没有 Spring Cloud Alibaba 之前，我们的第一选择是 Spring Cloud Netflix，但是它们的文档都是英文的，出问题后排查也比较困难， 在国内并不是有特别多的人精通。Spring Cloud Alibaba 由阿里开源组件和阿里云产品组件两部分组成，其致力于提供微服务一站式解决方案，方便开发者通过 Spring Cloud 编程模型轻松开发微服务应用。</p>

<p>另外，Apache Dubbo Ecosystem 是围绕 Apache Dubbo 打造的微服务生态，是经过生产验证的微服务的最佳实践组合。在阿里巴巴的微服务解决方案中，Dubbo、Nacos 和 Sentinel，以及后续将开源的微服务组件，都是 Dubbo EcoSystem 的一部分。阿里后续也会将 Dubbo EcoSystem 集成到 Spring Cloud 的生态中。</p>

<h3 id="5-谈谈你对-dubbo-和-spring-cloud-的认识两者关系">5. 谈谈你对 Dubbo 和 Spring Cloud 的认识(两者关系)</h3>

<p>具体可以看公众号-阿里巴巴中间件的这篇文章:<a href="https://mp.weixin.qq.com/s/iNVctXw7tUGHhnF0hV84ww">独家解读：Dubbo Ecosystem - 从微服务框架到微服务生态</a></p>

<p>Dubbo 与 Spring Cloud 并不是竞争关系，Dubbo 作为成熟的 RPC 框架，其易用性、扩展性和健壮性已得到业界的认可。未来 Dubbo 将会作为 Spring Cloud Alibaba 的 RPC 组件，并与 Spring Cloud 原生的 Feign 以及 RestTemplate 进行无缝整合，实现“零”成本迁移。</p>

<p>在阿里巴巴的微服务解决方案中，Dubbo、Nacos 和 Sentinel，以及后续将开源的微服务组件，都是 Dubbo EcoSystem 的一部分。我们后续也会将 Dubbo EcoSystem 集成到 Spring Cloud 的生态中。</p>

<h3 id="6-性能测试了解吗说说你知道的性能测试工具">6. 性能测试了解吗?说说你知道的性能测试工具?</h3>

<p>性能测试指通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。性能测试是总称，通常细分为：</p>

<ol>
  <li><strong>基准测试：</strong> 在给系统施加较低压力时，查看系统的运行状况并记录相关数做为基础参考</li>
  <li><strong>负载测试：</strong> 是指对系统不断地增加压力或增加一定压力下的持续时间，直到系统的某项或多项性能指标达到安全临界值，例如某种资源已经达到饱和状态等 。此时继续加压，系统处理能力会下降。</li>
  <li><strong>压力测试：</strong> 超过安全负载情况下，不断施加压力（增加并发请求），直到系统崩溃或无法处理任何请求，依此获得系统最大压力承受能力。</li>
  <li><strong>稳定性测试：</strong> 被测试系统在特定硬件、软件、网络环境下，加载一定业务压力（模拟生产环境不同时间点、不均匀请求，呈波浪特性）运行一段较长时间，以此检测系统是否稳定。</li>
</ol>

<p>后端程序员或者测试平常比较常用的测试工具是 JMeter（官网：<a href="https://jmeter.apache.org/">https://jmeter.apache.org/</a>）。Apache JMeter 是一款基于Java的压力测试工具(100％纯Java应用程序)，旨在加载测试功能行为和测量性能。它最初被设计用于 Web 应用测试但后来扩展到其他测试领域。</p>

<h3 id="7-对于一个单体应用系统随着产品使用的用户越来越多网站的流量会增加最终单台服务器无法处理那么大的流量怎么办">7. 对于一个单体应用系统,随着产品使用的用户越来越多,网站的流量会增加,最终单台服务器无法处理那么大的流量怎么办?</h3>

<p>这个时候就要考虑扩容了。《亿级流量网站架构核心技术》这本书上面介绍到我们可以考虑下面几步来解决这个问题：</p>

<ul>
  <li>第一步，可以考虑简单的扩容来解决问题。比如增加系统的服务器，提高硬件能力等等。</li>
  <li>第二步，如果简单扩容搞不定，就需要水平拆分和垂直拆分数据／应用来提升系统的伸缩性，即通过扩容提升系统负载能力。</li>
  <li>第三步，如果通过水平拆分／垂直拆分还是搞不定，那就需要根据现有系统特性，架构层面进行重构甚至是重新设计，即推倒重来。</li>
</ul>

<p>对于系统设计，理想的情况下应支持线性扩容和弹性扩容，即在系统瓶颈时，只需要增加机器就可以解决系统瓶颈，如降低延迟提升吞吐量，从而实现扩容需求。</p>

<p>如果你想扩容，则支持水平/垂直伸缩是前提。在进行拆分时，一定要清楚知道自己的目的是什么，拆分后带来的问题如何解决，拆分后如果没有得到任何收益就不要为了
拆而拆，即不要过度拆分，要适合自己的业务。</p>

<h3 id="8-大表优化的常见手段">8. 大表优化的常见手段</h3>

<p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p>

<ol>
  <li><strong>限定数据的范围：</strong> 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；</li>
  <li><strong>读/写分离：</strong> 经典的数据库拆分方案，主库负责写，从库负责读；</li>
  <li><strong>垂直分区：</strong> <strong>根据数据库里面数据表的相关性进行拆分。</strong> 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。<strong>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。</strong> 如下图所示，这样来说大家应该就更容易理解了。<img src="https://user-gold-cdn.xitu.io/2018/6/16/164084354ba2e0fd?w=950&amp;h=279&amp;f=jpeg&amp;s=26015" alt="" /><strong>垂直拆分的优点：</strong> 可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。<strong>垂直拆分的缺点：</strong> 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</li>
  <li><strong>水平分区：</strong> <strong>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</strong> 水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。<img src="https://user-gold-cdn.xitu.io/2018/6/16/164084b7e9e423e3?w=690&amp;h=271&amp;f=jpeg&amp;s=23119" alt="数据库水平拆分" />水平拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 <strong>水平拆分最好分库</strong> 。水平拆分能够 <strong>支持非常大的数据量存储，应用端改造也少</strong>，但 <strong>分片事务难以解决</strong>  ，跨界点Join性能较差，逻辑复杂。《Java工程师修炼之道》的作者推荐 <strong>尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度</strong> ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。</li>
</ol>

<p><strong>下面补充一下数据库分片的两种常见方案：</strong></p>

<ul>
  <li><strong>客户端代理：</strong>  <strong>分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。</strong> 当当网的 <strong>Sharding-JDBC</strong> 、阿里的TDDL是两种比较常用的实现。</li>
  <li><strong>中间件代理：</strong> <strong>在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。</strong> 我们现在谈的 <strong>Mycat</strong> 、360的Atlas、网易的DDB等等都是这种架构的实现。</li>
</ul>

<h3 id="9-在系统中使用消息队列能带来什么好处">9. 在系统中使用消息队列能带来什么好处?</h3>

<p><strong>《大型网站技术架构》第四章和第七章均有提到消息队列对应用性能及扩展性的提升。</strong></p>

<h4 id="1-通过异步处理提高系统性能">1) 通过异步处理提高系统性能</h4>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/21/162e63a8e34ba534?w=910&amp;h=350&amp;f=jpeg&amp;s=29123" alt="通过异步处理提高系统性能" />
如上图，<strong>在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即 返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。</strong></p>

<p>通过以上分析我们可以得出<strong>消息队列具有很好的削峰作用的功能</strong>——即<strong>通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。</strong> 举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示：
<img src="https://user-gold-cdn.xitu.io/2018/4/21/162e64583dd3ed01?w=780&amp;h=384&amp;f=jpeg&amp;s=13550" alt="合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击" />
因为<strong>用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败</strong>。因此使用消息队列进行异步处理之后，需要<strong>适当修改业务流程进行配合</strong>，比如<strong>用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功</strong>，以免交易纠纷。这就类似我们平时手机订火车票和电影票。</p>

<h3 id="2-降低系统耦合性">2) 降低系统耦合性</h3>
<p>我们知道模块分布式部署以后聚合方式通常有两种：1.<strong>分布式消息队列</strong>和2.<strong>分布式服务</strong>。</p>

<blockquote>
  <p><strong>先来简单说一下分布式服务：</strong></p>
</blockquote>

<p>目前使用比较多的用来构建<strong>SOA（Service Oriented Architecture面向服务体系结构）</strong>的<strong>分布式服务框架</strong>是阿里巴巴开源的<strong>Dubbo</strong>.如果想深入了解Dubbo的可以看我写的关于Dubbo的这一篇文章：<strong>《高性能优秀的服务框架-dubbo介绍》</strong>：<a href="https://juejin.im/post/5acadeb1f265da2375072f9c">https://juejin.im/post/5acadeb1f265da2375072f9c</a></p>

<blockquote>
  <p><strong>再来谈我们的分布式消息队列：</strong></p>
</blockquote>

<p>我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。</p>

<p>我们最常见的<strong>事件驱动架构</strong>类似生产者消费者模式，在大型网站中通常用利用消息队列实现事件驱动结构。如下图所示：
<img src="https://user-gold-cdn.xitu.io/2018/4/21/162e6665fa394b3b?w=790&amp;h=290&amp;f=jpeg&amp;s=14946" alt="利用消息队列实现事件驱动结构" />
<strong>消息队列使利用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。</strong> 从上图可以看到<strong>消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合</strong>，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。<strong>对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计</strong>。</p>

<p>消息接受者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消息接受者订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。</p>

<p><strong>另外为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。</strong></p>

<p><strong>备注：</strong> 不要认为消息队列只能利用发布-订阅模式工作，只不过在解耦这个特定业务环境下是使用发布-订阅模式的，<strong>比如在我们的ActiveMQ消息队列中还有点对点工作模式</strong>，具体的会在后面的文章给大家详细介绍，这一篇文章主要还是让大家对消息队列有一个更透彻的了解。</p>

<blockquote>
  <p>这个问题一般会在上一个问题问完之后，紧接着被问到。“使用消息队列会带来什么问题？”这个问题要引起重视，一般我们都会考虑使用消息队列会带来的好处而忽略它带来的问题！</p>
</blockquote>

<h3 id="10-说说自己对-cap-定理base-理论的了解">10. 说说自己对 CAP 定理,BASE 理论的了解</h3>

<h4 id="cap-定理">CAP 定理</h4>

<p><img src="https://user-gold-cdn.xitu.io/2018/5/24/163912e973ecb93c?w=624&amp;h=471&amp;f=png&amp;s=32984" alt="CAP定理" />
在理论计算机科学中，CAP定理（CAP theorem），又被称作布鲁尔定理（Brewer’s theorem），它指出对于一个分布式计算系统来说，不可能同时满足以下三点：</p>

<ul>
  <li><strong>一致性（Consistence）</strong> :所有节点访问同一份最新的数据副本</li>
  <li><strong>可用性（Availability）</strong>:每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据</li>
  <li><strong>分区容错性（Partition tolerance）</strong> : 分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。</li>
</ul>

<p>CAP仅适用于原子读写的NOSQL场景中，并不适合数据库系统。现在的分布式系统具有更多特性比如扩展性、可用性等等，在进行系统设计和开发时，我们不应该仅仅局限在CAP问题上。</p>

<p><strong>注意：不是所谓的3选2（不要被网上大多数文章误导了）:</strong></p>

<p>大部分人解释这一定律时，常常简单的表述为：“一致性、可用性、分区容忍性三者你只能同时达到其中两个，不可能同时达到”。实际上这是一个非常具有误导性质的说法，而且在CAP理论诞生12年之后，CAP之父也在2012年重写了之前的论文。</p>

<p><strong>当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能2选1。也就是说当网络分区之后P是前提，决定了P之后才有C和A的选择。也就是说分区容错性（Partition tolerance）我们是必须要实现的。</strong></p>

<p>我在网上找了很多文章想看一下有没有文章提到这个不是所谓的3选2，用百度半天没找到了一篇，用谷歌搜索找到一篇比较不错的，如果想深入学习一下CAP就看这篇文章把，我这里就不多BB了：<strong>《分布式系统之CAP理论》 ：</strong> <a href="http://www.cnblogs.com/hxsyl/p/4381980.html">http://www.cnblogs.com/hxsyl/p/4381980.html</a></p>

<h4 id="base-理论">BASE 理论</h4>

<p><strong>BASE</strong> 是 <strong>Basically Available（基本可用）</strong> 、<strong>Soft-state（软状态）</strong> 和 <strong>Eventually Consistent（最终一致性）</strong> 三个短语的缩写。BASE理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的，它大大降低了我们对系统的要求。</p>

<p><strong>BASE理论的核心思想：</strong> 即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。也就是牺牲数据的一致性来满足系统的高可用性，系统中一部分数据不可用或者不一致时，仍需要保持系统整体“主要可用”。</p>

<p><strong>BASE理论三要素：</strong></p>

<p><img src="https://user-gold-cdn.xitu.io/2018/5/24/163914806d9e15c6?w=612&amp;h=461&amp;f=png&amp;s=39129" alt="BASE理论三要素" /></p>

<ol>
  <li><strong>基本可用：</strong> 基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。 比如： <strong>①响应时间上的损失</strong>:正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障，查询结果的响应时间增加了1~2秒；<strong>②系统功能上的损失</strong>：正常情况下，在一个电子商务网站上进行购物的时候，消费者几乎能够顺利完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面；</li>
  <li><strong>软状态：</strong> 软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时；</li>
  <li><strong>最终一致性：</strong> 最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</li>
</ol>

<h4 id="zookeeper">ZooKeeper</h4>

<blockquote>
  <p>从PAXOS到ZOOKEEPER分布式一致性原理与实践</p>
</blockquote>

<ul>
  <li>
    <p>ACID</p>

    <p>事务是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元，狭义上的事务特之数据库事务。一方面，当多个应用程序并发访问数据库时，事务可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。另一方面，事务为数据库操作系列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持数据一致性的方法。</p>

    <p><strong>原子性</strong></p>

    <p>事务的原子性是指事务必须是一个原子的操作序列单元。事务中包含的各项操作在一次执行过程中，只允许出现以下两种状态之一。</p>

    <ul>
      <li>全部成功执行。</li>
      <li>全部不执行。</li>
    </ul>

    <p>任何一项操作失败都将导致整个事务失败，同时其他已经被执行的操作都将被撤销并回滚，只有所有的操作全部成功，整个事务才算是成功完成。</p>

    <p><strong>一致性</strong></p>

    <p>事务的一致性是指事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处于一致性状态。也就是说，事务执行的结果必须是使数据库从一个一致性状态转变到另一个一致性状态，因此当数据库系统在运行过程中发生故障，有些事务被迫中断，这些未完成的事务对数据库所作的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态。</p>

    <p><strong>隔离性</strong></p>

    <p>事务的隔离性是指在并发环境中，并发的事务是相互隔离的，一个事务的执行不能被其他事务干扰。也就是说，不同的事务并发操纵相同的数据时，每个事务都有各自完整的数据空间，即一个事务内部的操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>

    <p><strong>持久性</strong></p>

    <p>事务的持久性也被称为永久性，是指一个事务一旦提交，它对数据库中对应数据的状态变更就应该是永久的。换句话说，一旦某个事务成功结束，那么它对数据库所做的更新就必须被永久保存下来————即使发生系统崩溃或机器宕机等故障，只要数据库能够重新启动，那么一定能够将其恢复到事务成功结束时的状态。</p>
  </li>
  <li>
    <p>CAP定理</p>

    <p>一个分布式系统不可能同时满足一致性、可用性和分区容忍性这三个基本需求，最多只能同时满足其中的两项。</p>

    <p><strong>一致性</strong></p>

    <p>在分布式环境中，一致性是指数据在多个副本直接按是否能够保持一致的特性。在一致性的需求下，当一个系统在数据一致的状态下执行更新操作后，应该保证系统的数据仍然处于一致的状态。</p>

    <p>对于一个将数据副本分布在不同分布式节点上的系统来说，如果对第一个节点的数据进行了更新操作并且更新成功后，却没有使第二个节点上的数据得到相应的更新，于是在对第二个节点的数据进行读取操作时，获取的依然时老数据（或成为脏数据），这就是典型的分布式数据不一致的情况。在分布式系统中，如果能够做到针对一个数据项的更新操作执行成功后，所有的用户都可以读取到其最新的值，那么这个系统就被认为具有强一致性。</p>

    <p><strong>可用性</strong></p>

    <p>可用性是指系统提供的服务必须一致处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。这里我们重点看下“有限的时间内”和“返回结果”。</p>

    <p>“有限的时间内”是指，对于用户的一个操作请求，系统必须能够在指定的时间（即响应时间）内返回对应的处理结果，如果超过了这个时间范围，那么系统就被认为是不可用的。另外，“有限的时间”是指一个在系统设定好的系统运行指标，通常不同的系统之间可能会有很大的不同。比如说，对于一个在线搜索引擎来说，通常在0.5秒内需要给出用户搜索关键词对应的检索结果。</p>

    <p>从上面的例子中，我们可以看出用户对于一个系统的请求响应时间的期望值不尽相同。但是，无论系统之间的差异有多大，唯一相同的一点就是对于用户请求，系统必须存在一个合理的响应时间，否则用户便会对系统感到失望。</p>

    <p>“返回结果”是可用性的另一个非常重要的指标，它要求系统在完成对用户请求的处理后，返回一个正常的响应结果。正常的响应结果通常能够明确地反映出对请求的处理结果，即成功或失败，而不是一个让用户感到困惑的返回结果。</p>

    <p>让我们再来看看上面提到的在线搜索引擎的例子，如果用户输入指定的搜索关键词后，返回的结果是一个系统错误，通常类似于“OutOfMemoryError”或“System Has Crashed”等提示语，那么我们认为此时的系统是不可用的。</p>

    <p><strong>分区容忍性</strong></p>

    <p>分区容忍性约束了一个分布式系统需要具有如下特性：分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。</p>

    <p>网络分区是指在分布式系统中，不同的节点分布在不同的子网络（集放或异地网络等）中，由于一些特殊的原因导致这些子网络之间出现网络不连通的状况，但各个子网络的内部网络是正常的，从而导致整个系统的网络环境被切分成若干个孤立的区域。需要注意的是，组成一个分布式系统的每个节点的加入与退出都可以看作是一个特殊的网络分区。</p>
  </li>
  <li>
    <p>BASE理论</p>

    <p>BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写。NASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。</p>

    <p><strong>基本可用</strong></p>

    <p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性————但请注意，这绝不等价于系统不可用。以下就是两个“基本可用”的典型例子。</p>

    <ul>
      <li>响应时间上的损失：正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户响应的查询结果，但由于出现故障（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了1~2秒。</li>
      <li>功能上的损失：正常情况下，在一个电子商务网站上进行购物，消费者几乎能够顺利地完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，未来保护购物系统的稳定性，部分消费者可能会被引导到一个降级的页面。</li>
    </ul>

    <p><strong>弱状态</strong></p>

    <p>弱状态也称为软状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响达系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p>

    <p><strong>最终一致性</strong></p>

    <p>最终一致性强调的使系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p>
  </li>
  <li>
    <p>2PC</p>

    <p><strong>阶段一：提交事务请求</strong></p>

    <p>也称为投票阶段。</p>

    <p><strong>阶段二：执行事务提交</strong></p>

    <p>加入协调者从所有的参与者获得的反馈都是Yes相应，那么就会执行事务提交。</p>

    <p>假如任何一个参与者向协调者反馈了No相应，或者在等待超时之后，协调者尚无法接受到所有参与者的反馈相应，那么就会中断事务。</p>

    <p>两阶段提交将一个事务的处理方式分为了<strong>投票</strong>和<strong>执行</strong>两个阶段，其核心时对每个事务都采用先尝试后提交的处理方式。</p>
  </li>
  <li>
    <p>3PC</p>

    <p>三阶段提交是两阶段提交的改进版，将两阶段提交协议的提交事务请求（投票）过程一分为二，形成由CanCommit、PreCommit和doCommit三个阶段组成的事务处理协议。</p>

    <p><strong>阶段一：CanCommit</strong></p>

    <p><strong>阶段二：PreCommit</strong></p>

    <p>执行事务预提交：假设协调者从所有的参与者获得的反馈都是Yes相应，那么就会执行事务预提交。</p>

    <p>中断事务：假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么会中断事务。</p>

    <p><strong>阶段三：doCommit</strong></p>

    <p>该阶段将进行真正的事务。</p>
  </li>
  <li>
    <p>Paxos算法</p>

    <p>拜占庭将军问题：在分布式计算领域，试图在异步系统和不可靠的信道尚来达到一致性状态时不可能的，因此在对一致性的研究过程中，都往往假设信道是可靠的。</p>
  </li>
</ul>

<blockquote>
  <p><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/ZooKeeper-plus">https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/ZooKeeper-plus</a></p>
</blockquote>

<ul>
  <li>ZooKeeper 是一个 分布式协调服务框架。</li>
  <li>Eureka 的处理方式保证了AP（可用性），ZooKeeper 的处理方式保证了CP（数据一致性）。</li>
  <li>
    <p>Paxos 算法</p>

    <p>Paxos 算法是基于消息传递且具有高度容错特性的一致性算法，是目前公认的解决分布式一致性问题最有效的算法之一，其解决的问题就是在分布式系统中如何就某个值（决议）达成一致 。</p>

    <p>在 Paxos 中主要有三个角色，分别为 Proposer提案者、Acceptor表决者、Learner学习者。Paxos 算法和 2PC 一样，也有两个阶段，分别为 Prepare 和 accept 阶段。</p>

    <p><strong>prepare 阶段</strong></p>

    <p><strong>Proposer提案者</strong>：负责提出 proposal，<strong>每个提案者在提出提案时都会首先获取到一个 具有全局唯一性的、递增的提案编号N</strong>，即在整个集群中是唯一的编号 N，然后将该编号赋予其要提出的提案，在第一阶段是只将提案编号发送给所有的表决者。</p>

    <p><strong>Acceptor表决者</strong>：每个表决者在 accept 某提案后，会将该提案编号N记录在本地，这样每个表决者中保存的已经被 accept 的提案中会存在一个编号最大的提案，其编号假设为 maxN。<strong>每个表决者仅会 accept 编号大于自己本地 maxN 的提案</strong>，在批准提案时表决者会将以前接受过的最大编号的提案作为响应反馈给 Proposer 。</p>

    <p><strong>accept 阶段</strong></p>

    <p><strong>当一个提案被 Proposer 提出后，如果 Proposer 收到了超过半数的 Acceptor 的批准（Proposer 本身同意），那么此时 Proposer 会给所有的 Acceptor 发送真正的提案（你可以理解为第一阶段为试探）</strong>，这个时候 Proposer 就会发送提案的内容和提案编号。</p>

    <p><strong>表决者收到提案请求后会再次比较本身已经批准过的最大提案编号和该提案编号，如果该提案编号 大于等于 已经批准过的最大提案编号，那么就 accept 该提案</strong>（此时执行提案内容但不提交），随后将情况返回给 Proposer 。如果不满足则不回应或者返回 NO 。</p>

    <p><strong>当 Proposer 收到超过半数的 accept ，那么它这个时候会向所有的 acceptor 发送提案的提交请求</strong>。需要注意的是，因为上述仅仅是超过半数的 acceptor 批准执行了该提案内容，其他没有批准的并没有执行该提案内容，所以这个时候需要向未批准的 acceptor 发送提案内容和提案编号并让它无条件执行和提交，而对于前面已经批准过该提案的 acceptor 来说 仅仅需要发送该提案的编号 ，让 acceptor 执行提交就行了。</p>

    <p>而如果 Proposer 如果没有收到超过半数的 accept 那么它将会将 递增 该 Proposal 的编号，然后 重新进入 Prepare 阶段 。</p>
  </li>
</ul>

<h4 id="springcloud">SpringCloud</h4>

<blockquote>
  <p><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/micro-service/spring-cloud">https://snailclimb.gitee.io/javaguide/#/docs/system-design/micro-service/spring-cloud</a></p>
</blockquote>

<blockquote>
  <p>构建分布式系统不需要复杂和容易出错。Spring Cloud 为最常见的分布式系统模式提供了一种简单且易于接受的编程模型，帮助开发人员构建有弹性的、可靠的、协调的应用程序。Spring Cloud 构建于 Spring Boot 之上，使得开发者很容易入手并快速应用于生产中。</p>
</blockquote>

<p>我所理解的 <strong>Spring Cloud 就是微服务系统架构的一站式解决方案</strong>，在平时我们构建微服务的过程中需要做如 <strong>服务发现注册</strong> 、配置中心 、消息总线 、<strong>负载均衡</strong> 、<strong>断路器</strong> 、数据监控 等操作，而 <strong>Spring Cloud 为我们提供了一套简易的编程模型，使我们能在 Spring Boot 的基础上轻松地实现微服务项目的构建。</strong></p>

<h4 id="kafka">Kafka</h4>

<blockquote>
  <p><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/data-communication/kafka-inverview?id=kafka-%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e6%b6%88%e6%81%af%e4%b8%8d%e4%b8%a2%e5%a4%b1">https://snailclimb.gitee.io/javaguide/#/docs/system-design/data-communication/kafka-inverview?id=kafka-%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e6%b6%88%e6%81%af%e4%b8%8d%e4%b8%a2%e5%a4%b1</a></p>
</blockquote>

<h4 id="限流算法">限流算法</h4>

<blockquote>
  <p><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/micro-service/limit-request">https://snailclimb.gitee.io/javaguide/#/docs/system-design/micro-service/limit-request</a></p>
</blockquote>

<ul>
  <li>固定窗口计数器算法</li>
  <li>滑动窗口计数器算法</li>
  <li>漏桶算法</li>
  <li>令牌桶算法</li>
</ul>

<h4 id="微服务">微服务</h4>

<blockquote>
  <p><a href="https://www.zhihu.com/question/65502802">https://www.zhihu.com/question/65502802</a></p>
</blockquote>

<p>完全拆分后各个服务可以采用异构的技术。比如数据分析服务可以使用数据仓库作为持久化层，以便于高效地做一些统计计算；商品服务和促销服务访问频率比较大，因此加入了缓存机制等。</p>

<p>微服务架构还有一个技术外的好处，它使整个系统的分工更加明确，责任更加清晰，每个人专心负责为其他人提供更好的服务。</p>

<p>微服务架构整个应用分散成多个服务，定位故障点非常困难。在微服务架构中，一个服务故障可能会产生雪崩效用，导致整个系统故障。</p>

<h4 id="云计算">云计算</h4>

<p>云计算是一种商业计算模型。它将计算任务分布在大量计算机构成的资源池上，使各种应用系统能够根据需要获取计算力、存储空间和信息服务。</p>

<p>云计算的三种服务模式</p>

<ul>
  <li>SaaS(Software as a Service，软件即服务)</li>
  <li>PaaS(Platform as a Service，平台即服务)</li>
  <li>IaaS(Infrastructure as a Service，基础架构即服务)</li>
</ul>

<p>云计算的基础技术</p>

<ul>
  <li>虚拟化技术：系统虚拟化的目的是通过使用虚拟化管理器（Virtual Machine Monitor，简称VMM）在一台物理机上虚拟和运行一台或多台虚拟机（Virtual Machine，简称VM）。</li>
  <li>容器技术：提供应用运行的环境支持；封装系统资源，提供应用SDK；对应用进行管理、统计</li>
</ul>

<h4 id="docker">Docker</h4>

<blockquote>
  <p><a href="https://snailclimb.gitee.io/javaguide/#/docs/tools/Docker">https://snailclimb.gitee.io/javaguide/#/docs/tools/Docker</a></p>
</blockquote>

<p>容器虚拟化的是操作系统而不是硬件，容器之间是共享同一套操作系统资源的。虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统。因此容器的隔离级别会稍低一些。</p>
:ET